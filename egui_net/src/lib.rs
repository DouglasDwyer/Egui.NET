#![allow(warnings)]

#![feature(thread_local)]

use egui::*;
use egui::ecolor::*;
use egui::emath::*;
use egui::epaint::*;
use egui::epaint::tessellator::*;
use egui::epaint::text::*;
use egui::epaint::text::cursor::*;
use egui::Id;
use egui::collapsing_header::*;
use egui::containers::*;
use egui::containers::menu::*;
use egui::layers::*;
use egui::load::*;
use egui::os::*;
use egui::output::*;
use egui::panel::*;
use egui::scroll_area::*;
use egui::style::*;
use egui::text::*;
use egui::text_edit::*;
use egui::text_selection::*;
use egui::util::undoer::*;
use serde::*;
use serde::de::*;
use std::borrow::*;
use std::collections::*;
use std::ffi::*;
use std::marker::PhantomData;
use std::mem::*;
use std::ops::*;
use std::time::*;
use std::panic;
use std::panic::catch_unwind;
use std::sync::*;

include!(concat!(env!("CARGO_MANIFEST_DIR"), "/../target/bindings/egui_fn.rs"));

/// A registry containing all `egui` functions callable from C#.
const EGUI_FNS: EguiFnMap = AUTOGENERATED_EGUI_FNS
    // Bindings for AreaState
    .with_byref(EguiFn::egui_containers_area_AreaState_load, (|ctx: &Context, id: Id| AreaState::load(ctx, id)) as fn(&_, _) -> _)
    // Bindings for CentralPanel
    .with_byref(EguiFn::egui_containers_panel_CentralPanel_show, (|ctx: &Context, panel: CentralPanel, callback: EguiCallback| unsafe {
        panel.show(ctx, |ui| {
            callback.invoke(ui as *const _ as *const _);
        }).response
    }) as fn(&_, _, _) -> _)
    .with_byref(EguiFn::egui_containers_panel_CentralPanel_show_inside, (|ui: &mut Ui, panel: CentralPanel, callback: EguiCallback| unsafe {
        panel.show_inside(ui, |ui| {
            callback.invoke(ui as *const _ as *const _);
        }).response
    }) as fn(&mut _, _, _) -> _)
    // Bindings for Context
    .with(EguiFn::egui_context_Context_default, (|| EguiHandle::to_heap(Context::default())) as fn() -> _)
    .with_byref(EguiFn::egui_context_Context_request_discard, (|ctx: &Context, x: String| ctx.request_discard(x)) as fn(&_, _) -> _)
    .with_byref(EguiFn::egui_context_Context_layer_painter, (|ctx: &Context, layer_id: LayerId| EguiHandle::to_heap(ctx.layer_painter(layer_id))) as fn(&_, _) -> _)
    .with_byref(EguiFn::egui_context_Context_debug_painter, (|ctx: &Context| EguiHandle::to_heap(ctx.debug_painter())) as fn(&_) -> _)
    .with_byref(EguiFn::egui_context_Context_inspection_ui, (|ctx: &Context, mut ui: EguiPointer<Ui>| unsafe { ctx.inspection_ui(ui.get_mut()) }) as fn(&_, _) -> _)
    .with_byref(EguiFn::egui_context_Context_loaders_ui, (|ctx: &Context, mut ui: EguiPointer<Ui>| unsafe { ctx.loaders_ui(ui.get_mut()) }) as fn(&_, _) -> _)
    .with_byref(EguiFn::egui_context_Context_memory_ui, (|ctx: &Context, mut ui: EguiPointer<Ui>| unsafe { ctx.memory_ui(ui.get_mut()) }) as fn(&_, _) -> _)
    .with_byref(EguiFn::egui_context_Context_settings_ui, (|ctx: &Context, mut ui: EguiPointer<Ui>| unsafe { ctx.settings_ui(ui.get_mut()) }) as fn(&_, _) -> _)
    .with_byref(EguiFn::egui_context_Context_style_ui, (|ctx: &Context, mut ui: EguiPointer<Ui>, theme: Theme| unsafe { ctx.style_ui(ui.get_mut(), theme) }) as fn(&_, _, _) -> _)
    .with_byref(EguiFn::egui_context_Context_texture_ui, (|ctx: &Context, mut ui: EguiPointer<Ui>| unsafe { ctx.texture_ui(ui.get_mut()) }) as fn(&_, _) -> _)
    .with_byref(EguiFn::egui_context_Context_run, (|ctx: &Context, raw_input: RawInput, callback: EguiCallback| unsafe {
        ctx.run(raw_input, |ctx| {
            callback.invoke(std::ptr::null());
        })
    }) as fn(&_, _, _) -> _)
    // Bindings for Grid
    .with_byref(EguiFn::egui_grid_Grid_show, (|ui: &mut Ui, grid: Grid, callback: EguiCallback| unsafe {
        grid.show(ui, |ui| {
            callback.invoke(ui as *const _ as *const _);
        }).response
    }) as fn(&mut _, _, _) -> _)
    // Bindings for Id
    .with(EguiFn::egui_id_Id_new, (|source: String| Id::new(source)) as fn(_) -> _)
    .with(EguiFn::egui_id_Id_with, (|this: Id, child: String| this.with(child)) as fn(_, _) -> _)
    // Bindings for Popup
    .with_byref(EguiFn::egui_containers_popup_Popup_close_all, (|ctx: &Context| Popup::close_all(ctx)) as fn(&_) -> _)
    .with_byref(EguiFn::egui_containers_popup_Popup_close_id, (|ctx: &Context, id: Id| Popup::close_id(ctx, id)) as fn(&_, _) -> _)
    .with_byref(EguiFn::egui_containers_popup_Popup_open_id, (|ctx: &Context, id: Id| Popup::open_id(ctx, id)) as fn(&_, _) -> _)
    .with_byref(EguiFn::egui_containers_popup_Popup_toggle_id, (|ctx: &Context, id: Id| Popup::toggle_id(ctx, id)) as fn(&_, _) -> _)
    .with_byref(EguiFn::egui_containers_popup_Popup_is_any_open, (|ctx: &Context| Popup::is_any_open(ctx)) as fn(&_) -> _)
    .with_byref(EguiFn::egui_containers_popup_Popup_is_id_open, (|ctx: &Context, id: Id| Popup::is_id_open(ctx, id)) as fn(&_, _) -> _)
    .with_byref(EguiFn::egui_containers_popup_Popup_position_of_id, (|ctx: &Context, id: Id| Popup::position_of_id(ctx, id)) as fn(&_, _) -> _)
    // Bindings for RawInput
    .with(EguiFn::egui_data_input_RawInput_append, (|mut this: RawInput, newer: RawInput| {
        this.append(newer);
        this
    }) as fn(_, _) -> _)
    .with(EguiFn::egui_data_input_RawInput_take, (|mut this: RawInput| {
        let new = this.take();
        (this, new)
    }) as fn(_) -> _)
    .with(EguiFn::egui_data_input_RawInput_viewport, (|this: RawInput| this.viewport().clone()) as fn(_) -> _)
    // Bindings for Rect
    .with(EguiFn::emath_rect_Rect_center, Rect::center as fn(&_) -> _)
    .with(EguiFn::emath_rect_Rect_set_center, (|mut r: Rect, p: Pos2| { r.set_center(p); r }) as fn(_, _) -> _)
    .with(EguiFn::emath_rect_Rect_extend_with, (|mut r: Rect, p: Pos2| { r.extend_with(p); r }) as fn(_, _) -> _)
    .with(EguiFn::emath_rect_Rect_extend_with, (|mut r: Rect, p: Pos2| { r.extend_with(p); r }) as fn(_, _) -> _)
    .with(EguiFn::emath_rect_Rect_extend_with_x, (|mut r: Rect, p: f32| { r.extend_with_x(p); r }) as fn(_, _) -> _)
    .with(EguiFn::emath_rect_Rect_extend_with_y, (|mut r: Rect, p: f32| { r.extend_with_y(p); r }) as fn(_, _) -> _)
    // Bindings for RectAlign
    .with(EguiFn::emath_rect_align_RectAlign_find_best_align, (|values_to_try: Vec<RectAlign>, screen_rect: Rect, parent_rect: Rect, gap: f32, expected_size: Vec2| RectAlign::find_best_align(values_to_try.into_iter(), screen_rect, parent_rect, gap, expected_size)) as fn(_, _, _, _, _) -> _)
    // Bindings for Sense
    .with(EguiFn::egui_sense_Sense_interactive, (|x: u8| Sense::from_bits_truncate(x).interactive()) as fn(_) -> _)
    .with(EguiFn::egui_sense_Sense_senses_click, (|x: u8| Sense::from_bits_truncate(x).senses_click()) as fn(_) -> _)
    .with(EguiFn::egui_sense_Sense_senses_drag, (|x: u8| Sense::from_bits_truncate(x).senses_drag()) as fn(_) -> _)
    .with(EguiFn::egui_sense_Sense_is_focusable, (|x: u8| Sense::from_bits_truncate(x).is_focusable()) as fn(_) -> _)
    // Bindings for Ui
    .with_byref(EguiFn::egui_ui_Ui_allocate_painter, (|ui: &mut Ui, desired_size: Vec2, sense: Sense| {
        let (response, painter) = ui.allocate_painter(desired_size, sense);
        (response, EguiHandle::to_heap(painter))
    }) as fn(&mut _, _, _) -> _)
    .with_byref(EguiFn::egui_ui_Ui_painter, (|ui: &Ui| EguiHandle::to_heap(ui.painter().clone())) as fn(&_) -> _)
    .with_byref(EguiFn::egui_ui_Ui_painter, (|ui: &Ui, rect: Rect| EguiHandle::to_heap(ui.painter_at(rect))) as fn(&_, _) -> _)
    .with_byref(EguiFn::egui_ui_Ui_spacing, (|ui: &Ui| ui.spacing().clone()) as fn(&_) -> _)
    .with_byref(EguiFn::egui_ui_Ui_style, (|ui: &Ui| ui.style().clone()) as fn(&_) -> _)
    .with_byref(EguiFn::egui_ui_Ui_layout, (|ui: &Ui| ui.layout().clone()) as fn(&_) -> _)
    .with_byref(EguiFn::egui_ui_Ui_visuals, (|ui: &Ui| ui.visuals().clone()) as fn(&_) -> _)
    .with_byref(EguiFn::egui_ui_Ui_stack, (|ui: &Ui| ui.stack().clone()) as fn(&_) -> _)
    .with_byref(EguiFn::egui_ui_Ui_separator, (|ui: &mut Ui| ui.separator()) as fn(&mut _) -> _)
    // Bindings for WidgetText
    .with(EguiFn::egui_widget_text_WidgetText_text, (|x: WidgetText| x.text().to_string()) as fn(_) -> _)
    // Bindings for Window
    .with_byref(EguiFn::egui_containers_window_Window_show, (|ctx: &Context, window: SerializableWindow, open: Option<bool>, add_contents: EguiCallback| unsafe {
        let window = Window::from(window);
        if let Some(mut is_open) = open {
            let response = window.open(&mut is_open).show(ctx, |ui| add_contents.invoke(ui as *const _ as *const _));
            (response.map(|x| x.response), is_open)
        }
        else {
            let response = window.show(ctx, |ui| add_contents.invoke(ui as *const _ as *const _));
            (response.map(|x| x.response), true)
        }
    }) as fn(&_, _, _, _) -> _);

/// A C# callback for `egui` to invoke.
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EguiCallback {
    /// The function to call.
    func: unsafe extern "C" fn(*const c_void, *const c_void),
    /// Data to pass as the second function argument.
    data: *const c_void
}

impl EguiCallback {
    /// Invokes the callback.
    /// 
    /// # Safety
    /// 
    /// All invariants for [`Self::func`] must be satisfied.
    pub unsafe fn invoke(&self, argument: *const c_void) {
        (self.func)(argument, self.data)
    }
}

impl Serialize for EguiCallback {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: Serializer {
        [self.func as usize, self.data as usize].serialize(serializer)
    }
}

impl<'a> Deserialize<'a> for EguiCallback {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: Deserializer<'a> {
        unsafe {
            let [func, data] = <[usize; 2] as Deserialize<'a>>::deserialize(deserializer)?;
            Ok(Self {
                func: transmute(func),
                data: data as *const _
            })
        }
    }
}

/// An `egui` object that is passed by reference.
#[derive(Copy, Clone, Serialize, Deserialize)]
#[repr(C)]
pub struct EguiPointer<T> {
    /// The underlying pointer.
    ptr: usize,
    /// Marker data identifying the type.
    marker: PhantomData<*mut T>
}

impl<T> EguiPointer<T> {
    /// Gets a reference to the underlying object.
    /// 
    /// # Safety
    /// 
    /// The pointer must be valid, and no mutable references may exist to it.
    pub unsafe fn get(&self) -> &T {
        &*(self.ptr as *const _)
    }

    /// Gets a mutable reference to the underlying object.
    /// 
    /// # Safety
    /// 
    /// The pointer must be valid, and no other references may exist to it.
    pub unsafe fn get_mut(&mut self) -> &mut T {
        &mut *(self.ptr as *mut _)
    }
}

/// Represents a heap-allocated `egui` object.
#[derive(Copy, Clone, Serialize, Deserialize)]
#[repr(C)]
pub struct EguiHandle {
    /// A pointer to the object.
    ptr: usize,
    /// Metadata about the pointer used for internal purposes.
    metadata: usize
}

impl EguiHandle {
    /// Allocates `value` on the heap and returns a handle to it.
    pub fn to_heap<T: 'static>(value: T) -> Self {
        let ptr = Box::into_raw(Box::new(value)) as usize;
        let metadata = std::ptr::drop_in_place::<T> as usize;
        Self {
            ptr,
            metadata
        }
    }
}

/*
#[derive(Copy, Clone, Serialize, Deserialize)]
#[repr(C)]
pub struct EguiPtr<T> {
    ptr: usize,
    
}

impl<T> EguiPtr<T> {
    pub unsafe fn get(&self) 0
} 
*/

/// Describes the result of an `egui` call.
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EguiInvokeResult {
    /// Whether `return_value` holds a serialized value or an error string.
    pub success: bool,
    /// If [`Self::success`], then the serialized data that the function returned.
    /// Otherwise, holds a UTF8 string describing what went wrong.
    pub return_value: EguiSliceU8
}

/// Describes a section of a `u8` array.
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EguiSliceU8 {
    /// A pointer to the data buffer.
    pub ptr: *const u8,
    /// The length of the data in bytes.
    pub len: usize
}

impl EguiSliceU8 {
    /// Converts `x` to an FFI-compatible slice.
    /// 
    /// # Safety
    /// 
    /// The lifetime of the returned slice should not outlive `x`. 
    pub const fn from_slice(x: &[u8]) -> Self {
        Self {
            ptr: x.as_ptr(),
            len: x.len()
        }
    }

    /// Converts this object to a Rust slice pointer.
    /// 
    /// # Safety
    /// 
    /// For this function call to be sound, `self` must refer
    /// to a valid array of `u8` with at least [`Self::len`] elements.
    pub unsafe fn to_ptr(&self) -> *const [u8] {
        if self.len == 0 {
            &[]
        }
        else {
            std::slice::from_raw_parts(self.ptr, self.len)
        }
    }

    /// Converts this object to a Rust slice.
    /// 
    /// # Safety
    /// 
    /// For this function call to be sound, `self` must refer
    /// to a valid array of `u8` with at least [`Self::len`] elements.
    pub unsafe fn to_slice(&self) -> &[u8] {
        if self.len == 0 {
            &[]
        }
        else {
            std::slice::from_raw_parts(self.ptr, self.len)
        }
    }
}

/// Initializes the `egui` bindings library.
#[no_mangle]
pub unsafe extern "C" fn egui_init() {
    panic::set_hook(Box::new(|_| ()));
}

#[no_mangle]
pub unsafe extern "C" fn egui_invoke(f: EguiFn, ptr: usize, args: EguiSliceU8) -> EguiInvokeResult {
    /// The serialization buffer to which results will be written.
    #[thread_local]
    static mut RETURN_BUFFER: Vec<u8> = Vec::new();

    match catch_unwind(|| {
        if let Some(invoker) = EGUI_FNS.inner[f as usize] {
            invoker.invoke(ptr as *mut _, args.to_ptr(), std::ptr::addr_of_mut!(RETURN_BUFFER));
            EguiInvokeResult {
                success: true,
                return_value: EguiSliceU8::from_slice(&*std::ptr::addr_of_mut!(RETURN_BUFFER))
            }
        }
        else {
            panic!("Function {f:?} not implemented")
        }
    }) {
        Ok(x) => x,
        Err(error) => {
            let error_message = error.downcast_ref::<&'static str>()
                .map(|x| x.to_string())
                .unwrap_or_else(|| error.downcast_ref::<String>().cloned().unwrap_or_default());
            
            let return_buffer = &mut *std::ptr::addr_of_mut!(RETURN_BUFFER);
            return_buffer.clear();
            for character in error_message.encode_utf16() {
                return_buffer.extend(character.to_ne_bytes());
            }

            EguiInvokeResult {
                success: false,
                return_value: EguiSliceU8::from_slice(&return_buffer)
            }
        }
    }
}

/// Frees an `egui` object from the heap.
#[no_mangle]
pub unsafe extern "C" fn egui_drop(handle: EguiHandle) {
    transmute::<_, unsafe fn(usize)>(handle.metadata)(handle.ptr)
}

/// Holds bindings for all `egui` functions and allows for translating from [`EguiFn`] names to function pointers.
struct EguiFnMap {
    /// A mapping from [`EguiFn`] bindings to the underlying function to invoke.
    inner: [Option<EguiFnInvoker>; EguiFn::ALL.len()]
}

impl EguiFnMap {
    /// Adds a function (that has call-by-value semantics) and returns the new map.
    pub const fn with(mut self, binding: EguiFn, f: impl EguiFnInvokable) -> Self {
        self.inner[binding as usize] = Some(EguiFnInvoker::new(f));
        self
    }

    /// Adds a function (that has call-by-reference semantics) and returns the new map.
    pub const fn with_byref(mut self, binding: EguiFn, f: impl EguiFnRefInvokable) -> Self {
        self.inner[binding as usize] = Some(EguiFnInvoker::new_byref(f));
        self
    }
}

/// Creates a new, empty function map.
const fn egui_fn_map() -> EguiFnMap {
    EguiFnMap {
        inner: [None; EguiFn::ALL.len()]
    }
}

/// A type-erased `egui` function that may be called with serialized arguments/result.
#[derive(Copy, Clone, Debug)]
struct EguiFnInvoker {
    /// The `fn` object to pass to `func`.
    data: *const (),
    /// The [`EguiFnInvokable::invoke`] method to call.
    func: unsafe fn(*const (), *mut (), *const [u8], *mut Vec<u8>)
}

impl EguiFnInvoker {
    /// Stores the provided [`EguiFnInvokable`] on the stack for later use.
    /// `F` should be a `fn` pointer.
    pub const fn new<F: EguiFnInvokable>(f: F) -> Self {
        unsafe {
            if size_of::<F>() != size_of::<*const ()>() {
                panic!("Invokable function must be thin pointer");
            }

            Self {
                data: std::ptr::read(&f as *const _ as *const _),
                func: transmute(F::invoke as unsafe fn(_, _, _, _))
            }
        }
    }

    /// Stores the provided [`EguiFnRefInvokable`] on the stack for later use.
    /// `F` should be a `fn` pointer.
    pub const fn new_byref<F: EguiFnRefInvokable>(f: F) -> Self {
        unsafe {
            if size_of::<F>() != size_of::<*const ()>() {
                panic!("Invokable function must be thin pointer");
            }

            Self {
                data: std::ptr::read(&f as *const _ as *const _),
                func: transmute(F::invoke as unsafe fn(_, _, _, _))
            }
        }
    }

    /// Invokes the underlying function.
    /// 
    /// # Safety
    /// 
    /// For this function call to be sound, `ptr` must refer to a valid instance
    /// of the invoker function's type. 
    pub unsafe fn invoke(&self, ptr: *mut (), args: *const [u8], ret: *mut Vec<u8>) {
        (self.func)(&self.data as *const _ as *const _, ptr, args, ret)
    }
}

trait EguiFnInvokable: 'static + Copy + Send + Sync {
    unsafe fn invoke(&self, ptr: *mut (), args: *const [u8], ret: *mut Vec<u8>);
}

trait EguiFnRefInvokable: 'static + Copy + Send + Sync {
    unsafe fn invoke(&self, ptr: *mut (), args: *const [u8], ret: *mut Vec<u8>);
}

impl<T: 'static + Copy + Send + Sync + CallBorrow> EguiFnInvokable for T
where T::Input: 'static + DeserializeOwned, T::Output: Serialize
{
    unsafe fn invoke(&self, ptr: *mut (), args: *const [u8], ret: *mut Vec<u8>) {
        assert!(ptr.is_null(), "Attempted to call by-value method with object pointer");
        let deserialized_args = bincode::deserialize(&*args).expect("Failed to decode args");
        let result = self.call(deserialized_args);
        (*ret).clear();
        bincode::serialize_into(&mut *ret, &result).expect("Failed to encode result");
    }
}

impl<T: 'static + Copy + Send + Sync + CallBorrowRef> EguiFnRefInvokable for T
where T::Input: 'static + DeserializeOwned, T::Output: Serialize
{
    unsafe fn invoke(&self, ptr: *mut (), args: *const [u8], ret: *mut Vec<u8>) {
        let deserialized_args = bincode::deserialize(&*args).expect("Failed to decode args");
        let result = self.call(&mut *ptr.cast(), deserialized_args);
        (*ret).clear();
        bincode::serialize_into(&mut *ret, &result).expect("Failed to encode result");
    }
}

/// Implements [`CallBorrow`] for every possible combination of by-value and by-reference parameters.
macro_rules! impl_call_borrow {
    ({ $($ty_name:ident,)* }, { $($arg_name:ident,)* }) => {
        impl_call_borrow!({ $($ty_name,)* }, { $($arg_name,)* }, { }, { }, { }, { }, { });
    };
    ({ }, { }, { $($bounds: tt)* }, { $($args: tt)* }, { $($input_tys: tt)* }, { $($arg_names: tt)* }, { $($arg_borrows: tt )* }) => {
        impl<$($bounds)* R> CallBorrow for fn($($args)*) -> R {
            type Input = ($($input_tys)*);
            type Output = R;

            fn call(&self, ($($arg_names)*): Self::Input) -> Self::Output {
                self($($arg_borrows)*)
            }
        }

        impl<P, $($bounds)* R> CallBorrowRef for fn(&P, $($args)*) -> R {
            type Input = ($($input_tys)*);
            type Output = R;
            type Reference = P;

            fn call(&self, reference: &mut Self::Reference, ($($arg_names)*): Self::Input) -> Self::Output {
                self(reference, $($arg_borrows)*)
            }
        }

        impl<P, $($bounds)* R> CallBorrowRef for fn(&mut P, $($args)*) -> R {
            type Input = ($($input_tys)*);
            type Output = R;
            type Reference = P;

            fn call(&self, reference: &mut Self::Reference, ($($arg_names)*): Self::Input) -> Self::Output {
                self(reference, $($arg_borrows)*)
            }
        }
    };
    ({ $first_ty_name:ident, $($rest_ty_name:ident,)* }, { $first_arg_name:ident, $($rest_arg_name:ident,)* }, { $($bounds: tt)* }, { $($args: tt)* }, { $($input_tys: tt)* }, { $($arg_names: tt)* }, { $($arg_borrows: tt)* }) => {
        impl_call_borrow!({ $($rest_ty_name,)* }, { $($rest_arg_name,)* }, { $first_ty_name, $($bounds)* }, { $first_ty_name, $($args)* }, { $first_ty_name, $($input_tys)* }, { $first_arg_name, $($arg_names)* }, { $first_arg_name, $($arg_borrows)* });
        impl_call_borrow!({ $($rest_ty_name,)* }, { $($rest_arg_name,)* }, { $first_ty_name: ?Sized + ToOwned, $($bounds)* }, { &$first_ty_name, $($args)* }, { $first_ty_name::Owned, $($input_tys)* }, { $first_arg_name, $($arg_names)* }, { $first_arg_name.borrow(), $($arg_borrows)* });
    };
}

/// A trait that allows for passing *values* to a function, some of which
/// that function may take by immutable reference.
trait CallBorrow {
    /// A tuple containing the arguments for the function.
    type Input;
    /// The return type of the function.
    type Output;

    /// Invokes the function.
    fn call(&self, args: Self::Input) -> Self::Output;
}

impl<R> CallBorrow for fn() -> R {
    type Input = ();
    type Output = R;

    fn call(&self, (): Self::Input) -> Self::Output {
        self()
    }
}

/// A trait that allows for passing *values* to a function, some of which
/// that function may take by immutable reference.
/// The function acts on a reference type.
trait CallBorrowRef {
    /// A tuple containing the arguments for the function.
    type Input;
    /// The return type of the function.
    type Output;
    /// The type that will be passed by reference for the call.
    type Reference;

    /// Invokes the function.
    fn call(&self, reference: &mut Self::Reference, args: Self::Input) -> Self::Output;
}

impl<P, R> CallBorrowRef for fn(&P) -> R {
    type Input = ();
    type Output = R;
    type Reference = P;

    fn call(&self, reference: &mut Self::Reference, (): Self::Input) -> Self::Output {
        self(reference)
    }
}

impl<P, R> CallBorrowRef for fn(&mut P) -> R {
    type Input = ();
    type Output = R;
    type Reference = P;

    fn call(&self, reference: &mut Self::Reference, (): Self::Input) -> Self::Output {
        self(reference)
    }
}

impl_call_borrow!({ A0, }, { arg_0, });
impl_call_borrow!({ A0, A1, }, { arg_0, arg_1, });
impl_call_borrow!({ A0, A1, A2, }, { arg_0, arg_1, arg_2, });
impl_call_borrow!({ A0, A1, A2, A3, }, { arg_0, arg_1, arg_2, arg_3, });
impl_call_borrow!({ A0, A1, A2, A3, A4, }, { arg_0, arg_1, arg_2, arg_3, arg_4, });

/// Helper struct for serializing windows
#[derive(Clone, Serialize, Deserialize)]
struct SerializableWindow {
    title: WidgetText,
    area: Area,
    frame: Option<Frame>,
    resize: Resize,
    scroll: ScrollArea,
    collapsible: bool,
    default_open: bool,
    with_title_bar: bool,
    fade_out: bool,
}

impl<'a> From<SerializableWindow> for Window<'a> {
    fn from(value: SerializableWindow) -> Self {
        Window {
            title: value.title,
            open: None,
            area: value.area,
            frame: value.frame,
            resize: value.resize,
            scroll: value.scroll,
            collapsible: value.collapsible,
            default_open: value.default_open,
            with_title_bar: value.with_title_bar,
            fade_out: value.fade_out
        }
    }
}

/// Functions that can be run as tests.
#[cfg(test)]
mod tests {
    use super::*;
    
    /// Creates a list of all unbound methods and stubs for them. 
    #[test]
    fn report_unbound_methods() {
        let mut result = String::new();
        let mut bound = 0;

        for func in EguiFn::ALL {
            if EGUI_FNS.inner[*func as usize].is_none() {
                result += &format!("{func:?}\n");
            }
            else {
                bound += 1;
            }
        }
        
        result = format!("{bound} / {} ({}%) bound\n{result}", EguiFn::ALL.len(), (100.0 * bound as f32 / EguiFn::ALL.len() as f32).floor());
        std::fs::write("progress_report.txt", result).expect("Failed to write progress report");
    }
}