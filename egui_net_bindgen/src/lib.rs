#![feature(formatting_options)]

use convert_case::*;
use egui::*;
use egui::Id;
use egui::output::*;
use egui::panel::*;
use egui::scroll_area::*;
use egui::style::*;
use egui::text::*;
use egui::text_edit::*;
use egui::text_selection::*;
use egui::util::undoer::*;
use rustdoc_types::*;
use rustdoc_types::Id as RdId;
use serde_generate::*;
use serde_generate::csharp::*;
use serde_reflection::*;
use std::borrow::*;
use std::path::*;

/// A list of fully-qualified function IDs to ignore during generation.
const IGNORE_FNS: &[&str] = &[
    "alloc_borrow_Cow_as_str",
    "alloc_borrow_Cow_clear",
    "alloc_borrow_Cow_delete_char_range",
    "alloc_borrow_Cow_insert_text",
    "alloc_borrow_Cow_is_mutable",
    "alloc_borrow_Cow_replace_with",
    "alloc_borrow_Cow_take",
    "alloc_string_String_as_str",
    "alloc_string_String_clear",
    "alloc_string_String_delete_char_range",
    "alloc_string_String_insert_text",
    "alloc_string_String_is_mutable",
    "alloc_string_String_replace_with",
    "alloc_string_String_take",
    "egui_containers_frame_Frame_corner_radius",
    "egui_containers_frame_Frame_stroke",
    "egui_containers_frame_Frame_shadow",
    "egui_style_Visuals_window_stroke",
    "egui_containers_frame_Frame_inner_margin",
    "egui_style_Visuals_window_fill",
    "egui_style_ScrollAnimation_duration",
    "egui_data_output_WidgetInfo_selected",
    "egui_containers_frame_Frame_fill",
    "egui_style_ScrollStyle_floating",
    "egui_containers_frame_Frame_outer_margin",
    "egui_style_Style_text_styles",
    "egui_data_output_OpenUrl_new_tab",
    "egui_text_selection_cursor_range_CursorRange_on_event",
    "egui_viewport_ViewportIdPair_from_self_and_parent"
];

/// Function names to be ignored during generation.
const IGNORE_FN_NAMES: &[&str] = &[
    "bits",
    "cmp",
    "deserialize",
    "eq",
    "hash",
    "fmt",
    "from",
    "from_bits",
    "from_bits_retain",
    "partial_cmp",
    "serialize",
    "value"
];

include!(concat!(env!("OUT_DIR"), "/tracer.rs"));

/// Holds context for use during bindings generation.
pub struct BindingsGenerator {
    /// Metadata about the crate being generated.
    krate: Crate,
    /// The output path to which data will be written.
    output_path: PathBuf,
    /// A registry of reflected information about `egui` types.
    registry: Registry
}

impl BindingsGenerator {
    /// Creates autogenerated bindings for all `serde` types.
    pub fn generate(path: &std::path::Path) {
        BindingsGenerator {
            krate: serde_json::from_str::<Crate>(include_str!("egui.json")).expect("Failed to parse egui"),
            output_path: path.to_path_buf(),
            registry: Self::trace_serde_types()
        }.run()
    }

    /// Executes the bindings generator.
    fn run(mut self) {
        let path_to_clear = self.output_path.join("Egui");
        let _ = std::fs::remove_dir_all(path_to_clear);
        let _ = std::fs::create_dir_all(&self.output_path);

        let config = CodeGeneratorConfig::new("Egui".to_string())
            .with_serialization(true)
            .with_c_style_enums(true)
            .with_comments(self.gather_doc_comments());
        let generator = CodeGenerator::new(&config);

        self.emit_fn_enum();
        self.emit_cs_fn_bindings();
        self.rename_struct_fields();
        
        generator.write_source_files(self.output_path, &self.registry).expect("Failed to write source files");
    }

    /// Gets the C# name for a type, or returns [`None`] if the type
    /// could not be resolved.
    fn cs_type_name(&self, self_ty: Option<&str>, ty: &Type) -> Option<String> {
        Some(match ty {
            Type::ResolvedPath(path) => {
                let name = path.path.split("::").last().expect("Type was empty");
                if self.registry.contains_key(name) {
                    name.to_string()
                }
                else {
                    return None;
                }
            },
            Type::Generic(x) if x == "Self" => self_ty?.to_string(),
            Type::Primitive(x) => Self::cs_primitive_name(&x)?.to_string(),
            Type::Tuple(items) => format!("ValueTuple<{}>",
                items.iter().map(|x| self.cs_type_name(self_ty, x)).collect::<Option<Vec<_>>>()?.join(", ")),
            Type::Slice(type_)
            | Type::Array { type_, .. } => format!("ImmutableList<{}>", self.cs_type_name(self_ty, &type_)?),
            Type::ImplTrait(generic_bounds) => if format!("{generic_bounds:?}").contains("ToString") {
                "string".to_string()
            }
            else {
                return None
            },
            Type::BorrowedRef { is_mutable: false, type_, .. } => self.cs_type_name(self_ty, &type_)?,
            Type::DynTrait(_)
            | Type::Generic(_)
            | Type::Pat { .. }
            | Type::Infer
            | Type::RawPointer { .. }
            | Type::QualifiedPath { .. }
            | Type::BorrowedRef { is_mutable: true, .. }
            | Type::FunctionPointer(_) => return None,
        })
    }

    /// Determines whether the type with the given name has a particular field.
    fn ty_has_field(&self, ty_name: &str, field: &str) -> bool {
        if let Some(ContainerFormat::Struct(fields)) = self.registry.get(ty_name) {
            if fields.iter().find(|x| x.name == field).is_some() {
                return true;
            }
        }

        false
    }

    /// Emits a C# file containing bindings for `egui` functions.
    fn emit_cs_fn_bindings(&self) {
        let mut result = String::new();

        result += "#pragma warning disable\n";
        result += "using System.Collections.Immutable;\n";
        result += "namespace Egui;\n";

        for id in self.gather_fns() {
            let _ = self.emit_cs_fn_binding(&mut std::fmt::Formatter::new(&mut result, Default::default()), id);
        }

        std::fs::write(self.output_path.join("EguiFn.g.cs"), result).expect("Failed to write C# function bindings");
    }

    /// Writes a single C# method definition (with appropriate type qualifiers) to `f`.
    fn emit_cs_fn_binding(&self, f: &mut std::fmt::Formatter, id: RdId) -> std::fmt::Result {
        if let Some(impl_ty) = self.declaring_type(id).and_then(|x| self.krate.index.get(&x)) {
            if matches!(impl_ty.inner, ItemEnum::Struct(_)) {
                if let Some(ty_name) = impl_ty.name.as_deref() {
                    if self.registry.contains_key(ty_name) {
                        let mut fn_def = String::new();
                        self.emit_cs_fn(&mut std::fmt::Formatter::new(&mut fn_def, Default::default()), Some(ty_name), id)?;
                        writeln!(f, "public partial struct {ty_name} {{\n{fn_def}\n}}")?;
                    }
                }
            }
        }

        Ok(())
    }

    /// Writes a single C# method definition to `f`.
    fn emit_cs_fn(&self, f: &mut std::fmt::Formatter, ty_name: Option<&str>, id: RdId) -> std::fmt::Result {
        let item = &self.krate.index[&id];
        let ItemEnum::Function(func) = &item.inner else { panic!("Expected id to refer to a function") };

        let has_this = func.sig.inputs.first().map(|(name, _)| name == "self").unwrap_or_default();
        let returns_this = func.sig.output.as_ref().map(|x| x == &Type::Generic("Self".to_string())).unwrap_or_default();
        let original_name = item.name.as_deref().expect("Failed to get function name");
        let cs_name = original_name.to_case(Case::Pascal);

        if let Some(comment) = self.get_doc_comment(id) {
            writeln!(f, "/// {}", comment.replace("\n", "\n/// "))?;
        }

        if !has_this && returns_this && (cs_name == "New" || cs_name == "Default") {
            write!(f, "public {}", ty_name.expect("Expected type to be provided"))?;
            self.emit_cs_fn_def(f, ty_name, id, FnType::Constructor, &func.sig)?;
        }
        else {
            let return_name = func.sig.output.as_ref().and_then(|x| self.cs_type_name(ty_name, x))
                .unwrap_or("void".to_string());
            
            write!(f, "public {} {return_name} {}", ["static", "readonly"][has_this as usize], cs_name)?;

            self.emit_cs_fn_def(f, ty_name, id, [FnType::Static, FnType::Instance][has_this as usize], &func.sig)?;
        }

        Ok(())
    }

    /// Emits the body of a C# function (excluding the name and return type).
    fn emit_cs_fn_def(&self, f: &mut std::fmt::Formatter, ty_name: Option<&str>, id: RdId, ty: FnType, sig: &FunctionSignature) -> std::fmt::Result {
        write!(f, "(")?;
        
        let mut first = true;

        let mut generic_args = Vec::new();
        
        for (name, ty) in sig.inputs.iter().skip((ty == FnType::Instance) as usize) {
            if !first {
                write!(f, ", ")?;
            }

            first = false;

            let param_ty = self.cs_type_name(ty_name, ty).ok_or(std::fmt::Error)?;
            generic_args.push(param_ty.clone());
            let cs_name = name.to_case(Case::Camel);
            write!(f, "{param_ty} {cs_name}")?;
        }
        
        writeln!(f, ") {{");

        if let Some(return_ty) = &sig.output {
            generic_args.push(self.cs_type_name(ty_name, return_ty).ok_or(std::fmt::Error)?);

            if ty == FnType::Constructor {
                write!(f, "   this = ")?;
            }
            else {
                write!(f, "   return ")?;
            }
        }
        else {
            write!(f, "    ")?;
        }

        if generic_args.is_empty() {
            writeln!(f, "EguiMarshal.Call(")?;
        }
        else {
            writeln!(f, "EguiMarshal.Call<{}>(", generic_args.join(", "))?;
        }

        let enum_name = format!("EguiFn.{}", self.fn_enum_variant_name(id));
        write!(f, "{}", [enum_name].into_iter().chain(sig.inputs.iter().skip((ty == FnType::Instance) as usize).map(|(name, _)| name.to_case(Case::Camel)))
            .collect::<Vec<_>>().join(", "))?;
        writeln!(f, ");")?;

        writeln!(f, "}}")?;
        Ok(())
    }

    /// Emits an `enum` containing the names of all public `egui` functions.
    fn emit_fn_enum(&self) {
        let variants = self.fn_enum_variant_names();
        let mut result = String::new();
        
        result += "#[allow(warnings)]\n";
        result += "#[derive(Clone, Copy)]\n";
        result += "#[repr(C)]\n";
        result += "pub enum EguiFn {\n    ";
        result += &variants.join(",\n    ").trim();
        result += "}\n";

        result += "impl EguiFn {\n";
        result += "    /// All enum variants.\n";
        result += "    pub const ALL: &[Self] = &[\n    ";
        result += &variants.iter().map(|x| "Self::".to_string() + x).collect::<Vec<_>>().join(",\n    ").trim();
        result += "    ];\n";
        result += "}\n";

        std::fs::write(self.output_path.join("egui_fn.rs"), result).expect("Failed to write egui function enum");
    }

    /// Gets the variant names for an `enum` containing all public `egui` functions.
    fn fn_enum_variant_names(&self) -> Vec<String> {
        let mut result = self.gather_fns().into_iter().map(|id| self.fn_enum_variant_name(id)).collect::<Vec<_>>();
        result.sort();
        result
    }

    /// Gets the `EguiFn` variant name of `id`.
    fn fn_enum_variant_name(&self, id: RdId) -> String {
        if let Some(impl_ty) = self.declaring_type(id) {
            format!("{}_{}", self.krate.paths[&impl_ty].path.join("_"), self.krate.index[&id].name.clone().unwrap_or_default())
        }
        else if self.krate.paths.contains_key(&id) {
            format!("{}", self.krate.paths[&id].path.join("_"))
        }
        else {
            panic!("Item was not a bindable egui function")
        }
    }

    /// Gets all doc-comments to emit for types and fields.
    fn gather_doc_comments(&self) -> DocComments {
        let mut result = DocComments::default();
        for name in self.registry.keys() {
            if let Some(id) = self.get_type_id(name) {
                if let Some(docs) = self.get_doc_comment(id) {
                    result.insert(vec!["Egui".to_string(), name.clone()], docs);
                }

                let fields = match &self.krate.index[&id].inner {
                    ItemEnum::Struct(Struct { kind: StructKind::Plain { fields, .. }, .. }) => &**fields,
                    ItemEnum::Enum(Enum { variants, .. }) => &**variants,
                    _ => &[]
                };

                for field in fields {
                    let field_name = self.krate.index[field].name.clone().unwrap_or_default();
                    if let Some(docs) = self.get_doc_comment(*field) {
                        result.insert(vec!["Egui".to_string(), name.clone(), field_name.to_case(Case::Pascal)], docs);
                    }
                }
            }
        }
        result
    }

    /// Gets a list of all functions that should be bound for `egui`.
    fn gather_fns(&self) -> Vec<RdId> {
        self.krate.index.iter()
            .filter_map(|(id, item)| (
                item.crate_id == 0
                && matches!(item.inner, ItemEnum::Function(_))
                && (self.declaring_type(*id).is_some() || self.krate.paths.contains_key(id))
                && !IGNORE_FNS.contains(&&*self.fn_enum_variant_name(*id))
                && item.name.as_deref().map(|x| !IGNORE_FN_NAMES.contains(&x)).unwrap_or(true)
            ).then_some(id.clone()))
            .collect()
    }

    /// Gets the ID of the type that declares the given function.
    fn declaring_type(&self, fn_id: RdId) -> Option<RdId> {
        self.krate.index.values()
            .filter_map(|item| if let ItemEnum::Impl(Impl { for_: Type::ResolvedPath(p), items, .. }) = &item.inner {
                items.contains(&fn_id).then_some(p.id)
            }
            else {
                None
            })
            .next()
    }
    
    /// Renames all fields in the registry from Rust to C# casing.
    fn rename_struct_fields(&mut self) {
        for item in self.registry.values_mut() {
            match item {
                ContainerFormat::Struct(nameds) => for field in nameds {
                    field.name = field.name.to_case(Case::Pascal);
                },
                _ => {},
            }
        }
    }
    
    /// Gets the C# doc-comment to use for an item given its ID.
    fn get_doc_comment(&self, id: RdId) -> Option<String> {
        let docs = self.krate.index[&id].docs.clone().unwrap_or_default();
        let converted_docs = Self::inline_code_to_cs(&Self::strip_links(&Self::strip_code_comments(docs.trim_end())));
        if converted_docs.is_empty() {
            None
        }
        else {
            Some(format!("<summary>\n{converted_docs}\n</summary>"))
        }
    }
    
    /// Gets the `rustdoc` ID for a type given its name.
    fn get_type_id(&self, name: &str) -> Option<RdId> {
        self.krate.index.iter()
            .filter_map(|(id, item)| (matches!(item.inner, ItemEnum::Enum(_) | ItemEnum::Struct(_)) && item.name.as_deref() == Some(name)).then_some(id.clone()))
            .next()
    }

    /// Performs reflection on `egui` types to determine fields.
    fn trace_serde_types() -> Registry {
        let mut samples = Samples::new();
        let mut tracer = Tracer::new(TracerConfig::default()
            .default_u64_value(1)
            .record_samples_for_newtype_structs(true)
            .record_samples_for_tuple_structs(true)
            .record_samples_for_structs(true));

        trace_auto_serde_types(&mut tracer);

        tracer.trace_value(&mut samples, &Options::default()).expect("Failed to trace Options");
        tracer.trace_value(&mut samples, &UserData::default()).expect("Failed to trace UserData");
        
        tracer.trace_simple_type::<Align>().expect("Failed to trace Align");
        tracer.trace_simple_type::<FontFamily>().expect("Failed to trace FontFamily");
        tracer.trace_simple_type::<TextWrapMode>().expect("Failed to trace TextWrapMode");

        tracer.registry().expect("Failed to generate serde registry")
    }

    /// Removes all code examples from the given documentation string.
    fn strip_code_comments(docs: &str) -> String {
        let mut result = Cow::Borrowed(docs);
        while let Some(index) = result.find("```") {
            let base_offset = index + "```".len();
            if let Some(remaining) = result[base_offset..].find("```") {
                result = Cow::Owned(result[..index].trim_end().to_owned() + result[base_offset + remaining + "```".len()..].trim_start());
            }
            else {
                break;
            }
        }
        
        result.trim().to_string()
    }

    /// Removes all links from the given documentation string.
    fn strip_links(docs: &str) -> String {
        let mut result = Cow::Borrowed(docs);
        while let Some(index) = result.find("[") {
            let base_offset = index + "[".len();
            if let Some(remaining) = result[base_offset..].find("]") {
                let inner_text = result[base_offset..base_offset + remaining].to_string();
                let rest_begin = base_offset + remaining + "]".len();
                let final_offset = if result[rest_begin..].starts_with("(") {
                    rest_begin + result[rest_begin..].find(")").expect("Malformatted documentation link") + ")".len()
                }
                else {
                    rest_begin
                };

                result = Cow::Owned(result[..index].to_owned() + &inner_text + &result[final_offset..]);
            }
            else {
                break;
            }
        }
        
        result.trim().to_string()
    }

    /// Removes everything before the last instance of `ending` in `value`.
    fn strip_prefix_with_ending(value: &str, ending: &str) -> String {
        let mut start_pos = 0;
        while let Some(prefix) = value[start_pos..].find(ending) {
            start_pos = start_pos + prefix + ending.len();
        }
        value[start_pos..].to_string()
    }

    /// Converts all inline code snippets to their C# equivalent.
    fn inline_code_to_cs(docs: &str) -> String {
        let mut result = Cow::Borrowed(docs);
        while let Some(index) = result.find("`") {
            let base_offset = index + "`".len();
            if let Some(remaining) = result[base_offset..].find("`") {
                let end_offset = base_offset + remaining + "`".len();

                result = Cow::Owned(result[..index].to_owned()
                    + "<c>" + &Self::strip_prefix_with_ending(&result[base_offset..base_offset + remaining], "::").to_case(Case::Pascal) + "</c>"
                    + &result[end_offset..]);
            }
            else {
                break;
            }
        }
        
        result.trim().to_string()
    }

    /// Converts the given Rust primitive to a C# primitive, or returns
    /// [`None`] if the primitive was not recognized.
    fn cs_primitive_name(x: &str) -> Option<&'static str> {
        Some(match x {
            "bool" => "bool",
            "u8" => "byte",
            "u16" => "ushort",
            "u32" => "uint",
            "u64" => "ulong",
            "i8" => "sbyte",
            "i16" => "short",
            "i32" => "int",
            "i64" => "long",
            "f32" => "float",
            "f64" => "double",
            "isize" => "nint",
            "usize" => "nuint",
            _ => return None
        })
    }
}

/// How to emit a particular function.
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
enum FnType {
    /// The function should be treated as a constructor.
    Constructor,
    /// The function should be treated as an instance method.
    Instance,
    /// The function should be treated as a static method.
    Static
}