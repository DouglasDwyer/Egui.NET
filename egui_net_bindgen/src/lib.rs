use convert_case::*;
use egui::*;
use egui::Id;
use egui::output::*;
use egui::panel::*;
use egui::scroll_area::*;
use egui::style::*;
use egui::text::*;
use egui::text_edit::*;
use egui::text_selection::*;
use egui::util::undoer::*;
use rustdoc_types::*;
use rustdoc_types::Id as RdId;
use serde_generate::*;
use serde_generate::csharp::*;
use serde_reflection::*;
use std::borrow::*;
use std::path::*;

include!(concat!(env!("OUT_DIR"), "/tracer.rs"));

/// Holds context for use during bindings generation.
pub struct BindingsGenerator {
    /// Metadata about the crate being generated.
    krate: Crate,
    /// The output path to which data will be written.
    output_path: PathBuf,
    /// A registry of reflected information about `egui` types.
    registry: Registry
}

impl BindingsGenerator {
    /// Creates autogenerated bindings for all `serde` types.
    pub fn generate(path: &std::path::Path) {
        BindingsGenerator {
            krate: serde_json::from_str::<Crate>(include_str!("egui.json")).expect("Failed to parse egui"),
            output_path: path.to_path_buf(),
            registry: Self::trace_serde_types()
        }.run()
    }

    /// Executes the bindings generator.
    fn run(mut self) {
        let config = CodeGeneratorConfig::new("Egui".to_string())
            .with_serialization(true)
            .with_c_style_enums(true)
            .with_comments(self.gather_doc_comments());
        let generator = CodeGenerator::new(&config);

        self.rename_struct_fields();
        
        let path_to_clear = self.output_path.join("Egui");
        let _ = std::fs::remove_dir_all(path_to_clear);
        generator.write_source_files(self.output_path, &self.registry).expect("Failed to write source files");
    }

    /// Gets all doc-comments to emit for types and fields.
    fn gather_doc_comments(&self) -> DocComments {
        let mut result = DocComments::default();
        for name in self.registry.keys() {
            if let Some(id) = self.get_type_id(name) {
                if let Some(docs) = self.get_doc_comment(id) {
                    result.insert(vec!["Egui".to_string(), name.clone()], docs);
                }

                let fields = match &self.krate.index[&id].inner {
                    ItemEnum::Struct(Struct { kind: StructKind::Plain { fields, .. }, .. }) => &**fields,
                    ItemEnum::Enum(Enum { variants, .. }) => &**variants,
                    _ => &[]
                };

                for field in fields {
                    let field_name = self.krate.index[field].name.clone().unwrap_or_default();
                    if let Some(docs) = self.get_doc_comment(*field) {
                        result.insert(vec!["Egui".to_string(), name.clone(), field_name.to_case(Case::Pascal)], docs);
                    }
                }
            }
        }
        result
    }
    
    /// Renames all fields in the registry from Rust to C# casing.
    fn rename_struct_fields(&mut self) {
        for item in self.registry.values_mut() {
            match item {
                ContainerFormat::Struct(nameds) => for field in nameds {
                    field.name = field.name.to_case(Case::Pascal);
                },
                _ => {},
            }
        }
    }
    
    /// Gets the C# doc-comment to use for an item given its ID.
    fn get_doc_comment(&self, id: RdId) -> Option<String> {
        let docs = self.krate.index[&id].docs.clone().unwrap_or_default();
        let converted_docs = Self::inline_code_to_cs(&Self::strip_links(&Self::strip_code_comments(docs.trim_end())));
        if converted_docs.is_empty() {
            None
        }
        else {
            Some(format!("<summary>\n{converted_docs}\n</summary>"))
        }
    }
    
    /// Gets the `rustdoc` ID for a type given its name.
    fn get_type_id(&self, name: &str) -> Option<RdId> {
        self.krate.index.iter()
            .filter_map(|(id, item)| (matches!(item.inner, ItemEnum::Enum(_) | ItemEnum::Struct(_)) && item.name.as_deref() == Some(name)).then_some(id.clone()))
            .next()
    }

    /// Performs reflection on `egui` types to determine fields.
    fn trace_serde_types() -> Registry {
        let mut samples = Samples::new();
        let mut tracer = Tracer::new(TracerConfig::default()
            .default_u64_value(1)
            .record_samples_for_newtype_structs(true)
            .record_samples_for_tuple_structs(true)
            .record_samples_for_structs(true));

        trace_auto_serde_types(&mut tracer);

        tracer.trace_value(&mut samples, &Options::default()).expect("Failed to trace Options");
        tracer.trace_value(&mut samples, &UserData::default()).expect("Failed to trace UserData");
        
        tracer.trace_simple_type::<Align>().expect("Failed to trace Align");
        tracer.trace_simple_type::<FontFamily>().expect("Failed to trace FontFamily");
        tracer.trace_simple_type::<TextWrapMode>().expect("Failed to trace TextWrapMode");

        tracer.registry().expect("Failed to generate serde registry")
    }

    /// Removes all code examples from the given documentation string.
    fn strip_code_comments(docs: &str) -> String {
        let mut result = Cow::Borrowed(docs);
        while let Some(index) = result.find("```") {
            let base_offset = index + "```".len();
            if let Some(remaining) = result[base_offset..].find("```") {
                result = Cow::Owned(result[..index].trim_end().to_owned() + result[base_offset + remaining + "```".len()..].trim_start());
            }
            else {
                break;
            }
        }
        
        result.trim().to_string()
    }

    /// Removes all links from the given documentation string.
    fn strip_links(docs: &str) -> String {
        let mut result = Cow::Borrowed(docs);
        while let Some(index) = result.find("[") {
            let base_offset = index + "[".len();
            if let Some(remaining) = result[base_offset..].find("]") {
                let inner_text = result[base_offset..base_offset + remaining].to_string();
                let rest_begin = base_offset + remaining + "]".len();
                let final_offset = if result[rest_begin..].starts_with("(") {
                    rest_begin + result[rest_begin..].find(")").expect("Malformatted documentation link") + ")".len()
                }
                else {
                    rest_begin
                };

                result = Cow::Owned(result[..index].to_owned() + &inner_text + &result[final_offset..]);
            }
            else {
                break;
            }
        }
        
        result.trim().to_string()
    }

    /// Removes everything before the last instance of `ending` in `value`.
    fn strip_prefix_with_ending(value: &str, ending: &str) -> String {
        let mut start_pos = 0;
        while let Some(prefix) = value[start_pos..].find(ending) {
            start_pos = start_pos + prefix + ending.len();
        }
        value[start_pos..].to_string()
    }

    /// Converts all inline code snippets to their C# equivalent.
    fn inline_code_to_cs(docs: &str) -> String {
        let mut result = Cow::Borrowed(docs);
        while let Some(index) = result.find("`") {
            let base_offset = index + "`".len();
            if let Some(remaining) = result[base_offset..].find("`") {
                let end_offset = base_offset + remaining + "`".len();

                result = Cow::Owned(result[..index].to_owned()
                    + "<c>" + &Self::strip_prefix_with_ending(&result[base_offset..base_offset + remaining], "::").to_case(Case::Pascal) + "</c>"
                    + &result[end_offset..]);
            }
            else {
                break;
            }
        }
        
        result.trim().to_string()
    }
}