
namespace Vortex.Gui;

/// <summary>
/// Tracks which items have been autogenerated. This makes it easier to identify
/// which classes and methods must be bound by hand.
/// </summary>
internal static class AutogenStatistics {
    /// <summary>
    /// The list of all GUI items that must be bound for the GUI library to be complete.
    /// </summary>
    private static readonly IImmutableList<string> Items = ["AboveOrBelow", "Alpha", "CursorGrab", "CursorIcon", "Direction", "IMEPurpose", "MouseWheelUnit", "NumericColorSpace", "Order", "PointerButton", "PopupCloseBehavior", "ResizeDirection", "ScrollBarVisibility", "Side", "SliderClamping", "SliderOrientation", "SystemTheme", "Theme", "ThemePreference", "TopBottomSide", "TouchPhase", "UiKind", "UserAttentionType", "ViewportClass", "ViewportEvent", "WidgetType", "WindowLevel", "Area", "Areas", "BarState", "Button", "CacheStorage", "CentralPanel", "Checkbox", "CollapsingHeader", "CollapsingResponse", "CollapsingState", "ComboBox", "DebugRect", "DefaultBytesLoader", "DefaultTextureLoader", "DragAndDrop", "DragValue", "FrameCache", "FramePublisher", "Grid", "HeaderResponse", "Hyperlink", "IdTypeMap", "Image", "ImageButton", "ImmediateViewport", "InnerResponse", "InputOptions", "InputState", "InteractionSnapshot", "Label", "LabelSelectionState", "Link", "Memory", "MenuRootManager", "MenuState", "Modal", "ModalResponse", "Options", "Painter", "PassState", "PerLayerState", "PerWidgetTooltipState", "PointerState", "Prepared", "ProgressBar", "RadioButton", "Resize", "Response", "RichText", "Scene", "ScrollArea", "ScrollAreaOutput", "ScrollTarget", "SelectableLabel", "Separator", "SidePanel", "Sides", "Slider", "Spinner", "State", "SubMenu", "SubMenuButton", "TextCursorState", "TextEdit", "TextEditOutput", "TextEditState", "TooltipPassState", "TopBottomPanel", "Ui", "UiStack", "UiStackIterator", "Undoer", "ViewportState", "WidgetHits", "WidgetRects", "Window", "AreaState", "CCursorRange", "CursorRange", "DebugOptions", "DroppedFile", "EventFilter", "Frame", "HoveredFile", "IMEOutput", "ImageOptions", "ImageSize", "Interaction", "KeyboardShortcut", "LayerId", "Layout", "MenuRoot", "ModifierNames", "Modifiers", "MultiTouchInfo", "OpenUrl", "PCursorRange", "PlatformOutput", "RawInput", "RepaintCause", "RequestRepaintInfo", "RowVertexIndices", "ScrollAnimation", "ScrollStyle", "Selection", "Settings", "SizedTexture", "Spacing", "Style", "TextCursorStyle", "UiBuilder", "UiStackInfo", "UserData", "ViewportIdPair", "ViewportInfo", "Visuals", "WidgetInfo", "WidgetRect", "WidgetVisuals", "Widgets", "Area.New", "Area.Id", "Area.Kind", "Area.Layer", "Area.Enabled", "Area.Movable", "Area.IsEnabled", "Area.IsMovable", "Area.Interactable", "Area.Sense", "Area.Order", "Area.DefaultPos", "Area.DefaultSize", "Area.DefaultWidth", "Area.DefaultHeight", "Area.FixedPos", "Area.Constrain", "Area.ConstrainTo", "Area.Pivot", "Area.CurrentPos", "Area.Anchor", "Area.FadeIn", "Area.Show", "BarState.Load", "BarState.Store", "BarState.BarMenu", "Button.New", "Button.Image", "Button.ImageAndText", "Button.OptImageAndText", "Button.WrapMode", "Button.Wrap", "Button.Truncate", "Button.Fill", "Button.Stroke", "Button.Small", "Button.Frame", "Button.Sense", "Button.MinSize", "Button.CornerRadius", "Button.Rounding", "Button.ImageTintFollowsTextColor", "Button.ShortcutText", "Button.Selected", "CacheStorage.Cache", "CacheStorage.Update", "CentralPanel.Frame", "CentralPanel.ShowInside", "CentralPanel.Show", "Checkbox.New", "Checkbox.WithoutText", "Checkbox.Indeterminate", "CollapsingHeader.New", "CollapsingHeader.DefaultOpen", "CollapsingHeader.Open", "CollapsingHeader.IdSalt", "CollapsingHeader.IdSource", "CollapsingHeader.Enabled", "CollapsingHeader.ShowBackground", "CollapsingHeader.Icon", "CollapsingHeader.Show", "CollapsingHeader.ShowUnindented", "CollapsingResponse.HeaderResponse", "CollapsingResponse.BodyResponse", "CollapsingResponse.BodyReturned", "CollapsingResponse.Openness", "CollapsingResponse.FullyClosed", "CollapsingResponse.FullyOpen", "CollapsingState.Load", "CollapsingState.Store", "CollapsingState.Remove", "CollapsingState.Id", "CollapsingState.LoadWithDefaultOpen", "CollapsingState.IsOpen", "CollapsingState.SetOpen", "CollapsingState.Toggle", "CollapsingState.Openness", "CollapsingState.ShowHeader", "CollapsingState.ShowBodyIndented", "CollapsingState.ShowBodyUnindented", "CollapsingState.ShowToggleButton", "ComboBox.New", "ComboBox.FromLabel", "ComboBox.FromIdSalt", "ComboBox.FromIdSource", "ComboBox.Width", "ComboBox.Height", "ComboBox.SelectedText", "ComboBox.Icon", "ComboBox.WrapMode", "ComboBox.Wrap", "ComboBox.Truncate", "ComboBox.CloseBehavior", "ComboBox.ShowUi", "ComboBox.ShowIndex", "ComboBox.IsOpen", "DebugRect.Rect", "DebugRect.Callstack", "DebugRect.IsClicking", "DefaultBytesLoader.Insert", "DragAndDrop.SetPayload", "DragAndDrop.ClearPayload", "DragAndDrop.Payload", "DragAndDrop.TakePayload", "DragAndDrop.HasPayloadOfType", "DragAndDrop.HasAnyPayload", "DragValue.New", "DragValue.FromGetSet", "DragValue.Speed", "DragValue.ClampRange", "DragValue.Range", "DragValue.ClampExistingToRange", "DragValue.ClampToRange", "DragValue.Prefix", "DragValue.Suffix", "DragValue.MinDecimals", "DragValue.MaxDecimals", "DragValue.MaxDecimalsOpt", "DragValue.FixedDecimals", "DragValue.CustomFormatter", "DragValue.CustomParser", "DragValue.Binary", "DragValue.Octal", "DragValue.Hexadecimal", "DragValue.UpdateWhileEditing", "FrameCache.New", "FrameCache.EvictCache", "FrameCache.Get", "FramePublisher.New", "FramePublisher.Set", "FramePublisher.Get", "FramePublisher.EvictCache", "Grid.New", "Grid.WithRowColor", "Grid.NumColumns", "Grid.Striped", "Grid.MinColWidth", "Grid.MinRowHeight", "Grid.MaxColWidth", "Grid.Spacing", "Grid.StartRow", "Grid.Show", "HeaderResponse.IsOpen", "HeaderResponse.SetOpen", "HeaderResponse.Toggle", "HeaderResponse.Body", "HeaderResponse.BodyUnindented", "Hyperlink.New", "Hyperlink.FromLabelAndUrl", "Hyperlink.OpenInNewTab", "IdTypeMap.InsertTemp", "IdTypeMap.InsertPersisted", "IdTypeMap.GetTemp", "IdTypeMap.GetPersisted", "IdTypeMap.GetTempMutOr", "IdTypeMap.GetPersistedMutOr", "IdTypeMap.GetTempMutOrDefault", "IdTypeMap.GetPersistedMutOrDefault", "IdTypeMap.GetTempMutOrInsertWith", "IdTypeMap.GetPersistedMutOrInsertWith", "IdTypeMap.Remove", "IdTypeMap.RemoveTemp", "IdTypeMap.RemoveByType", "IdTypeMap.Clear", "IdTypeMap.IsEmpty", "IdTypeMap.Len", "IdTypeMap.CountSerialized", "IdTypeMap.Count", "IdTypeMap.MaxBytesPerType", "IdTypeMap.SetMaxBytesPerType", "Image.New", "Image.FromUri", "Image.FromTexture", "Image.FromBytes", "Image.TextureOptions", "Image.MaxWidth", "Image.MaxHeight", "Image.MaxSize", "Image.MaintainAspectRatio", "Image.FitToOriginalSize", "Image.FitToExactSize", "Image.FitToFraction", "Image.ShrinkToFit", "Image.Sense", "Image.Uv", "Image.BgFill", "Image.Tint", "Image.Rotate", "Image.CornerRadius", "Image.Rounding", "Image.ShowLoadingSpinner", "Image.AltText", "Image.CalcSize", "Image.LoadAndCalcSize", "Image.Size", "Image.Uri", "Image.ImageOptions", "Image.Source", "Image.LoadForSize", "Image.PaintAt", "ImageButton.New", "ImageButton.Uv", "ImageButton.Tint", "ImageButton.Selected", "ImageButton.Frame", "ImageButton.Sense", "ImageButton.CornerRadius", "ImageButton.Rounding", "ImmediateViewport.Ids", "ImmediateViewport.Builder", "ImmediateViewport.ViewportUiCb", "InnerResponse.Inner", "InnerResponse.Response", "InnerResponse.New", "InputOptions.MaxClickDist", "InputOptions.MaxClickDuration", "InputOptions.MaxDoubleClickDelay", "InputState.Raw", "InputState.Pointer", "InputState.RawScrollDelta", "InputState.SmoothScrollDelta", "InputState.ScreenRect", "InputState.PixelsPerPoint", "InputState.MaxTextureSide", "InputState.Time", "InputState.UnstableDt", "InputState.PredictedDt", "InputState.StableDt", "InputState.Focused", "InputState.Modifiers", "InputState.KeysDown", "InputState.Events", "InputState.BeginPass", "InputState.Viewport", "InputState.ScreenRect", "InputState.ZoomDelta", "InputState.ZoomDelta2D", "InputState.TimeSinceLastScroll", "InputState.WantsRepaintAfter", "InputState.CountAndConsumeKey", "InputState.ConsumeKey", "InputState.ConsumeShortcut", "InputState.KeyPressed", "InputState.NumPresses", "InputState.KeyDown", "InputState.KeyReleased", "InputState.PixelsPerPoint", "InputState.PhysicalPixelSize", "InputState.AimRadius", "InputState.MultiTouch", "InputState.AnyTouches", "InputState.HasTouchScreen", "InputState.FilteredEvents", "InputState.Ui", "InteractionSnapshot.Clicked", "InteractionSnapshot.LongTouched", "InteractionSnapshot.DragStarted", "InteractionSnapshot.Dragged", "InteractionSnapshot.DragStopped", "InteractionSnapshot.Hovered", "InteractionSnapshot.ContainsPointer", "Label.New", "Label.Text", "Label.WrapMode", "Label.Wrap", "Label.Truncate", "Label.Extend", "Label.Halign", "Label.Selectable", "Label.Sense", "Label.LayoutInUi", "LabelSelectionState.Load", "LabelSelectionState.Store", "LabelSelectionState.HasSelection", "LabelSelectionState.ClearSelection", "LabelSelectionState.LabelTextSelection", "Link.New", "Memory.Options", "Memory.Data", "Memory.Caches", "Memory.ToGlobal", "Memory.Areas", "Memory.AreasMut", "Memory.LayerIdAt", "Memory.LayerTransforms", "Memory.LayerIds", "Memory.HadFocusLastFrame", "Memory.HasFocus", "Memory.Focused", "Memory.SetFocusLockFilter", "Memory.RequestFocus", "Memory.SurrenderFocus", "Memory.IsAboveModalLayer", "Memory.AllowsInteraction", "Memory.InterestedInFocus", "Memory.SetModalLayer", "Memory.TopModalLayer", "Memory.StopTextInput", "Memory.IsAnythingBeingDragged", "Memory.IsBeingDragged", "Memory.DraggedId", "Memory.SetDraggedId", "Memory.StopDragging", "Memory.DraggingSomethingElse", "Memory.ResetAreas", "Memory.AreaRect", "Memory.IsPopupOpen", "Memory.AnyPopupOpen", "Memory.OpenPopup", "Memory.ClosePopup", "Memory.TogglePopup", "Memory.EverythingIsVisible", "Memory.SetEverythingIsVisible", "MenuRootManager.Show", "MenuState.Rect", "MenuState.Response", "MenuState.New", "MenuState.Close", "MenuState.AreaContains", "Modal.Area", "Modal.BackdropColor", "Modal.Frame", "Modal.New", "Modal.DefaultArea", "Modal.Frame", "Modal.BackdropColor", "Modal.Area", "Modal.Show", "ModalResponse.Response", "ModalResponse.BackdropResponse", "ModalResponse.Inner", "ModalResponse.IsTopModal", "ModalResponse.AnyPopupOpen", "ModalResponse.ShouldClose", "Options.DarkStyle", "Options.LightStyle", "Options.ThemePreference", "Options.FallbackTheme", "Options.ZoomFactor", "Options.ZoomWithKeyboard", "Options.TessellationOptions", "Options.RepaintOnWidgetChange", "Options.MaxPasses", "Options.ScreenReader", "Options.PreloadFontGlyphs", "Options.WarnOnIdClash", "Options.LineScrollSpeed", "Options.ScrollZoomSpeed", "Options.InputOptions", "Options.ReduceTextureMemory", "Options.Ui", "Painter.New", "Painter.WithLayerId", "Painter.WithClipRect", "Painter.SetLayerId", "Painter.SetFadeToColor", "Painter.SetOpacity", "Painter.MultiplyOpacity", "Painter.Opacity", "Painter.IsVisible", "Painter.SetInvisible", "Painter.Ctx", "Painter.PixelsPerPoint", "Painter.Fonts", "Painter.LayerId", "Painter.ClipRect", "Painter.ShrinkClipRect", "Painter.SetClipRect", "Painter.RoundToPixelCenter", "Painter.RoundPosToPixelCenter", "Painter.RoundToPixel", "Painter.RoundVecToPixels", "Painter.RoundPosToPixels", "Painter.RoundRectToPixels", "Painter.Add", "Painter.Extend", "Painter.Set", "Painter.ForEachShape", "Painter.DebugRect", "Painter.Error", "Painter.DebugText", "Painter.LineSegment", "Painter.Line", "Painter.Hline", "Painter.Vline", "Painter.Circle", "Painter.CircleFilled", "Painter.CircleStroke", "Painter.Rect", "Painter.RectFilled", "Painter.RectStroke", "Painter.Arrow", "Painter.Image", "Painter.Text", "Painter.Layout", "Painter.LayoutNoWrap", "Painter.LayoutJob", "Painter.Galley", "Painter.GalleyWithOverrideTextColor", "Painter.GalleyWithColor", "PassState.UsedIds", "PassState.Widgets", "PassState.Layers", "PassState.Tooltips", "PassState.AvailableRect", "PassState.UnusedRect", "PassState.UsedByPanels", "PassState.ScrollTarget", "PassState.ScrollDelta", "PassState.HighlightNextPass", "PassState.DebugRect", "PerLayerState.OpenPopups", "PerLayerState.WidgetWithTooltip", "PerWidgetTooltipState.BoundingRect", "PerWidgetTooltipState.TooltipCount", "PointerState.Delta", "PointerState.Motion", "PointerState.Velocity", "PointerState.Direction", "PointerState.PressOrigin", "PointerState.PressStartTime", "PointerState.LatestPos", "PointerState.HoverPos", "PointerState.InteractPos", "PointerState.HasPointer", "PointerState.IsStill", "PointerState.IsMoving", "PointerState.TimeSinceLastMovement", "PointerState.TimeSinceLastClick", "PointerState.AnyPressed", "PointerState.AnyReleased", "PointerState.ButtonPressed", "PointerState.ButtonReleased", "PointerState.PrimaryPressed", "PointerState.SecondaryPressed", "PointerState.PrimaryReleased", "PointerState.SecondaryReleased", "PointerState.AnyDown", "PointerState.AnyClick", "PointerState.ButtonClicked", "PointerState.ButtonDoubleClicked", "PointerState.ButtonTripleClicked", "PointerState.PrimaryClicked", "PointerState.SecondaryClicked", "PointerState.ButtonDown", "PointerState.CouldAnyButtonBeClick", "PointerState.IsDecidedlyDragging", "PointerState.PrimaryDown", "PointerState.SecondaryDown", "PointerState.MiddleDown", "PointerState.Ui", "Prepared.Frame", "Prepared.ContentUi", "Prepared.AllocateSpace", "Prepared.Paint", "Prepared.End", "ProgressBar.New", "ProgressBar.DesiredWidth", "ProgressBar.DesiredHeight", "ProgressBar.Fill", "ProgressBar.Text", "ProgressBar.ShowPercentage", "ProgressBar.Animate", "ProgressBar.CornerRadius", "ProgressBar.Rounding", "RadioButton.New", "Resize.Id", "Resize.IdSource", "Resize.IdSalt", "Resize.DefaultWidth", "Resize.DefaultHeight", "Resize.DefaultSize", "Resize.MinSize", "Resize.MinWidth", "Resize.MinHeight", "Resize.MaxSize", "Resize.MaxWidth", "Resize.MaxHeight", "Resize.Resizable", "Resize.IsResizable", "Resize.AutoSized", "Resize.FixedSize", "Resize.WithStroke", "Resize.Show", "Response.Ctx", "Response.LayerId", "Response.Id", "Response.Rect", "Response.InteractRect", "Response.Sense", "Response.IntrinsicSize", "Response.Clicked", "Response.ClickedBy", "Response.SecondaryClicked", "Response.LongTouched", "Response.MiddleClicked", "Response.DoubleClicked", "Response.TripleClicked", "Response.DoubleClickedBy", "Response.TripleClickedBy", "Response.ClickedElsewhere", "Response.Enabled", "Response.Hovered", "Response.ContainsPointer", "Response.HasFocus", "Response.GainedFocus", "Response.LostFocus", "Response.RequestFocus", "Response.SurrenderFocus", "Response.DragStarted", "Response.DragStartedBy", "Response.Dragged", "Response.DraggedBy", "Response.DragStopped", "Response.DragStoppedBy", "Response.DragReleased", "Response.DragReleasedBy", "Response.DragDelta", "Response.DragMotion", "Response.DndSetDragPayload", "Response.DndHoverPayload", "Response.DndReleasePayload", "Response.InteractPointerPos", "Response.HoverPos", "Response.IsPointerButtonDownOn", "Response.Changed", "Response.MarkChanged", "Response.OnHoverUi", "Response.OnDisabledHoverUi", "Response.OnHoverUiAtPointer", "Response.ShowTooltipUi", "Response.ShowTooltipText", "Response.IsTooltipOpen", "Response.OnHoverTextAtPointer", "Response.OnHoverText", "Response.Highlight", "Response.OnDisabledHoverText", "Response.OnHoverCursor", "Response.OnHoverAndDragCursor", "Response.Interact", "Response.ScrollToMe", "Response.ScrollToMeAnimation", "Response.WidgetInfo", "Response.OutputEvent", "Response.LabelledBy", "Response.ContextMenu", "Response.ContextMenuOpened", "Response.PaintDebugInfo", "Response.Union", "Response.WithNewRect", "RichText.New", "RichText.IsEmpty", "RichText.Text", "RichText.Size", "RichText.ExtraLetterSpacing", "RichText.LineHeight", "RichText.Family", "RichText.Font", "RichText.TextStyle", "RichText.FallbackTextStyle", "RichText.Heading", "RichText.Monospace", "RichText.Code", "RichText.Strong", "RichText.Weak", "RichText.Underline", "RichText.Strikethrough", "RichText.Italics", "RichText.Small", "RichText.SmallRaised", "RichText.Raised", "RichText.BackgroundColor", "RichText.Color", "RichText.FontHeight", "RichText.AppendTo", "Scene.New", "Scene.ZoomRange", "Scene.MaxInnerSize", "Scene.Show", "Scene.RegisterPanAndZoom", "ScrollArea.Horizontal", "ScrollArea.Vertical", "ScrollArea.Both", "ScrollArea.Neither", "ScrollArea.New", "ScrollArea.MaxWidth", "ScrollArea.MaxHeight", "ScrollArea.MinScrolledWidth", "ScrollArea.MinScrolledHeight", "ScrollArea.ScrollBarVisibility", "ScrollArea.ScrollBarRect", "ScrollArea.IdSource", "ScrollArea.IdSalt", "ScrollArea.ScrollOffset", "ScrollArea.VerticalScrollOffset", "ScrollArea.HorizontalScrollOffset", "ScrollArea.Hscroll", "ScrollArea.Vscroll", "ScrollArea.Scroll", "ScrollArea.Scroll2", "ScrollArea.EnableScrolling", "ScrollArea.DragToScroll", "ScrollArea.AutoShrink", "ScrollArea.Animated", "ScrollArea.StickToRight", "ScrollArea.StickToBottom", "ScrollArea.Show", "ScrollArea.ShowRows", "ScrollArea.ShowViewport", "ScrollAreaOutput.Inner", "ScrollAreaOutput.Id", "ScrollAreaOutput.State", "ScrollAreaOutput.ContentSize", "ScrollAreaOutput.InnerRect", "ScrollTarget.Range", "ScrollTarget.Align", "ScrollTarget.Animation", "SelectableLabel.New", "Separator.Spacing", "Separator.Horizontal", "Separator.Vertical", "Separator.Grow", "Separator.Shrink", "SidePanel.Left", "SidePanel.Right", "SidePanel.New", "SidePanel.Resizable", "SidePanel.ShowSeparatorLine", "SidePanel.DefaultWidth", "SidePanel.MinWidth", "SidePanel.MaxWidth", "SidePanel.WidthRange", "SidePanel.ExactWidth", "SidePanel.Frame", "SidePanel.ShowInside", "SidePanel.Show", "SidePanel.ShowAnimated", "SidePanel.ShowAnimatedInside", "SidePanel.ShowAnimatedBetween", "SidePanel.ShowAnimatedBetweenInside", "Sides.New", "Sides.Height", "Sides.Spacing", "Sides.Show", "Slider.New", "Slider.FromGetSet", "Slider.ShowValue", "Slider.Prefix", "Slider.Suffix", "Slider.Text", "Slider.TextColor", "Slider.Orientation", "Slider.Vertical", "Slider.Logarithmic", "Slider.SmallestPositive", "Slider.LargestFinite", "Slider.Clamping", "Slider.ClampToRange", "Slider.SmartAim", "Slider.StepBy", "Slider.DragValueSpeed", "Slider.MinDecimals", "Slider.MaxDecimals", "Slider.MaxDecimalsOpt", "Slider.FixedDecimals", "Slider.TrailingFill", "Slider.HandleShape", "Slider.CustomFormatter", "Slider.CustomParser", "Slider.Binary", "Slider.Octal", "Slider.Hexadecimal", "Slider.Integer", "Spinner.New", "Spinner.Size", "Spinner.Color", "Spinner.PaintAt", "State.Offset", "State.Load", "State.Store", "State.Velocity", "SubMenu.Show", "SubMenuButton.Icon", "TextCursorState.IsEmpty", "TextCursorState.CharRange", "TextCursorState.Range", "TextCursorState.SetCharRange", "TextCursorState.SetRange", "TextCursorState.PointerInteraction", "TextEdit.LoadState", "TextEdit.StoreState", "TextEdit.Singleline", "TextEdit.Multiline", "TextEdit.CodeEditor", "TextEdit.Id", "TextEdit.IdSource", "TextEdit.IdSalt", "TextEdit.HintText", "TextEdit.BackgroundColor", "TextEdit.HintTextFont", "TextEdit.Password", "TextEdit.Font", "TextEdit.TextColor", "TextEdit.TextColorOpt", "TextEdit.Layouter", "TextEdit.Interactive", "TextEdit.Frame", "TextEdit.Margin", "TextEdit.DesiredWidth", "TextEdit.DesiredRows", "TextEdit.LockFocus", "TextEdit.CursorAtEnd", "TextEdit.ClipText", "TextEdit.CharLimit", "TextEdit.HorizontalAlign", "TextEdit.VerticalAlign", "TextEdit.MinSize", "TextEdit.ReturnKey", "TextEdit.Show", "TextEditOutput.Response", "TextEditOutput.Galley", "TextEditOutput.GalleyPos", "TextEditOutput.TextClipRect", "TextEditOutput.State", "TextEditOutput.CursorRange", "TextEditOutput.TextDrawPos", "TextEditState.Cursor", "TextEditState.Load", "TextEditState.Store", "TextEditState.CcursorRange", "TextEditState.SetCcursorRange", "TextEditState.SetCursorRange", "TextEditState.Undoer", "TextEditState.SetUndoer", "TextEditState.ClearUndoer", "TextEditState.CursorRange", "TooltipPassState.WidgetTooltips", "TopBottomPanel.Top", "TopBottomPanel.Bottom", "TopBottomPanel.New", "TopBottomPanel.Resizable", "TopBottomPanel.ShowSeparatorLine", "TopBottomPanel.DefaultHeight", "TopBottomPanel.MinHeight", "TopBottomPanel.MaxHeight", "TopBottomPanel.HeightRange", "TopBottomPanel.ExactHeight", "TopBottomPanel.Frame", "TopBottomPanel.ShowInside", "TopBottomPanel.Show", "TopBottomPanel.ShowAnimated", "TopBottomPanel.ShowAnimatedInside", "TopBottomPanel.ShowAnimatedBetween", "TopBottomPanel.ShowAnimatedBetweenInside", "Ui.New", "Ui.ChildUi", "Ui.ChildUiWithIdSource", "Ui.NewChild", "Ui.SetSizingPass", "Ui.IsSizingPass", "Ui.Id", "Ui.UniqueId", "Ui.Style", "Ui.StyleMut", "Ui.SetStyle", "Ui.ResetStyle", "Ui.Spacing", "Ui.SpacingMut", "Ui.Visuals", "Ui.VisualsMut", "Ui.Stack", "Ui.Ctx", "Ui.Painter", "Ui.PixelsPerPoint", "Ui.IsEnabled", "Ui.Disable", "Ui.SetEnabled", "Ui.IsVisible", "Ui.SetInvisible", "Ui.SetVisible", "Ui.SetOpacity", "Ui.MultiplyOpacity", "Ui.Opacity", "Ui.Layout", "Ui.WrapMode", "Ui.WrapText", "Ui.TextValign", "Ui.PainterAt", "Ui.LayerId", "Ui.TextStyleHeight", "Ui.ClipRect", "Ui.ShrinkClipRect", "Ui.SetClipRect", "Ui.IsRectVisible", "Ui.Input", "Ui.InputMut", "Ui.Memory", "Ui.MemoryMut", "Ui.Data", "Ui.DataMut", "Ui.Output", "Ui.OutputMut", "Ui.Fonts", "Ui.MinRect", "Ui.MinSize", "Ui.MaxRect", "Ui.SetMaxSize", "Ui.SetMaxWidth", "Ui.SetMaxHeight", "Ui.SetMinSize", "Ui.SetMinWidth", "Ui.SetMinHeight", "Ui.ShrinkWidthToCurrent", "Ui.ShrinkHeightToCurrent", "Ui.ExpandToIncludeRect", "Ui.SetWidthRange", "Ui.SetHeightRange", "Ui.SetWidth", "Ui.SetHeight", "Ui.ExpandToIncludeX", "Ui.ExpandToIncludeY", "Ui.AvailableSize", "Ui.AvailableWidth", "Ui.AvailableHeight", "Ui.AvailableSizeBeforeWrap", "Ui.AvailableRectBeforeWrap", "Ui.MakePersistentId", "Ui.NextAutoId", "Ui.AutoIdWith", "Ui.SkipAheadAutoIds", "Ui.Interact", "Ui.InteractWithHovered", "Ui.Response", "Ui.InteractBg", "Ui.RectContainsPointer", "Ui.UiContainsPointer", "Ui.AllocateResponse", "Ui.AllocateExactSize", "Ui.AllocateAtLeast", "Ui.AllocateSpace", "Ui.AllocateRect", "Ui.AdvanceCursorAfterRect", "Ui.Cursor", "Ui.NextWidgetPosition", "Ui.AllocateUi", "Ui.AllocateUiWithLayout", "Ui.AllocateUiAtRect", "Ui.AllocateNewUi", "Ui.AllocatePainter", "Ui.ScrollToRect", "Ui.ScrollToRectAnimation", "Ui.ScrollToCursor", "Ui.ScrollToCursorAnimation", "Ui.ScrollWithDelta", "Ui.ScrollWithDeltaAnimation", "Ui.Add", "Ui.AddSized", "Ui.Put", "Ui.AddEnabled", "Ui.AddEnabledUi", "Ui.AddVisible", "Ui.AddVisibleUi", "Ui.AddSpace", "Ui.Label", "Ui.ColoredLabel", "Ui.Heading", "Ui.Monospace", "Ui.Code", "Ui.Small", "Ui.Strong", "Ui.Weak", "Ui.Link", "Ui.Hyperlink", "Ui.HyperlinkTo", "Ui.TextEditSingleline", "Ui.TextEditMultiline", "Ui.CodeEditor", "Ui.Button", "Ui.SmallButton", "Ui.Checkbox", "Ui.ToggleValue", "Ui.Radio", "Ui.RadioValue", "Ui.SelectableLabel", "Ui.SelectableValue", "Ui.Separator", "Ui.Spinner", "Ui.DragAngle", "Ui.DragAngleTau", "Ui.Image", "Ui.ColorEditButtonSrgba", "Ui.ColorEditButtonHsva", "Ui.ColorEditButtonSrgb", "Ui.ColorEditButtonRgb", "Ui.ColorEditButtonSrgbaPremultiplied", "Ui.ColorEditButtonSrgbaUnmultiplied", "Ui.ColorEditButtonRgbaPremultiplied", "Ui.ColorEditButtonRgbaUnmultiplied", "Ui.Group", "Ui.PushId", "Ui.PushStackInfo", "Ui.Scope", "Ui.ScopeBuilder", "Ui.ScopeDyn", "Ui.WithLayerId", "Ui.Collapsing", "Ui.Indent", "Ui.Horizontal", "Ui.HorizontalCentered", "Ui.HorizontalTop", "Ui.HorizontalWrapped", "Ui.Vertical", "Ui.VerticalCentered", "Ui.VerticalCenteredJustified", "Ui.WithLayout", "Ui.CenteredAndJustified", "Ui.EndRow", "Ui.SetRowHeight", "Ui.Columns", "Ui.ColumnsConst", "Ui.DndDragSource", "Ui.DndDropZone", "Ui.WithVisualTransform", "Ui.CloseMenu", "Ui.MenuButton", "Ui.MenuImageButton", "Ui.MenuImageTextButton", "Ui.DebugPaintCursor", "UiStack.Id", "UiStack.Info", "UiStack.LayoutDirection", "UiStack.MinRect", "UiStack.MaxRect", "UiStack.Parent", "UiStack.Kind", "UiStack.Frame", "UiStack.Tags", "UiStack.IsPanelUi", "UiStack.IsAreaUi", "UiStack.IsRootUi", "UiStack.HasVisibleFrame", "UiStack.Iter", "UiStack.ContainedIn", "Undoer.WithSettings", "Undoer.HasUndo", "Undoer.HasRedo", "Undoer.IsInFlux", "Undoer.Undo", "Undoer.Redo", "Undoer.AddUndo", "Undoer.FeedState", "ViewportState.Class", "ViewportState.Builder", "ViewportState.ViewportUiCb", "ViewportState.Input", "ViewportState.ThisPass", "ViewportState.PrevPass", "ViewportState.Used", "ViewportState.Hits", "ViewportState.InteractWidgets", "ViewportState.Graphics", "ViewportState.Output", "ViewportState.Commands", "ViewportState.NumMultipassInRow", "WidgetHits.Close", "WidgetHits.ContainsPointer", "WidgetHits.Click", "WidgetHits.Drag", "WidgetRects.LayerIds", "WidgetRects.Layers", "WidgetRects.Get", "WidgetRects.Order", "WidgetRects.Contains", "WidgetRects.GetLayer", "WidgetRects.Clear", "WidgetRects.Insert", "WidgetRects.SetInfo", "WidgetRects.Info", "Window.New", "Window.Id", "Window.Open", "Window.Enabled", "Window.Interactable", "Window.Movable", "Window.Order", "Window.FadeIn", "Window.FadeOut", "Window.Mutate", "Window.Resize", "Window.Frame", "Window.MinWidth", "Window.MinHeight", "Window.MinSize", "Window.MaxWidth", "Window.MaxHeight", "Window.MaxSize", "Window.CurrentPos", "Window.DefaultPos", "Window.FixedPos", "Window.Constrain", "Window.ConstrainTo", "Window.Pivot", "Window.Anchor", "Window.DefaultOpen", "Window.DefaultSize", "Window.DefaultWidth", "Window.DefaultHeight", "Window.FixedSize", "Window.DefaultRect", "Window.FixedRect", "Window.Resizable", "Window.Collapsible", "Window.TitleBar", "Window.AutoSized", "Window.Scroll", "Window.Scroll2", "Window.Hscroll", "Window.Vscroll", "Window.DragToScroll", "Window.ScrollBarVisibility", "Window.Show", "AreaState.PivotPos", "AreaState.Pivot", "AreaState.Size", "AreaState.Interactable", "AreaState.LastBecameVisibleAt", "AreaState.Load", "AreaState.LeftTopPos", "AreaState.SetLeftTopPos", "AreaState.Rect", "CCursorRange.Primary", "CCursorRange.Secondary", "CCursorRange.One", "CCursorRange.Two", "CCursorRange.IsSorted", "CCursorRange.Sorted", "CursorRange.Primary", "CursorRange.Secondary", "CursorRange.One", "CursorRange.Two", "CursorRange.SelectAll", "CursorRange.AsCcursorRange", "CursorRange.AsSortedCharRange", "CursorRange.IsEmpty", "CursorRange.Contains", "CursorRange.Single", "CursorRange.IsSorted", "CursorRange.Sorted", "CursorRange.SortedCursors", "CursorRange.SliceStr", "CursorRange.OnKeyPress", "CursorRange.OnEvent", "DebugOptions.DebugOnHover", "DebugOptions.DebugOnHoverWithAllModifiers", "DebugOptions.HoverShowsNext", "DebugOptions.ShowExpandWidth", "DebugOptions.ShowExpandHeight", "DebugOptions.ShowResize", "DebugOptions.ShowInteractiveWidgets", "DebugOptions.ShowWidgetHits", "DebugOptions.ShowUnaligned", "DebugOptions.Ui", "DroppedFile.Path", "DroppedFile.Name", "DroppedFile.Mime", "DroppedFile.LastModified", "DroppedFile.Bytes", "EventFilter.Tab", "EventFilter.HorizontalArrows", "EventFilter.VerticalArrows", "EventFilter.Escape", "EventFilter.Matches", "Frame.InnerMargin", "Frame.Fill", "Frame.Stroke", "Frame.CornerRadius", "Frame.OuterMargin", "Frame.Shadow", "Frame.New", "Frame.None", "Frame.Group", "Frame.SideTopPanel", "Frame.CentralPanel", "Frame.Window", "Frame.Menu", "Frame.Popup", "Frame.Canvas", "Frame.DarkCanvas", "Frame.InnerMargin", "Frame.Fill", "Frame.Stroke", "Frame.CornerRadius", "Frame.Rounding", "Frame.OuterMargin", "Frame.Shadow", "Frame.MultiplyWithOpacity", "Frame.TotalMargin", "Frame.FillRect", "Frame.WidgetRect", "Frame.OuterRect", "Frame.Begin", "Frame.Show", "Frame.ShowDyn", "Frame.Paint", "HoveredFile.Path", "HoveredFile.Mime", "IMEOutput.Rect", "IMEOutput.CursorRect", "ImageOptions.Uv", "ImageOptions.BgFill", "ImageOptions.Tint", "ImageOptions.Rotation", "ImageOptions.CornerRadius", "ImageSize.MaintainAspectRatio", "ImageSize.MaxSize", "ImageSize.Fit", "ImageSize.Hint", "ImageSize.CalcSize", "Interaction.InteractRadius", "Interaction.ResizeGrabRadiusSide", "Interaction.ResizeGrabRadiusCorner", "Interaction.ShowTooltipsOnlyWhenStill", "Interaction.TooltipDelay", "Interaction.TooltipGraceTime", "Interaction.SelectableLabels", "Interaction.MultiWidgetTextSelect", "Interaction.Ui", "KeyboardShortcut.Modifiers", "KeyboardShortcut.LogicalKey", "KeyboardShortcut.New", "KeyboardShortcut.Format", "LayerId.Order", "LayerId.Id", "LayerId.New", "LayerId.Debug", "LayerId.Background", "LayerId.AllowInteraction", "LayerId.ShortDebugFormat", "Layout.MainDir", "Layout.MainWrap", "Layout.MainAlign", "Layout.MainJustify", "Layout.CrossAlign", "Layout.CrossJustify", "Layout.LeftToRight", "Layout.RightToLeft", "Layout.TopDown", "Layout.TopDownJustified", "Layout.BottomUp", "Layout.FromMainDirAndCrossAlign", "Layout.CenteredAndJustified", "Layout.WithMainWrap", "Layout.WithMainAlign", "Layout.WithCrossAlign", "Layout.WithMainJustify", "Layout.WithCrossJustify", "Layout.MainDir", "Layout.MainWrap", "Layout.CrossAlign", "Layout.CrossJustify", "Layout.IsHorizontal", "Layout.IsVertical", "Layout.PreferRightToLeft", "Layout.HorizontalPlacement", "Layout.HorizontalAlign", "Layout.VerticalAlign", "Layout.HorizontalJustify", "Layout.VerticalJustify", "Layout.AlignSizeWithinRect", "MenuRoot.MenuState", "MenuRoot.Id", "MenuRoot.New", "MenuRoot.Show", "MenuRoot.ContextInteraction", "MenuRoot.HandleMenuResponse", "MenuRoot.ContextClickInteraction", "MenuRoot.StationaryClickInteraction", "ModifierNames.IsShort", "ModifierNames.Alt", "ModifierNames.Ctrl", "ModifierNames.Shift", "ModifierNames.MacCmd", "ModifierNames.MacAlt", "ModifierNames.Concat", "ModifierNames.Format", "Modifiers.Alt", "Modifiers.Ctrl", "Modifiers.Shift", "Modifiers.MacCmd", "Modifiers.Command", "Modifiers.Plus", "Modifiers.IsNone", "Modifiers.Any", "Modifiers.All", "Modifiers.ShiftOnly", "Modifiers.CommandOnly", "Modifiers.MatchesLogically", "Modifiers.MatchesExact", "Modifiers.Matches", "Modifiers.CmdCtrlMatches", "Modifiers.Contains", "MultiTouchInfo.StartTime", "MultiTouchInfo.StartPos", "MultiTouchInfo.CenterPos", "MultiTouchInfo.NumTouches", "MultiTouchInfo.ZoomDelta", "MultiTouchInfo.ZoomDelta2D", "MultiTouchInfo.RotationDelta", "MultiTouchInfo.TranslationDelta", "MultiTouchInfo.Force", "OpenUrl.Url", "OpenUrl.NewTab", "OpenUrl.SameTab", "OpenUrl.NewTab", "PCursorRange.Primary", "PCursorRange.Secondary", "PlatformOutput.Commands", "PlatformOutput.CursorIcon", "PlatformOutput.OpenUrl", "PlatformOutput.CopiedText", "PlatformOutput.Events", "PlatformOutput.MutableTextUnderCursor", "PlatformOutput.Ime", "PlatformOutput.NumCompletedPasses", "PlatformOutput.RequestDiscardReasons", "PlatformOutput.EventsDescription", "PlatformOutput.Append", "PlatformOutput.Take", "PlatformOutput.RequestedDiscard", "RawInput.ViewportId", "RawInput.Viewports", "RawInput.ScreenRect", "RawInput.MaxTextureSide", "RawInput.Time", "RawInput.PredictedDt", "RawInput.Modifiers", "RawInput.Events", "RawInput.HoveredFiles", "RawInput.DroppedFiles", "RawInput.Focused", "RawInput.SystemTheme", "RawInput.Viewport", "RawInput.Take", "RawInput.Append", "RawInput.Ui", "RepaintCause.File", "RepaintCause.Line", "RepaintCause.Reason", "RepaintCause.New", "RepaintCause.NewReason", "RequestRepaintInfo.ViewportId", "RequestRepaintInfo.Delay", "RequestRepaintInfo.CurrentCumulativePassNr", "RowVertexIndices.Row", "RowVertexIndices.VertexIndices", "ScrollAnimation.PointsPerSecond", "ScrollAnimation.Duration", "ScrollAnimation.New", "ScrollAnimation.None", "ScrollAnimation.Duration", "ScrollAnimation.Ui", "ScrollStyle.Floating", "ScrollStyle.BarWidth", "ScrollStyle.HandleMinLength", "ScrollStyle.BarInnerMargin", "ScrollStyle.BarOuterMargin", "ScrollStyle.FloatingWidth", "ScrollStyle.FloatingAllocatedWidth", "ScrollStyle.ForegroundColor", "ScrollStyle.DormantBackgroundOpacity", "ScrollStyle.ActiveBackgroundOpacity", "ScrollStyle.InteractBackgroundOpacity", "ScrollStyle.DormantHandleOpacity", "ScrollStyle.ActiveHandleOpacity", "ScrollStyle.InteractHandleOpacity", "ScrollStyle.Solid", "ScrollStyle.Thin", "ScrollStyle.Floating", "ScrollStyle.AllocatedWidth", "ScrollStyle.Ui", "ScrollStyle.DetailsUi", "Selection.BgFill", "Selection.Stroke", "Selection.Ui", "Settings.MaxUndos", "Settings.StableTime", "Settings.AutoSaveInterval", "SizedTexture.Id", "SizedTexture.Size", "SizedTexture.New", "SizedTexture.FromHandle", "Spacing.ItemSpacing", "Spacing.WindowMargin", "Spacing.ButtonPadding", "Spacing.MenuMargin", "Spacing.Indent", "Spacing.InteractSize", "Spacing.SliderWidth", "Spacing.SliderRailHeight", "Spacing.ComboWidth", "Spacing.TextEditWidth", "Spacing.IconWidth", "Spacing.IconWidthInner", "Spacing.IconSpacing", "Spacing.DefaultAreaSize", "Spacing.TooltipWidth", "Spacing.MenuWidth", "Spacing.MenuSpacing", "Spacing.IndentEndsWithHorizontalLine", "Spacing.ComboHeight", "Spacing.Scroll", "Spacing.IconRectangles", "Spacing.Ui", "Style.OverrideTextStyle", "Style.OverrideFontId", "Style.OverrideTextValign", "Style.TextStyles", "Style.DragValueTextStyle", "Style.NumberFormatter", "Style.Wrap", "Style.WrapMode", "Style.Spacing", "Style.Interaction", "Style.Visuals", "Style.AnimationTime", "Style.Debug", "Style.ExplanationTooltips", "Style.UrlInTooltip", "Style.AlwaysScrollTheOnlyDirection", "Style.ScrollAnimation", "Style.Interact", "Style.InteractSelectable", "Style.Noninteractive", "Style.TextStyles", "Style.Ui", "TextCursorStyle.Stroke", "TextCursorStyle.Preview", "TextCursorStyle.Blink", "TextCursorStyle.OnDuration", "TextCursorStyle.OffDuration", "UiBuilder.IdSalt", "UiBuilder.UiStackInfo", "UiBuilder.LayerId", "UiBuilder.MaxRect", "UiBuilder.Layout", "UiBuilder.Disabled", "UiBuilder.Invisible", "UiBuilder.SizingPass", "UiBuilder.Style", "UiBuilder.Sense", "UiBuilder.New", "UiBuilder.IdSalt", "UiBuilder.UiStackInfo", "UiBuilder.LayerId", "UiBuilder.MaxRect", "UiBuilder.Layout", "UiBuilder.Disabled", "UiBuilder.Invisible", "UiBuilder.SizingPass", "UiBuilder.Style", "UiBuilder.Sense", "UiStackInfo.Kind", "UiStackInfo.Frame", "UiStackInfo.Tags", "UiStackInfo.New", "UiStackInfo.WithFrame", "UiStackInfo.WithTag", "UiStackInfo.WithTagValue", "UserData.Data", "UserData.New", "ViewportIdPair.This", "ViewportIdPair.Parent", "ViewportIdPair.FromSelfAndParent", "ViewportInfo.Parent", "ViewportInfo.Title", "ViewportInfo.Events", "ViewportInfo.NativePixelsPerPoint", "ViewportInfo.MonitorSize", "ViewportInfo.InnerRect", "ViewportInfo.OuterRect", "ViewportInfo.Minimized", "ViewportInfo.Maximized", "ViewportInfo.Fullscreen", "ViewportInfo.Focused", "ViewportInfo.CloseRequested", "ViewportInfo.Take", "ViewportInfo.Ui", "Visuals.DarkMode", "Visuals.OverrideTextColor", "Visuals.Widgets", "Visuals.Selection", "Visuals.HyperlinkColor", "Visuals.FaintBgColor", "Visuals.ExtremeBgColor", "Visuals.CodeBgColor", "Visuals.WarnFgColor", "Visuals.ErrorFgColor", "Visuals.WindowCornerRadius", "Visuals.WindowShadow", "Visuals.WindowFill", "Visuals.WindowStroke", "Visuals.WindowHighlightTopmost", "Visuals.MenuCornerRadius", "Visuals.PanelFill", "Visuals.PopupShadow", "Visuals.ResizeCornerSize", "Visuals.TextCursor", "Visuals.ClipRectMargin", "Visuals.ButtonFrame", "Visuals.CollapsingHeaderFrame", "Visuals.IndentHasLeftVline", "Visuals.Striped", "Visuals.SliderTrailingFill", "Visuals.HandleShape", "Visuals.InteractCursor", "Visuals.ImageLoadingSpinners", "Visuals.NumericColorSpace", "Visuals.Noninteractive", "Visuals.TextColor", "Visuals.WeakTextColor", "Visuals.StrongTextColor", "Visuals.WindowFill", "Visuals.WindowStroke", "Visuals.FadeOutToColor", "Visuals.GrayOut", "Visuals.Dark", "Visuals.Light", "Visuals.Ui", "WidgetInfo.Typ", "WidgetInfo.Enabled", "WidgetInfo.Label", "WidgetInfo.CurrentTextValue", "WidgetInfo.PrevTextValue", "WidgetInfo.Selected", "WidgetInfo.Value", "WidgetInfo.TextSelection", "WidgetInfo.New", "WidgetInfo.Labeled", "WidgetInfo.Selected", "WidgetInfo.DragValue", "WidgetInfo.Slider", "WidgetInfo.TextEdit", "WidgetInfo.TextSelectionChanged", "WidgetInfo.Description", "WidgetRect.Id", "WidgetRect.LayerId", "WidgetRect.Rect", "WidgetRect.InteractRect", "WidgetRect.Sense", "WidgetRect.Enabled", "WidgetRect.Transform", "WidgetVisuals.BgFill", "WidgetVisuals.WeakBgFill", "WidgetVisuals.BgStroke", "WidgetVisuals.CornerRadius", "WidgetVisuals.FgStroke", "WidgetVisuals.Expansion", "WidgetVisuals.TextColor", "WidgetVisuals.Rounding", "WidgetVisuals.Ui", "Widgets.Noninteractive", "Widgets.Inactive", "Widgets.Hovered", "Widgets.Active", "Widgets.Open", "Widgets.Style", "Widgets.Dark", "Widgets.Light", "Widgets.Ui"];

    /// <summary>
    /// Writes a report to the console describing which items still need to be bound.
    /// </summary>
    public static void PrintStatistics() {
        var boundItems = 0;
        foreach (var item in Items) {
            if (ItemExists(item)) {
                boundItems++;
            }
            else {
                Console.WriteLine(item);
            }
        }
        var boundPercent = MathF.Floor(100.0f * (float)boundItems / (float)Items.Length);

        Console.WriteLine("====================");
        Console.WriteLine($"{boundItems}/{Items.Length} ({boundPercent}%) members bound");
    }

    /// <summary>
    /// Determines whether the given item is defined.
    /// The item name may either be a type name of format <c>TypeName> or
    /// a member name of format <c>TypeName.FieldOrMethodName</c>.
    /// </summary>
    /// <param name="name">The name to query.</param>
    /// <return><c>true</c> if and only if the member was defined.</return>
    private static bool ItemExists(string name) {
        var parts = name.Split(".");

        if (parts.Length == 1) {
            return Type.GetType(parts[0]) != null;
        }
        else if (parts.Length == 2) {
            var ty = Type.GetType(parts[0]);
            return ty.GetMember(parts[1]) != null;
        }
        else {
            throw new ArgumentException($"Member name {name} was not properly formatted");
        }
    }
}

/// <summary>
/// Indicate whether a popup will be shown above or below the box.
/// </summary>
public enum AboveOrBelow {
    Above,
    Below,
}

/// <summary>
/// What options to show for alpha
/// </summary>
public enum Alpha {
    /// <summary>
    /// Set alpha to 1.0, and show no option for it.
    /// </summary>
    Opaque,
    /// <summary>
    /// Only show normal blend options for alpha.
    /// </summary>
    OnlyBlend,
    /// <summary>
    /// Show both blend and additive options.
    /// </summary>
    BlendOrAdditive,
}

public enum CursorGrab {
    None,
    Confined,
    Locked,
}

/// <summary>
/// A mouse cursor icon.
/// 
/// egui emits a <c>CursorIcon</c> in <c>PlatformOutput</c> each frame as a request to the integration.
/// 
/// Loosely based on <https://developer.mozilla.org/en-US/docs/Web/CSS/cursor>.
/// </summary>
public enum CursorIcon {
    /// <summary>
    /// Normal cursor icon, whatever that is.
    /// </summary>
    Default,
    /// <summary>
    /// Show no cursor
    /// </summary>
    None,
    /// <summary>
    /// A context menu is available
    /// </summary>
    ContextMenu,
    /// <summary>
    /// Question mark
    /// </summary>
    Help,
    /// <summary>
    /// Pointing hand, used for e.g. web links
    /// </summary>
    PointingHand,
    /// <summary>
    /// Shows that processing is being done, but that the program is still interactive.
    /// </summary>
    Progress,
    /// <summary>
    /// Not yet ready, try later.
    /// </summary>
    Wait,
    /// <summary>
    /// Hover a cell in a table
    /// </summary>
    Cell,
    /// <summary>
    /// For precision work
    /// </summary>
    Crosshair,
    /// <summary>
    /// Text caret, e.g. "Click here to edit text"
    /// </summary>
    Text,
    /// <summary>
    /// Vertical text caret, e.g. "Click here to edit vertical text"
    /// </summary>
    VerticalText,
    /// <summary>
    /// Indicated an alias, e.g. a shortcut
    /// </summary>
    Alias,
    /// <summary>
    /// Indicate that a copy will be made
    /// </summary>
    Copy,
    /// <summary>
    /// Omnidirectional move icon (e.g. arrows in all cardinal directions)
    /// </summary>
    Move,
    /// <summary>
    /// Can't drop here
    /// </summary>
    NoDrop,
    /// <summary>
    /// Forbidden
    /// </summary>
    NotAllowed,
    /// <summary>
    /// The thing you are hovering can be grabbed
    /// </summary>
    Grab,
    /// <summary>
    /// You are grabbing the thing you are hovering
    /// </summary>
    Grabbing,
    /// <summary>
    /// Something can be scrolled in any direction (panned).
    /// </summary>
    AllScroll,
    /// <summary>
    /// Horizontal resize <c></c> to make something wider or more narrow (left to/from right)
    /// </summary>
    ResizeHorizontal,
    /// <summary>
    /// Diagonal resize <c>/</c> (right-up to/from left-down)
    /// </summary>
    ResizeNeSw,
    /// <summary>
    /// Diagonal resize <c>\</c> (left-up to/from right-down)
    /// </summary>
    ResizeNwSe,
    /// <summary>
    /// Vertical resize <c>|</c> (up-down or down-up)
    /// </summary>
    ResizeVertical,
    /// <summary>
    /// Resize something rightwards (e.g. when dragging the right-most edge of something)
    /// </summary>
    ResizeEast,
    /// <summary>
    /// Resize something down and right (e.g. when dragging the bottom-right corner of something)
    /// </summary>
    ResizeSouthEast,
    /// <summary>
    /// Resize something downwards (e.g. when dragging the bottom edge of something)
    /// </summary>
    ResizeSouth,
    /// <summary>
    /// Resize something down and left (e.g. when dragging the bottom-left corner of something)
    /// </summary>
    ResizeSouthWest,
    /// <summary>
    /// Resize something leftwards (e.g. when dragging the left edge of something)
    /// </summary>
    ResizeWest,
    /// <summary>
    /// Resize something up and left (e.g. when dragging the top-left corner of something)
    /// </summary>
    ResizeNorthWest,
    /// <summary>
    /// Resize something up (e.g. when dragging the top edge of something)
    /// </summary>
    ResizeNorth,
    /// <summary>
    /// Resize something up and right (e.g. when dragging the top-right corner of something)
    /// </summary>
    ResizeNorthEast,
    /// <summary>
    /// Resize a column
    /// </summary>
    ResizeColumn,
    /// <summary>
    /// Resize a row
    /// </summary>
    ResizeRow,
    /// <summary>
    /// Enhance!
    /// </summary>
    ZoomIn,
    /// <summary>
    /// Let's get a better overview
    /// </summary>
    ZoomOut,
}

/// <summary>
/// Layout direction, one of <c>LeftToRight</c>, <c>RightToLeft</c>, <c>TopDown</c>, <c>BottomUp</c>.
/// </summary>
public enum Direction {
    LeftToRight,
    RightToLeft,
    TopDown,
    BottomUp,
}

public enum IMEPurpose {
    Normal,
    Password,
    Terminal,
}

/// <summary>
/// The unit associated with the numeric value of a mouse wheel event
/// </summary>
public enum MouseWheelUnit {
    /// <summary>
    /// Number of ui points (logical pixels)
    /// </summary>
    Point,
    /// <summary>
    /// Number of lines
    /// </summary>
    Line,
    /// <summary>
    /// Number of pages
    /// </summary>
    Page,
}

/// <summary>
/// How to display numeric color values.
/// </summary>
public enum NumericColorSpace {
    /// <summary>
    /// RGB is 0-255 in gamma space.
    /// 
    /// Alpha is 0-255 in linear space.
    /// </summary>
    GammaByte,
    /// <summary>
    /// 0-1 in linear space.
    /// </summary>
    Linear,
}

/// <summary>
/// Different layer categories
/// </summary>
public enum Order {
    /// <summary>
    /// Painted behind all floating windows
    /// </summary>
    Background,
    /// <summary>
    /// Normal moveable windows that you reorder by click
    /// </summary>
    Middle,
    /// <summary>
    /// Popups, menus etc that should always be painted on top of windows
    /// Foreground objects can also have tooltips
    /// </summary>
    Foreground,
    /// <summary>
    /// Things floating on top of everything else, like tooltips.
    /// You cannot interact with these.
    /// </summary>
    Tooltip,
    /// <summary>
    /// Debug layer, always painted last / on top
    /// </summary>
    Debug,
}

/// <summary>
/// Mouse button (or similar for touch input)
/// </summary>
public enum PointerButton {
    /// <summary>
    /// The primary mouse button is usually the left one.
    /// </summary>
    Primary = 0,
    /// <summary>
    /// The secondary mouse button is usually the right one,
    /// and most often used for context menus or other optional things.
    /// </summary>
    Secondary = 1,
    /// <summary>
    /// The tertiary mouse button is usually the middle mouse button (e.g. clicking the scroll wheel).
    /// </summary>
    Middle = 2,
    /// <summary>
    /// The first extra mouse button on some mice. In web typically corresponds to the Browser back button.
    /// </summary>
    Extra1 = 3,
    /// <summary>
    /// The second extra mouse button on some mice. In web typically corresponds to the Browser forward button.
    /// </summary>
    Extra2 = 4,
}

/// <summary>
/// Determines popup's close behavior
/// </summary>
public enum PopupCloseBehavior {
    /// <summary>
    /// Popup will be closed on click anywhere, inside or outside the popup.
    /// 
    /// It is used in <c>ComboBox</c>.
    /// </summary>
    CloseOnClick,
    /// <summary>
    /// Popup will be closed if the click happened somewhere else
    /// but in the popup's body
    /// </summary>
    CloseOnClickOutside,
    /// <summary>
    /// Clicks will be ignored. Popup might be closed manually by calling <c>ClosePopup</c>
    /// or by pressing the escape button
    /// </summary>
    IgnoreClicks,
}

public enum ResizeDirection {
    North,
    South,
    East,
    West,
    NorthEast,
    SouthEast,
    NorthWest,
    SouthWest,
}

/// <summary>
/// Indicate whether the horizontal and vertical scroll bars must be always visible, hidden or visible when needed.
/// </summary>
public enum ScrollBarVisibility {
    /// <summary>
    /// Hide scroll bar even if they are needed.
    /// 
    /// You can still scroll, with the scroll-wheel
    /// and by dragging the contents, but there is no
    /// visual indication of how far you have scrolled.
    /// </summary>
    AlwaysHidden,
    /// <summary>
    /// Show scroll bars only when the content size exceeds the container,
    /// i.e. when there is any need to scroll.
    /// 
    /// This is the default.
    /// </summary>
    VisibleWhenNeeded,
    /// <summary>
    /// Always show the scroll bar, even if the contents fit in the container
    /// and there is no need to scroll.
    /// </summary>
    AlwaysVisible,
}

/// <summary>
/// <c>Left</c> or <c>Right</c>
/// </summary>
public enum Side {
    Left,
    Right,
}

/// <summary>
/// Specifies how values in a <c>Slider</c> are clamped.
/// </summary>
public enum SliderClamping {
    /// <summary>
    /// Values are not clamped.
    /// 
    /// This means editing the value with the keyboard,
    /// or dragging the number next to the slider will always work.
    /// 
    /// The actual slider part is always clamped though.
    /// </summary>
    Never,
    /// <summary>
    /// Users cannot enter new values that are outside the range.
    /// 
    /// Existing values remain intact though.
    /// </summary>
    Edits,
    /// <summary>
    /// Always clamp values, even existing ones.
    /// </summary>
    Always,
}

/// <summary>
/// Specifies the orientation of a <c>Slider</c>.
/// </summary>
public enum SliderOrientation {
    Horizontal,
    Vertical,
}

public enum SystemTheme {
    SystemDefault,
    Light,
    Dark,
}

/// <summary>
/// Dark or Light theme.
/// </summary>
public enum Theme {
    /// <summary>
    /// Dark mode: light text on a dark background.
    /// </summary>
    Dark,
    /// <summary>
    /// Light mode: dark text on a light background.
    /// </summary>
    Light,
}

/// <summary>
/// The user's theme preference.
/// </summary>
public enum ThemePreference {
    /// <summary>
    /// Dark mode: light text on a dark background.
    /// </summary>
    Dark,
    /// <summary>
    /// Light mode: dark text on a light background.
    /// </summary>
    Light,
    /// <summary>
    /// Follow the system's theme preference.
    /// </summary>
    System,
}

/// <summary>
/// <c>Top</c> or <c>Bottom</c>
/// </summary>
public enum TopBottomSide {
    Top,
    Bottom,
}

/// <summary>
/// In what phase a touch event is in.
/// </summary>
public enum TouchPhase {
    /// <summary>
    /// User just placed a touch point on the touch surface
    /// </summary>
    Start,
    /// <summary>
    /// User moves a touch point along the surface. This event is also sent when
    /// any attributes (position, force, …) of the touch point change.
    /// </summary>
    Move,
    /// <summary>
    /// User lifted the finger or pen from the surface, or slid off the edge of
    /// the surface
    /// </summary>
    End,
    /// <summary>
    /// Touch operation has been disrupted by something (various reasons are possible,
    /// maybe a pop-up alert or any other kind of interruption which may not have
    /// been intended by the user)
    /// </summary>
    Cancel,
}

/// <summary>
/// What kind is this <c>Ui</c>?
/// </summary>
public enum UiKind {
    /// <summary>
    /// A <c>Window</c>.
    /// </summary>
    Window,
    /// <summary>
    /// A <c>CentralPanel</c>.
    /// </summary>
    CentralPanel,
    /// <summary>
    /// A left <c>SidePanel</c>.
    /// </summary>
    LeftPanel,
    /// <summary>
    /// A right <c>SidePanel</c>.
    /// </summary>
    RightPanel,
    /// <summary>
    /// A top <c>TopBottomPanel</c>.
    /// </summary>
    TopPanel,
    /// <summary>
    /// A bottom <c>TopBottomPanel</c>.
    /// </summary>
    BottomPanel,
    /// <summary>
    /// A modal <c>Modal</c>.
    /// </summary>
    Modal,
    /// <summary>
    /// A <c>Frame</c>.
    /// </summary>
    Frame,
    /// <summary>
    /// A <c>ScrollArea</c>.
    /// </summary>
    ScrollArea,
    /// <summary>
    /// A <c>Resize</c>.
    /// </summary>
    Resize,
    /// <summary>
    /// The content of a regular menu.
    /// </summary>
    Menu,
    /// <summary>
    /// The content of a popup menu.
    /// </summary>
    Popup,
    /// <summary>
    /// A tooltip, as shown by e.g. <c>OnHoverUi</c>.
    /// </summary>
    Tooltip,
    /// <summary>
    /// A picker, such as color picker.
    /// </summary>
    Picker,
    /// <summary>
    /// A table cell (from the <c>EguiExtras</c> crate).
    /// </summary>
    TableCell,
    /// <summary>
    /// An <c>Area</c> that is not of any other kind.
    /// </summary>
    GenericArea,
}

/// <summary>
/// Types of attention to request from a user when a native window is not in focus.
/// 
/// See winit's documentationuser_attention_type for platform-specific meaning of the attention types.
/// 
/// user_attention_type: https://docs.rs/winit/latest/winit/window/enum.UserAttentionType.html
/// </summary>
public enum UserAttentionType {
    /// <summary>
    /// Request an elevated amount of animations and flair for the window and the task bar or dock icon.
    /// </summary>
    Critical,
    /// <summary>
    /// Request a standard amount of attention-grabbing actions.
    /// </summary>
    Informational,
    /// <summary>
    /// Reset the attention request and interrupt related animations and flashes.
    /// </summary>
    Reset,
}

/// <summary>
/// The different types of viewports supported by egui.
/// </summary>
public enum ViewportClass {
    /// <summary>
    /// The root viewport; i.e. the original window.
    /// </summary>
    Root,
    /// <summary>
    /// A viewport run independently from the parent viewport.
    /// 
    /// This is the preferred type of viewport from a performance perspective.
    /// 
    /// Create these with <c>ShowViewportDeferred</c>.
    /// </summary>
    Deferred,
    /// <summary>
    /// A viewport run inside the parent viewport.
    /// 
    /// This is the easier type of viewport to use, but it is less performant
    /// at it requires both parent and child to repaint if any one of them needs repainting,
    /// which effectively produces double work for two viewports, and triple work for three viewports, etc.
    /// 
    /// Create these with <c>ShowViewportImmediate</c>.
    /// </summary>
    Immediate,
    /// <summary>
    /// The fallback, when the egui integration doesn't support viewports,
    /// or <c>EmbedViewports</c> is set to <c>True</c>.
    /// </summary>
    Embedded,
}

/// <summary>
/// An input event from the backend into egui, about a specific viewport.
/// </summary>
public enum ViewportEvent {
    /// <summary>
    /// The user clicked the close-button on the window, or similar.
    /// 
    /// If this is the root viewport, the application will exit
    /// after this frame unless you send a
    /// <c>CancelClose</c> command.
    /// 
    /// If this is not the root viewport,
    /// it is up to the user to hide this viewport the next frame.
    /// 
    /// This even will wake up both the child and parent viewport.
    /// </summary>
    Close,
}

/// <summary>
/// The different types of built-in widgets in egui
/// </summary>
public enum WidgetType {
    Label,
    /// <summary>
    /// e.g. a hyperlink
    /// </summary>
    Link,
    TextEdit,
    Button,
    Checkbox,
    RadioButton,
    /// <summary>
    /// A group of radio buttons.
    /// </summary>
    RadioGroup,
    SelectableLabel,
    ComboBox,
    Slider,
    DragValue,
    ColorButton,
    ImageButton,
    Image,
    CollapsingHeader,
    ProgressIndicator,
    Window,
    /// <summary>
    /// If you cannot fit any of the above slots.
    /// 
    /// If this is something you think should be added, file an issue.
    /// </summary>
    Other,
}

public enum WindowLevel {
    Normal,
    AlwaysOnBottom,
    AlwaysOnTop,
}

/// <summary>
/// An area on the screen that can be moved by dragging.
/// 
/// This forms the base of the <c>Window</c> container.The previous rectangle used by this area can be obtained through <c>AreaRect()</c>.
/// </summary>
public unsafe partial sealed class Area : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_area_drop(pointer);
    }
    public Area(Id id) {
        Egui.area_new(TODO_ARG(id));
    
    }
    
    public Area Id(Id id) {
        Egui.area_id(TODO_ARG(id));
    
    }
    
    public Area Kind(UiKind kind) {
        Egui.area_kind(TODO_ARG(kind));
    
    }
    
    public LayerId Layer() {
        Egui.area_layer();
    
    }
    
    public Area Enabled(bool enabled) {
        Egui.area_enabled(TODO_ARG(enabled));
    
    }
    
    public Area Movable(bool movable) {
        Egui.area_movable(TODO_ARG(movable));
    
    }
    
    public bool IsEnabled() {
        Egui.area_is_enabled();
    
    }
    
    public bool IsMovable() {
        Egui.area_is_movable();
    
    }
    
    public Area Interactable(bool interactable) {
        Egui.area_interactable(TODO_ARG(interactable));
    
    }
    
    public Area Sense(Sense sense) {
        Egui.area_sense(TODO_ARG(sense));
    
    }
    
    public Area Order(Order order) {
        Egui.area_order(TODO_ARG(order));
    
    }
    
    public Area DefaultPos(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Pos2", id: Id(144), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) defaultPos) {
        Egui.area_default_pos(TODO_ARG(defaultPos));
    
    }
    
    public Area DefaultSize(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Vec2", id: Id(150), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) defaultSize) {
        Egui.area_default_size(TODO_ARG(defaultSize));
    
    }
    
    public Area DefaultWidth(float defaultWidth) {
        Egui.area_default_width(TODO_ARG(defaultWidth));
    
    }
    
    public Area DefaultHeight(float defaultHeight) {
        Egui.area_default_height(TODO_ARG(defaultHeight));
    
    }
    
    public Area FixedPos(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Pos2", id: Id(144), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) fixedPos) {
        Egui.area_fixed_pos(TODO_ARG(fixedPos));
    
    }
    
    public Area Constrain(bool constrain) {
        Egui.area_constrain(TODO_ARG(constrain));
    
    }
    
    public Area ConstrainTo(Rect constrainRect) {
        Egui.area_constrain_to(TODO_ARG(constrainRect));
    
    }
    
    public Area Pivot(Align2 pivot) {
        Egui.area_pivot(TODO_ARG(pivot));
    
    }
    
    public Area CurrentPos(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Pos2", id: Id(144), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) currentPos) {
        Egui.area_current_pos(TODO_ARG(currentPos));
    
    }
    
    public Area Anchor(Align2 align, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Vec2", id: Id(150), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) offset) {
        Egui.area_anchor(TODO_ARG(align), TODO_ARG(offset));
    
    }
    
    public Area FadeIn(bool fadeIn) {
        Egui.area_fade_in(TODO_ARG(fadeIn));
    
    }
    
    public InnerResponse Show(Context ctx, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.area_show(TODO_ARG(ctx), TODO_ARG(addContents));
    
    }
}

/// <summary>
/// Keeps track of <c>Area</c>s, which are free-floating <c>Ui</c>s.
/// These <c>Area</c>s can be in any <c>Order</c>.
/// </summary>
public unsafe partial sealed class Areas : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_areas_drop(pointer);
    }
}

/// <summary>
/// What is saved between frames.
/// </summary>
public unsafe partial sealed class BarState : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_bar_state_drop(pointer);
    }
    public static BarState Load(Context ctx, Id barId) {
        Egui.bar_state_load(TODO_ARG(ctx), TODO_ARG(barId));
    
    }
    
    public void Store(Context ctx, Id barId) {
        Egui.bar_state_store(TODO_ARG(ctx), TODO_ARG(barId));
    
    }
    
    public InnerResponse? BarMenu(Response button, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.bar_state_bar_menu(TODO_ARG(button), TODO_ARG(addContents));
    
    }
}

/// <summary>
/// Clickable button with text.
/// 
/// See also <c>Button</c>.
/// </summary>
public unsafe partial sealed class Button : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_button_drop(pointer);
    }
    public Button(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.button_new(TODO_ARG(text));
    
    }
    
    public static Button Image(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Image", id: Id(1424), args: Some(AngleBracketed { args: [Lifetime("'a")], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) image) {
        Egui.button_image(TODO_ARG(image));
    
    }
    
    public static Button ImageAndText(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Image", id: Id(1424), args: Some(AngleBracketed { args: [Lifetime("'a")], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) image, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.button_image_and_text(TODO_ARG(image), TODO_ARG(text));
    
    }
    
    public static Button OptImageAndText(Image? image, WidgetText? text) {
        Egui.button_opt_image_and_text(TODO_ARG(image), TODO_ARG(text));
    
    }
    
    public Button WrapMode(TextWrapMode wrapMode) {
        Egui.button_wrap_mode(TODO_ARG(wrapMode));
    
    }
    
    public Button Wrap() {
        Egui.button_wrap();
    
    }
    
    public Button Truncate() {
        Egui.button_truncate();
    
    }
    
    public Button Fill(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Color32", id: Id(477), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) fill) {
        Egui.button_fill(TODO_ARG(fill));
    
    }
    
    public Button Stroke(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Stroke", id: Id(479), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) stroke) {
        Egui.button_stroke(TODO_ARG(stroke));
    
    }
    
    public Button Small() {
        Egui.button_small();
    
    }
    
    public Button Frame(bool frame) {
        Egui.button_frame(TODO_ARG(frame));
    
    }
    
    public Button Sense(Sense sense) {
        Egui.button_sense(TODO_ARG(sense));
    
    }
    
    public Button MinSize(Vec2 minSize) {
        Egui.button_min_size(TODO_ARG(minSize));
    
    }
    
    public Button CornerRadius(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "CornerRadius", id: Id(482), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) cornerRadius) {
        Egui.button_corner_radius(TODO_ARG(cornerRadius));
    
    }
    
    public Button Rounding(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "CornerRadius", id: Id(482), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) cornerRadius) {
        Egui.button_rounding(TODO_ARG(cornerRadius));
    
    }
    
    public Button ImageTintFollowsTextColor(bool imageTintFollowsTextColor) {
        Egui.button_image_tint_follows_text_color(TODO_ARG(imageTintFollowsTextColor));
    
    }
    
    public Button ShortcutText(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) shortcutText) {
        Egui.button_shortcut_text(TODO_ARG(shortcutText));
    
    }
    
    public Button Selected(bool selected) {
        Egui.button_selected(TODO_ARG(selected));
    
    }
}

/// <summary>
/// A typemap of many caches, all implemented with <c>CacheTrait</c>.
/// 
/// You can access egui's caches via <c>Caches</c>,
/// found with <c>MemoryMut</c>.
/// </summary>
public unsafe partial sealed class CacheStorage : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_cache_storage_drop(pointer);
    }
    public BorrowedRef { lifetime: None, is_mutable: true, type_: Generic("Cache") } Cache() {
        Egui.cache_storage_cache();
    
    }
    
    public void Update() {
        Egui.cache_storage_update();
    
    }
}

/// <summary>
/// A panel that covers the remainder of the screen,
/// i.e. whatever area is left after adding other panels.
/// 
/// The order in which you add panels matter!
/// The first panel you add will always be the outermost, and the last you add will always be the innermost.
/// 
/// ⚠ <c>CentralPanel</c> must be added after all other panels!
/// 
/// NOTE: Any <c>Window</c>s and <c>Area</c>s will cover the top-level <c>CentralPanel</c>.
/// 
/// See the module level docs for more details.
/// </summary>
public unsafe partial sealed class CentralPanel : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_central_panel_drop(pointer);
    }
    public CentralPanel Frame(Frame frame) {
        Egui.central_panel_frame(TODO_ARG(frame));
    
    }
    
    public InnerResponse ShowInside(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.central_panel_show_inside(TODO_ARG(ui), TODO_ARG(addContents));
    
    }
    
    public InnerResponse Show(Context ctx, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.central_panel_show(TODO_ARG(ctx), TODO_ARG(addContents));
    
    }
}

/// <summary>
/// Boolean on/off control with text label.
/// 
/// Usually you'd use <c>Checkbox</c> instead.
/// </summary>
public unsafe partial sealed class Checkbox : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_checkbox_drop(pointer);
    }
    public Checkbox(BorrowedRef { lifetime: Some("'a"), is_mutable: true, type_: Primitive("bool") } checked, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.checkbox_new(TODO_ARG(checked), TODO_ARG(text));
    
    }
    
    public static Checkbox WithoutText(BorrowedRef { lifetime: Some("'a"), is_mutable: true, type_: Primitive("bool") } checked) {
        Egui.checkbox_without_text(TODO_ARG(checked));
    
    }
    
    public Checkbox Indeterminate(bool indeterminate) {
        Egui.checkbox_indeterminate(TODO_ARG(indeterminate));
    
    }
}

/// <summary>
/// A header which can be collapsed/expanded, revealing a contained <c>Ui</c> region.If you want to customize the header contents, see <c>ShowHeader</c>.
/// </summary>
public unsafe partial sealed class CollapsingHeader : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_collapsing_header_drop(pointer);
    }
    public CollapsingHeader(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.collapsing_header_new(TODO_ARG(text));
    
    }
    
    public CollapsingHeader DefaultOpen(bool open) {
        Egui.collapsing_header_default_open(TODO_ARG(open));
    
    }
    
    public CollapsingHeader Open(bool? open) {
        Egui.collapsing_header_open(TODO_ARG(open));
    
    }
    
    public CollapsingHeader IdSalt(ImplTrait([TraitBound { trait_: Path { path: "Hash", id: Id(83), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) idSalt) {
        Egui.collapsing_header_id_salt(TODO_ARG(idSalt));
    
    }
    
    public CollapsingHeader IdSource(ImplTrait([TraitBound { trait_: Path { path: "Hash", id: Id(83), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) idSalt) {
        Egui.collapsing_header_id_source(TODO_ARG(idSalt));
    
    }
    
    public CollapsingHeader Enabled(bool enabled) {
        Egui.collapsing_header_enabled(TODO_ARG(enabled));
    
    }
    
    public CollapsingHeader ShowBackground(bool showBackground) {
        Egui.collapsing_header_show_background(TODO_ARG(showBackground));
    
    }
    
    public CollapsingHeader Icon(ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }, Primitive("f32"), BorrowedRef { lifetime: None, is_mutable: false, type_: ResolvedPath(Path { path: "Response", id: Id(282), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: None }) }, generic_params: [], modifier: None }, Outlives("'static")]) iconFn) {
        Egui.collapsing_header_icon(TODO_ARG(iconFn));
    
    }
    
    public CollapsingResponse Show(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addBody) {
        Egui.collapsing_header_show(TODO_ARG(ui), TODO_ARG(addBody));
    
    }
    
    public CollapsingResponse ShowUnindented(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addBody) {
        Egui.collapsing_header_show_unindented(TODO_ARG(ui), TODO_ARG(addBody));
    
    }
}

/// <summary>
/// The response from showing a <c>CollapsingHeader</c>.
/// </summary>
public unsafe partial sealed class CollapsingResponse : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_collapsing_response_drop(pointer);
    }
    public bool FullyClosed() {
        Egui.collapsing_response_fully_closed();
    
    }
    
    public bool FullyOpen() {
        Egui.collapsing_response_fully_open();
    
    }
}

/// <summary>
/// This is a a building block for building collapsing regions.
/// 
/// It is used by <c>CollapsingHeader</c> and <c>Window</c>, but can also be used on its own.
/// 
/// See <c>ShowHeader</c> for how to show a collapsing header with a custom header.
/// </summary>
public unsafe partial sealed class CollapsingState : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_collapsing_state_drop(pointer);
    }
    public static CollapsingState? Load(Context ctx, Id id) {
        Egui.collapsing_state_load(TODO_ARG(ctx), TODO_ARG(id));
    
    }
    
    public void Store(Context ctx) {
        Egui.collapsing_state_store(TODO_ARG(ctx));
    
    }
    
    public void Remove(Context ctx) {
        Egui.collapsing_state_remove(TODO_ARG(ctx));
    
    }
    
    public Id Id() {
        Egui.collapsing_state_id();
    
    }
    
    public static CollapsingState LoadWithDefaultOpen(Context ctx, Id id, bool defaultOpen) {
        Egui.collapsing_state_load_with_default_open(TODO_ARG(ctx), TODO_ARG(id), TODO_ARG(defaultOpen));
    
    }
    
    public bool IsOpen() {
        Egui.collapsing_state_is_open();
    
    }
    
    public void SetOpen(bool open) {
        Egui.collapsing_state_set_open(TODO_ARG(open));
    
    }
    
    public void Toggle(Ui ui) {
        Egui.collapsing_state_toggle(TODO_ARG(ui));
    
    }
    
    public float Openness(Context ctx) {
        Egui.collapsing_state_openness(TODO_ARG(ctx));
    
    }
    
    public HeaderResponse ShowHeader(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("HeaderRet")) }) }, generic_params: [], modifier: None }]) addHeader) {
        Egui.collapsing_state_show_header(TODO_ARG(ui), TODO_ARG(addHeader));
    
    }
    
    public InnerResponse? ShowBodyIndented(Response headerResponse, BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addBody) {
        Egui.collapsing_state_show_body_indented(TODO_ARG(headerResponse), TODO_ARG(ui), TODO_ARG(addBody));
    
    }
    
    public InnerResponse? ShowBodyUnindented(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addBody) {
        Egui.collapsing_state_show_body_unindented(TODO_ARG(ui), TODO_ARG(addBody));
    
    }
    
    public Response ShowToggleButton(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }, Primitive("f32"), BorrowedRef { lifetime: None, is_mutable: false, type_: ResolvedPath(Path { path: "Response", id: Id(282), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: None }) }, generic_params: [], modifier: None }, Outlives("'static")]) iconFn) {
        Egui.collapsing_state_show_toggle_button(TODO_ARG(ui), TODO_ARG(iconFn));
    
    }
}

/// <summary>
/// A drop-down selection menu with a descriptive label.
/// </summary>
public unsafe partial sealed class ComboBox : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_combo_box_drop(pointer);
    }
    public ComboBox(ImplTrait([TraitBound { trait_: Path { path: "std::hash::Hash", id: Id(83), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) idSalt, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) label) {
        Egui.combo_box_new(TODO_ARG(idSalt), TODO_ARG(label));
    
    }
    
    public static ComboBox FromLabel(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) label) {
        Egui.combo_box_from_label(TODO_ARG(label));
    
    }
    
    public static ComboBox FromIdSalt(ImplTrait([TraitBound { trait_: Path { path: "std::hash::Hash", id: Id(83), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) idSalt) {
        Egui.combo_box_from_id_salt(TODO_ARG(idSalt));
    
    }
    
    public static ComboBox FromIdSource(ImplTrait([TraitBound { trait_: Path { path: "std::hash::Hash", id: Id(83), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) idSalt) {
        Egui.combo_box_from_id_source(TODO_ARG(idSalt));
    
    }
    
    public ComboBox Width(float width) {
        Egui.combo_box_width(TODO_ARG(width));
    
    }
    
    public ComboBox Height(float height) {
        Egui.combo_box_height(TODO_ARG(height));
    
    }
    
    public ComboBox SelectedText(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) selectedText) {
        Egui.combo_box_selected_text(TODO_ARG(selectedText));
    
    }
    
    public ComboBox Icon(ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: false, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }, ResolvedPath(Path { path: "Rect", id: Id(162), args: Some(AngleBracketed { args: [], constraints: [] }) }), BorrowedRef { lifetime: None, is_mutable: false, type_: ResolvedPath(Path { path: "WidgetVisuals", id: Id(424), args: Some(AngleBracketed { args: [], constraints: [] }) }) }, Primitive("bool"), ResolvedPath(Path { path: "AboveOrBelow", id: Id(392), args: Some(AngleBracketed { args: [], constraints: [] }) })], output: None }) }, generic_params: [], modifier: None }, Outlives("'static")]) iconFn) {
        Egui.combo_box_icon(TODO_ARG(iconFn));
    
    }
    
    public ComboBox WrapMode(TextWrapMode wrapMode) {
        Egui.combo_box_wrap_mode(TODO_ARG(wrapMode));
    
    }
    
    public ComboBox Wrap() {
        Egui.combo_box_wrap();
    
    }
    
    public ComboBox Truncate() {
        Egui.combo_box_truncate();
    
    }
    
    public ComboBox CloseBehavior(PopupCloseBehavior closeBehavior) {
        Egui.combo_box_close_behavior(TODO_ARG(closeBehavior));
    
    }
    
    public InnerResponse ShowUi(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) menuContents) {
        Egui.combo_box_show_ui(TODO_ARG(ui), TODO_ARG(menuContents));
    
    }
    
    public Response ShowIndex(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui, BorrowedRef { lifetime: None, is_mutable: true, type_: Primitive("usize") } selected, nuint len, ImplTrait([TraitBound { trait_: Path { path: "Fn", id: Id(455), args: Some(Parenthesized { inputs: [Primitive("usize")], output: Some(Generic("Text")) }) }, generic_params: [], modifier: None }]) get) {
        Egui.combo_box_show_index(TODO_ARG(ui), TODO_ARG(selected), TODO_ARG(len), TODO_ARG(get));
    
    }
    
    public static bool IsOpen(Context ctx, Id id) {
        Egui.combo_box_is_open(TODO_ARG(ctx), TODO_ARG(id));
    
    }
}

public unsafe partial sealed class DebugRect : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_debug_rect_drop(pointer);
    }
}

/// <summary>
/// Maps URI:s to <c>Bytes</c>, e.g. found with <c>IncludeBytes!</c>.
/// 
/// By convention, the URI:s should be prefixed with <c>Bytes://</c>.
/// </summary>
public unsafe partial sealed class DefaultBytesLoader : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_default_bytes_loader_drop(pointer);
    }
    public void Insert(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Cow", id: Id(1271), args: Some(AngleBracketed { args: [Lifetime("'static"), Type(Primitive("str"))], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) uri, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Bytes", id: Id(1489), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) bytes) {
        Egui.default_bytes_loader_insert(TODO_ARG(uri), TODO_ARG(bytes));
    
    }
}

public unsafe partial sealed class DefaultTextureLoader : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_default_texture_loader_drop(pointer);
    }
}

/// <summary>
/// Tracking of drag-and-drop payload.
/// 
/// This is a low-level API.
/// 
/// For a higher-level API, see:
/// - <c>DndDragSource</c>
/// - <c>DndDropZone</c>
/// - <c>DndSetDragPayload</c>
/// - <c>DndHoverPayload</c>
/// - <c>DndReleasePayload</c>
/// 
/// See this example.
/// </summary>
public unsafe partial sealed class DragAndDrop : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_drag_and_drop_drop(pointer);
    }
    public static void SetPayload(Context ctx, Generic("Payload") payload) {
        Egui.drag_and_drop_set_payload(TODO_ARG(ctx), TODO_ARG(payload));
    
    }
    
    public static void ClearPayload(Context ctx) {
        Egui.drag_and_drop_clear_payload(TODO_ARG(ctx));
    
    }
    
    public static Arc? Payload(Context ctx) {
        Egui.drag_and_drop_payload(TODO_ARG(ctx));
    
    }
    
    public static Arc? TakePayload(Context ctx) {
        Egui.drag_and_drop_take_payload(TODO_ARG(ctx));
    
    }
    
    public static bool HasPayloadOfType(Context ctx) {
        Egui.drag_and_drop_has_payload_of_type(TODO_ARG(ctx));
    
    }
    
    public static bool HasAnyPayload(Context ctx) {
        Egui.drag_and_drop_has_any_payload(TODO_ARG(ctx));
    
    }
}

/// <summary>
/// A numeric value that you can change by dragging the number. More compact than a <c>Slider</c>.
/// </summary>
public unsafe partial sealed class DragValue : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_drag_value_drop(pointer);
    }
    public DragValue(BorrowedRef { lifetime: Some("'a"), is_mutable: true, type_: Generic("Num") } value) {
        Egui.drag_value_new(TODO_ARG(value));
    
    }
    
    public static DragValue FromGetSet(ImplTrait([Outlives("'a"), TraitBound { trait_: Path { path: "FnMut", id: Id(1319), args: Some(Parenthesized { inputs: [ResolvedPath(Path { path: "Option", id: Id(118), args: Some(AngleBracketed { args: [Type(Primitive("f64"))], constraints: [] }) })], output: Some(Primitive("f64")) }) }, generic_params: [], modifier: None }]) getSetValue) {
        Egui.drag_value_from_get_set(TODO_ARG(getSetValue));
    
    }
    
    public DragValue Speed(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(Primitive("f64"))], constraints: [] }) }, generic_params: [], modifier: None }]) speed) {
        Egui.drag_value_speed(TODO_ARG(speed));
    
    }
    
    public DragValue ClampRange(RangeInclusive range) {
        Egui.drag_value_clamp_range(TODO_ARG(range));
    
    }
    
    public DragValue Range(RangeInclusive range) {
        Egui.drag_value_range(TODO_ARG(range));
    
    }
    
    public DragValue ClampExistingToRange(bool clampExistingToRange) {
        Egui.drag_value_clamp_existing_to_range(TODO_ARG(clampExistingToRange));
    
    }
    
    public DragValue ClampToRange(bool clampToRange) {
        Egui.drag_value_clamp_to_range(TODO_ARG(clampToRange));
    
    }
    
    public DragValue Prefix(ImplTrait([TraitBound { trait_: Path { path: "ToString", id: Id(1298), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) prefix) {
        Egui.drag_value_prefix(TODO_ARG(prefix));
    
    }
    
    public DragValue Suffix(ImplTrait([TraitBound { trait_: Path { path: "ToString", id: Id(1298), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) suffix) {
        Egui.drag_value_suffix(TODO_ARG(suffix));
    
    }
    
    public DragValue MinDecimals(nuint minDecimals) {
        Egui.drag_value_min_decimals(TODO_ARG(minDecimals));
    
    }
    
    public DragValue MaxDecimals(nuint maxDecimals) {
        Egui.drag_value_max_decimals(TODO_ARG(maxDecimals));
    
    }
    
    public DragValue MaxDecimalsOpt(nuint? maxDecimals) {
        Egui.drag_value_max_decimals_opt(TODO_ARG(maxDecimals));
    
    }
    
    public DragValue FixedDecimals(nuint numDecimals) {
        Egui.drag_value_fixed_decimals(TODO_ARG(numDecimals));
    
    }
    
    public DragValue CustomFormatter(ImplTrait([Outlives("'a"), TraitBound { trait_: Path { path: "Fn", id: Id(455), args: Some(Parenthesized { inputs: [Primitive("f64"), ResolvedPath(Path { path: "RangeInclusive", id: Id(2598), args: Some(AngleBracketed { args: [Type(Primitive("usize"))], constraints: [] }) })], output: Some(ResolvedPath(Path { path: "String", id: Id(1295), args: Some(AngleBracketed { args: [], constraints: [] }) })) }) }, generic_params: [], modifier: None }]) formatter) {
        Egui.drag_value_custom_formatter(TODO_ARG(formatter));
    
    }
    
    public DragValue CustomParser(ImplTrait([Outlives("'a"), TraitBound { trait_: Path { path: "Fn", id: Id(455), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: false, type_: Primitive("str") }], output: Some(ResolvedPath(Path { path: "Option", id: Id(118), args: Some(AngleBracketed { args: [Type(Primitive("f64"))], constraints: [] }) })) }) }, generic_params: [], modifier: None }]) parser) {
        Egui.drag_value_custom_parser(TODO_ARG(parser));
    
    }
    
    public DragValue Binary(nuint minWidth, bool twosComplement) {
        Egui.drag_value_binary(TODO_ARG(minWidth), TODO_ARG(twosComplement));
    
    }
    
    public DragValue Octal(nuint minWidth, bool twosComplement) {
        Egui.drag_value_octal(TODO_ARG(minWidth), TODO_ARG(twosComplement));
    
    }
    
    public DragValue Hexadecimal(nuint minWidth, bool twosComplement, bool upper) {
        Egui.drag_value_hexadecimal(TODO_ARG(minWidth), TODO_ARG(twosComplement), TODO_ARG(upper));
    
    }
    
    public DragValue UpdateWhileEditing(bool update) {
        Egui.drag_value_update_while_editing(TODO_ARG(update));
    
    }
}

/// <summary>
/// Caches the results of a computation for one frame.
/// If it is still used next frame, it is not recomputed.
/// If it is not used next frame, it is evicted from the cache to save memory.
/// </summary>
public unsafe partial sealed class FrameCache : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_frame_cache_drop(pointer);
    }
    public FrameCache(Generic("Computer") computer) {
        Egui.frame_cache_new(TODO_ARG(computer));
    
    }
    
    public void EvictCache() {
        Egui.frame_cache_evict_cache();
    
    }
    
    public Generic("Value") Get(Generic("Key") key) {
        Egui.frame_cache_get(TODO_ARG(key));
    
    }
}

/// <summary>
/// Stores a key:value pair for the duration of this frame and the next.
/// </summary>
public unsafe partial sealed class FramePublisher : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_frame_publisher_drop(pointer);
    }
    public FramePublisher() {
        Egui.frame_publisher_new();
    
    }
    
    public void Set(Generic("Key") key, Generic("Value") value) {
        Egui.frame_publisher_set(TODO_ARG(key), TODO_ARG(value));
    
    }
    
    public Generic("Value")? Get(Generic("Key") key) {
        Egui.frame_publisher_get(TODO_ARG(key));
    
    }
    
    public void EvictCache() {
        Egui.frame_publisher_evict_cache();
    
    }
}

/// <summary>
/// A simple grid layout.
/// 
/// The cells are always laid out left to right, top-down.
/// The contents of each cell will be aligned to the left and center.
/// 
/// If you want to add multiple widgets to a cell you need to group them with
/// <c>Horizontal</c>, <c>Vertical</c> etc.
/// </summary>
public unsafe partial sealed class Grid : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_grid_drop(pointer);
    }
    public Grid(ImplTrait([TraitBound { trait_: Path { path: "std::hash::Hash", id: Id(83), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) idSalt) {
        Egui.grid_new(TODO_ARG(idSalt));
    
    }
    
    public Grid WithRowColor(Generic("F") colorPicker) {
        Egui.grid_with_row_color(TODO_ARG(colorPicker));
    
    }
    
    public Grid NumColumns(nuint numColumns) {
        Egui.grid_num_columns(TODO_ARG(numColumns));
    
    }
    
    public Grid Striped(bool striped) {
        Egui.grid_striped(TODO_ARG(striped));
    
    }
    
    public Grid MinColWidth(float minColWidth) {
        Egui.grid_min_col_width(TODO_ARG(minColWidth));
    
    }
    
    public Grid MinRowHeight(float minRowHeight) {
        Egui.grid_min_row_height(TODO_ARG(minRowHeight));
    
    }
    
    public Grid MaxColWidth(float maxColWidth) {
        Egui.grid_max_col_width(TODO_ARG(maxColWidth));
    
    }
    
    public Grid Spacing(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Vec2", id: Id(150), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) spacing) {
        Egui.grid_spacing(TODO_ARG(spacing));
    
    }
    
    public Grid StartRow(nuint startRow) {
        Egui.grid_start_row(TODO_ARG(startRow));
    
    }
    
    public InnerResponse Show(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.grid_show(TODO_ARG(ui), TODO_ARG(addContents));
    
    }
}

/// <summary>
/// From <c>ShowHeader</c>.
/// </summary>
public unsafe partial sealed class HeaderResponse : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_header_response_drop(pointer);
    }
    public bool IsOpen() {
        Egui.header_response_is_open();
    
    }
    
    public void SetOpen(bool open) {
        Egui.header_response_set_open(TODO_ARG(open));
    
    }
    
    public void Toggle() {
        Egui.header_response_toggle();
    
    }
    
    public Tuple([ResolvedPath(Path { path: "Response", id: Id(282), args: Some(AngleBracketed { args: [], constraints: [] }) }), ResolvedPath(Path { path: "InnerResponse", id: Id(239), args: Some(AngleBracketed { args: [Type(Generic("HeaderRet"))], constraints: [] }) }), ResolvedPath(Path { path: "Option", id: Id(118), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "InnerResponse", id: Id(239), args: Some(AngleBracketed { args: [Type(Generic("BodyRet"))], constraints: [] }) }))], constraints: [] }) })]) Body(ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("BodyRet")) }) }, generic_params: [], modifier: None }]) addBody) {
        Egui.header_response_body(TODO_ARG(addBody));
    
    }
    
    public Tuple([ResolvedPath(Path { path: "Response", id: Id(282), args: Some(AngleBracketed { args: [], constraints: [] }) }), ResolvedPath(Path { path: "InnerResponse", id: Id(239), args: Some(AngleBracketed { args: [Type(Generic("HeaderRet"))], constraints: [] }) }), ResolvedPath(Path { path: "Option", id: Id(118), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "InnerResponse", id: Id(239), args: Some(AngleBracketed { args: [Type(Generic("BodyRet"))], constraints: [] }) }))], constraints: [] }) })]) BodyUnindented(ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("BodyRet")) }) }, generic_params: [], modifier: None }]) addBody) {
        Egui.header_response_body_unindented(TODO_ARG(addBody));
    
    }
}

/// <summary>
/// A clickable hyperlink, e.g. to <c>"https://github.com/emilk/egui"</c>.
/// 
/// See also <c>Hyperlink</c> and <c>HyperlinkTo</c>.
/// </summary>
public unsafe partial sealed class Hyperlink : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_hyperlink_drop(pointer);
    }
    public Hyperlink(ImplTrait([TraitBound { trait_: Path { path: "ToString", id: Id(1298), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) url) {
        Egui.hyperlink_new(TODO_ARG(url));
    
    }
    
    public static Hyperlink FromLabelAndUrl(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text, ImplTrait([TraitBound { trait_: Path { path: "ToString", id: Id(1298), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) url) {
        Egui.hyperlink_from_label_and_url(TODO_ARG(text), TODO_ARG(url));
    
    }
    
    public Hyperlink OpenInNewTab(bool newTab) {
        Egui.hyperlink_open_in_new_tab(TODO_ARG(newTab));
    
    }
}

/// <summary>
/// Stores values identified by an <c>Id</c> AND the <c>TypeId</c> of the value.
/// 
/// In other words, it maps <c>(id,TypeId)</c> to any value you want.
/// 
/// Values are cloned when read, so keep them small and light.
/// If you want to store something bigger, wrap them in <c>Arc<mutex<…>></c>.
/// Also try <c>Arc<arcSwap<…>></c>.
/// 
/// Values can either be "persisted" (serializable) or "temporary" (cleared when egui is shut down).
/// 
/// You can store state using the key <c>Null</c>. The state will then only be identified by its type.
/// </summary>
public unsafe partial sealed class IdTypeMap : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_id_type_map_drop(pointer);
    }
    public void InsertTemp(Id id, Generic("T") value) {
        Egui.id_type_map_insert_temp(TODO_ARG(id), TODO_ARG(value));
    
    }
    
    public void InsertPersisted(Id id, Generic("T") value) {
        Egui.id_type_map_insert_persisted(TODO_ARG(id), TODO_ARG(value));
    
    }
    
    public Generic("T")? GetTemp(Id id) {
        Egui.id_type_map_get_temp(TODO_ARG(id));
    
    }
    
    public Generic("T")? GetPersisted(Id id) {
        Egui.id_type_map_get_persisted(TODO_ARG(id));
    
    }
    
    public BorrowedRef { lifetime: None, is_mutable: true, type_: Generic("T") } GetTempMutOr(Id id, Generic("T") orInsert) {
        Egui.id_type_map_get_temp_mut_or(TODO_ARG(id), TODO_ARG(orInsert));
    
    }
    
    public BorrowedRef { lifetime: None, is_mutable: true, type_: Generic("T") } GetPersistedMutOr(Id id, Generic("T") orInsert) {
        Egui.id_type_map_get_persisted_mut_or(TODO_ARG(id), TODO_ARG(orInsert));
    
    }
    
    public BorrowedRef { lifetime: None, is_mutable: true, type_: Generic("T") } GetTempMutOrDefault(Id id) {
        Egui.id_type_map_get_temp_mut_or_default(TODO_ARG(id));
    
    }
    
    public BorrowedRef { lifetime: None, is_mutable: true, type_: Generic("T") } GetPersistedMutOrDefault(Id id) {
        Egui.id_type_map_get_persisted_mut_or_default(TODO_ARG(id));
    
    }
    
    public BorrowedRef { lifetime: None, is_mutable: true, type_: Generic("T") } GetTempMutOrInsertWith(Id id, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [], output: Some(Generic("T")) }) }, generic_params: [], modifier: None }]) insertWith) {
        Egui.id_type_map_get_temp_mut_or_insert_with(TODO_ARG(id), TODO_ARG(insertWith));
    
    }
    
    public BorrowedRef { lifetime: None, is_mutable: true, type_: Generic("T") } GetPersistedMutOrInsertWith(Id id, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [], output: Some(Generic("T")) }) }, generic_params: [], modifier: None }]) insertWith) {
        Egui.id_type_map_get_persisted_mut_or_insert_with(TODO_ARG(id), TODO_ARG(insertWith));
    
    }
    
    public void Remove(Id id) {
        Egui.id_type_map_remove(TODO_ARG(id));
    
    }
    
    public Generic("T")? RemoveTemp(Id id) {
        Egui.id_type_map_remove_temp(TODO_ARG(id));
    
    }
    
    public void RemoveByType() {
        Egui.id_type_map_remove_by_type();
    
    }
    
    public void Clear() {
        Egui.id_type_map_clear();
    
    }
    
    public bool IsEmpty() {
        Egui.id_type_map_is_empty();
    
    }
    
    public nuint Len() {
        Egui.id_type_map_len();
    
    }
    
    public nuint CountSerialized() {
        Egui.id_type_map_count_serialized();
    
    }
    
    public nuint Count() {
        Egui.id_type_map_count();
    
    }
    
    public nuint MaxBytesPerType() {
        Egui.id_type_map_max_bytes_per_type();
    
    }
    
    public void SetMaxBytesPerType(nuint maxBytesPerType) {
        Egui.id_type_map_set_max_bytes_per_type(TODO_ARG(maxBytesPerType));
    
    }
}

/// <summary>
/// A widget which displays an image.
/// 
/// The task of actually loading the image is deferred to when the <c>Image</c> is added to the <c>Ui</c>,
/// and how it is loaded depends on the provided <c>ImageSource</c>:
/// 
/// - <c>Uri</c> will load the image using the asynchronous loading process<c>Load</c>.
/// - <c>Bytes</c> will also load the image using the asynchronous loading process<c>Load</c>, but with lower latency.
/// - <c>Texture</c> will use the provided texture.
/// 
/// See <c>Load</c> for more information.
/// 
/// ### Examples
/// // Using it in a layout:// Using it just to paint:
/// </summary>
public unsafe partial sealed class Image : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_image_drop(pointer);
    }
    public Image(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "ImageSource", id: Id(3592), args: Some(AngleBracketed { args: [Lifetime("'a")], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) source) {
        Egui.image_new(TODO_ARG(source));
    
    }
    
    public static Image FromUri(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Cow", id: Id(1271), args: Some(AngleBracketed { args: [Lifetime("'a"), Type(Primitive("str"))], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) uri) {
        Egui.image_from_uri(TODO_ARG(uri));
    
    }
    
    public static Image FromTexture(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "SizedTexture", id: Id(3501), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) texture) {
        Egui.image_from_texture(TODO_ARG(texture));
    
    }
    
    public static Image FromBytes(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Cow", id: Id(1271), args: Some(AngleBracketed { args: [Lifetime("'static"), Type(Primitive("str"))], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) uri, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Bytes", id: Id(1489), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) bytes) {
        Egui.image_from_bytes(TODO_ARG(uri), TODO_ARG(bytes));
    
    }
    
    public Image TextureOptions(TextureOptions textureOptions) {
        Egui.image_texture_options(TODO_ARG(textureOptions));
    
    }
    
    public Image MaxWidth(float width) {
        Egui.image_max_width(TODO_ARG(width));
    
    }
    
    public Image MaxHeight(float height) {
        Egui.image_max_height(TODO_ARG(height));
    
    }
    
    public Image MaxSize(Vec2 size) {
        Egui.image_max_size(TODO_ARG(size));
    
    }
    
    public Image MaintainAspectRatio(bool value) {
        Egui.image_maintain_aspect_ratio(TODO_ARG(value));
    
    }
    
    public Image FitToOriginalSize(float scale) {
        Egui.image_fit_to_original_size(TODO_ARG(scale));
    
    }
    
    public Image FitToExactSize(Vec2 size) {
        Egui.image_fit_to_exact_size(TODO_ARG(size));
    
    }
    
    public Image FitToFraction(Vec2 fraction) {
        Egui.image_fit_to_fraction(TODO_ARG(fraction));
    
    }
    
    public Image ShrinkToFit() {
        Egui.image_shrink_to_fit();
    
    }
    
    public Image Sense(Sense sense) {
        Egui.image_sense(TODO_ARG(sense));
    
    }
    
    public Image Uv(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Rect", id: Id(162), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) uv) {
        Egui.image_uv(TODO_ARG(uv));
    
    }
    
    public Image BgFill(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Color32", id: Id(477), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) bgFill) {
        Egui.image_bg_fill(TODO_ARG(bgFill));
    
    }
    
    public Image Tint(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Color32", id: Id(477), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) tint) {
        Egui.image_tint(TODO_ARG(tint));
    
    }
    
    public Image Rotate(float angle, Vec2 origin) {
        Egui.image_rotate(TODO_ARG(angle), TODO_ARG(origin));
    
    }
    
    public Image CornerRadius(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "CornerRadius", id: Id(482), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) cornerRadius) {
        Egui.image_corner_radius(TODO_ARG(cornerRadius));
    
    }
    
    public Image Rounding(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "CornerRadius", id: Id(482), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) cornerRadius) {
        Egui.image_rounding(TODO_ARG(cornerRadius));
    
    }
    
    public Image ShowLoadingSpinner(bool show) {
        Egui.image_show_loading_spinner(TODO_ARG(show));
    
    }
    
    public Image AltText(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "String", id: Id(1295), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) label) {
        Egui.image_alt_text(TODO_ARG(label));
    
    }
    
    public Vec2 CalcSize(Vec2 availableSize, Vec2? originalImageSize) {
        Egui.image_calc_size(TODO_ARG(availableSize), TODO_ARG(originalImageSize));
    
    }
    
    public Vec2? LoadAndCalcSize(Ui ui, Vec2 availableSize) {
        Egui.image_load_and_calc_size(TODO_ARG(ui), TODO_ARG(availableSize));
    
    }
    
    public Vec2? Size() {
        Egui.image_size();
    
    }
    
    public str? Uri() {
        Egui.image_uri();
    
    }
    
    public ImageOptions ImageOptions() {
        Egui.image_image_options();
    
    }
    
    public ImageSource Source(Context ctx) {
        Egui.image_source(TODO_ARG(ctx));
    
    }
    
    public TextureLoadResult LoadForSize(Context ctx, Vec2 availableSize) {
        Egui.image_load_for_size(TODO_ARG(ctx), TODO_ARG(availableSize));
    
    }
    
    public void PaintAt(Ui ui, Rect rect) {
        Egui.image_paint_at(TODO_ARG(ui), TODO_ARG(rect));
    
    }
}

/// <summary>
/// A clickable image within a frame.
/// </summary>
public unsafe partial sealed class ImageButton : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_image_button_drop(pointer);
    }
    public ImageButton(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Image", id: Id(1424), args: Some(AngleBracketed { args: [Lifetime("'a")], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) image) {
        Egui.image_button_new(TODO_ARG(image));
    
    }
    
    public ImageButton Uv(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Rect", id: Id(162), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) uv) {
        Egui.image_button_uv(TODO_ARG(uv));
    
    }
    
    public ImageButton Tint(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Color32", id: Id(477), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) tint) {
        Egui.image_button_tint(TODO_ARG(tint));
    
    }
    
    public ImageButton Selected(bool selected) {
        Egui.image_button_selected(TODO_ARG(selected));
    
    }
    
    public ImageButton Frame(bool frame) {
        Egui.image_button_frame(TODO_ARG(frame));
    
    }
    
    public ImageButton Sense(Sense sense) {
        Egui.image_button_sense(TODO_ARG(sense));
    
    }
    
    public ImageButton CornerRadius(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "CornerRadius", id: Id(482), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) cornerRadius) {
        Egui.image_button_corner_radius(TODO_ARG(cornerRadius));
    
    }
    
    public ImageButton Rounding(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "CornerRadius", id: Id(482), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) cornerRadius) {
        Egui.image_button_rounding(TODO_ARG(cornerRadius));
    
    }
}

/// <summary>
/// Viewport for immediate rendering.
/// </summary>
public unsafe partial sealed class ImmediateViewport : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_immediate_viewport_drop(pointer);
    }
}

/// <summary>
/// Returned when we wrap some ui-code and want to return both
/// the results of the inner function and the ui as a whole, e.g.:
/// </summary>
public unsafe partial sealed class InnerResponse : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_inner_response_drop(pointer);
    }
    public InnerResponse(Generic("R") inner, Response response) {
        Egui.inner_response_new(TODO_ARG(inner), TODO_ARG(response));
    
    }
}

/// <summary>
/// Options for input state handling.
/// </summary>
public unsafe partial sealed class InputOptions : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_input_options_drop(pointer);
    }
}

/// <summary>
/// Input state that egui updates each frame.
/// 
/// You can access this with <c>Input</c>.
/// 
/// You can check if <c>Egui</c> is using the inputs using
/// <c>WantsPointerInput</c> and <c>WantsKeyboardInput</c>.
/// </summary>
public unsafe partial sealed class InputState : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_input_state_drop(pointer);
    }
    public InputState BeginPass(RawInput new, bool requestedImmediateRepaintPrevFrame, float pixelsPerPoint, crate::Options options) {
        Egui.input_state_begin_pass(TODO_ARG(new), TODO_ARG(requestedImmediateRepaintPrevFrame), TODO_ARG(pixelsPerPoint), TODO_ARG(options));
    
    }
    
    public ViewportInfo Viewport() {
        Egui.input_state_viewport();
    
    }
    
    public Rect ScreenRect() {
        Egui.input_state_screen_rect();
    
    }
    
    public float ZoomDelta() {
        Egui.input_state_zoom_delta();
    
    }
    
    public Vec2 ZoomDelta2D() {
        Egui.input_state_zoom_delta_2d();
    
    }
    
    public float TimeSinceLastScroll() {
        Egui.input_state_time_since_last_scroll();
    
    }
    
    public Duration? WantsRepaintAfter() {
        Egui.input_state_wants_repaint_after();
    
    }
    
    public nuint CountAndConsumeKey(Modifiers modifiers, Key logicalKey) {
        Egui.input_state_count_and_consume_key(TODO_ARG(modifiers), TODO_ARG(logicalKey));
    
    }
    
    public bool ConsumeKey(Modifiers modifiers, Key logicalKey) {
        Egui.input_state_consume_key(TODO_ARG(modifiers), TODO_ARG(logicalKey));
    
    }
    
    public bool ConsumeShortcut(KeyboardShortcut shortcut) {
        Egui.input_state_consume_shortcut(TODO_ARG(shortcut));
    
    }
    
    public bool KeyPressed(Key desiredKey) {
        Egui.input_state_key_pressed(TODO_ARG(desiredKey));
    
    }
    
    public nuint NumPresses(Key desiredKey) {
        Egui.input_state_num_presses(TODO_ARG(desiredKey));
    
    }
    
    public bool KeyDown(Key desiredKey) {
        Egui.input_state_key_down(TODO_ARG(desiredKey));
    
    }
    
    public bool KeyReleased(Key desiredKey) {
        Egui.input_state_key_released(TODO_ARG(desiredKey));
    
    }
    
    public float PixelsPerPoint() {
        Egui.input_state_pixels_per_point();
    
    }
    
    public float PhysicalPixelSize() {
        Egui.input_state_physical_pixel_size();
    
    }
    
    public float AimRadius() {
        Egui.input_state_aim_radius();
    
    }
    
    public MultiTouchInfo? MultiTouch() {
        Egui.input_state_multi_touch();
    
    }
    
    public bool AnyTouches() {
        Egui.input_state_any_touches();
    
    }
    
    public bool HasTouchScreen() {
        Egui.input_state_has_touch_screen();
    
    }
    
    public List<Event> FilteredEvents(EventFilter filter) {
        Egui.input_state_filtered_events(TODO_ARG(filter));
    
    }
    
    public void Ui(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "crate::Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui) {
        Egui.input_state_ui(TODO_ARG(ui));
    
    }
}

/// <summary>
/// Calculated at the start of each frame
/// based on:
/// * Widget rects from precious frame
/// * Mouse/touch input
/// * Current <c>InteractionState</c>.
/// </summary>
public unsafe partial sealed class InteractionSnapshot : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_interaction_snapshot_drop(pointer);
    }
}

/// <summary>
/// Static text.
/// 
/// Usually it is more convenient to use <c>Label</c>.For full control of the text you can use <c>LayoutJob</c>
/// as argument to <c>New</c>.
/// </summary>
public unsafe partial sealed class Label : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_label_drop(pointer);
    }
    public Label(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.label_new(TODO_ARG(text));
    
    }
    
    public str Text() {
        Egui.label_text();
    
    }
    
    public Label WrapMode(TextWrapMode wrapMode) {
        Egui.label_wrap_mode(TODO_ARG(wrapMode));
    
    }
    
    public Label Wrap() {
        Egui.label_wrap();
    
    }
    
    public Label Truncate() {
        Egui.label_truncate();
    
    }
    
    public Label Extend() {
        Egui.label_extend();
    
    }
    
    public Label Halign(Align align) {
        Egui.label_halign(TODO_ARG(align));
    
    }
    
    public Label Selectable(bool selectable) {
        Egui.label_selectable(TODO_ARG(selectable));
    
    }
    
    public Label Sense(Sense sense) {
        Egui.label_sense(TODO_ARG(sense));
    
    }
    
    public Tuple([ResolvedPath(Path { path: "Pos2", id: Id(144), args: Some(AngleBracketed { args: [], constraints: [] }) }), ResolvedPath(Path { path: "Arc", id: Id(1246), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Galley", id: Id(4068), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }), ResolvedPath(Path { path: "Response", id: Id(282), args: Some(AngleBracketed { args: [], constraints: [] }) })]) LayoutInUi(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui) {
        Egui.label_layout_in_ui(TODO_ARG(ui));
    
    }
}

/// <summary>
/// Handles text selection in labels (NOT in <c>TextEdit</c>)s.
/// 
/// One state for all labels, because we only support text selection in one label at a time.
/// </summary>
public unsafe partial sealed class LabelSelectionState : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_label_selection_state_drop(pointer);
    }
    public static LabelSelectionState Load(Context ctx) {
        Egui.label_selection_state_load(TODO_ARG(ctx));
    
    }
    
    public void Store(Context ctx) {
        Egui.label_selection_state_store(TODO_ARG(ctx));
    
    }
    
    public bool HasSelection() {
        Egui.label_selection_state_has_selection();
    
    }
    
    public void ClearSelection() {
        Egui.label_selection_state_clear_selection();
    
    }
    
    public static void LabelTextSelection(Ui ui, Response response, Pos2 galleyPos, Arc galley, Color32 fallbackColor, Stroke underline) {
        Egui.label_selection_state_label_text_selection(TODO_ARG(ui), TODO_ARG(response), TODO_ARG(galleyPos), TODO_ARG(galley), TODO_ARG(fallbackColor), TODO_ARG(underline));
    
    }
}

/// <summary>
/// Clickable text, that looks like a hyperlink.
/// 
/// To link to a web page, use <c>Hyperlink</c>, <c>Hyperlink</c> or <c>HyperlinkTo</c>.
/// 
/// See also <c>Link</c>.
/// </summary>
public unsafe partial sealed class Link : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_link_drop(pointer);
    }
    public Link(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.link_new(TODO_ARG(text));
    
    }
}

/// <summary>
/// The data that egui persists between frames.
/// 
/// This includes window positions and sizes,
/// how far the user has scrolled in a <c>ScrollArea</c> etc.
/// 
/// If you want this to persist when closing your app, you should serialize <c>Memory</c> and store it.
/// For this you need to enable the <c>Persistence</c>.
/// 
/// If you want to store data for your widgets, you should look at <c>Data</c>
/// </summary>
public unsafe partial sealed class Memory : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_memory_drop(pointer);
    }
    public Areas Areas() {
        Egui.memory_areas();
    
    }
    
    public BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Areas", id: Id(3673), args: Some(AngleBracketed { args: [], constraints: [] }) }) } AreasMut() {
        Egui.memory_areas_mut();
    
    }
    
    public LayerId? LayerIdAt(Pos2 pos) {
        Egui.memory_layer_id_at(TODO_ARG(pos));
    
    }
    
    public TSTransform? LayerTransforms(LayerId layerId) {
        Egui.memory_layer_transforms(TODO_ARG(layerId));
    
    }
    
    public ImplTrait([TraitBound { trait_: Path { path: "ExactSizeIterator", id: Id(3114), args: Some(AngleBracketed { args: [], constraints: [AssocItemConstraint { name: "Item", args: AngleBracketed { args: [], constraints: [] }, binding: Equality(Type(ResolvedPath(Path { path: "LayerId", id: Id(209), args: Some(AngleBracketed { args: [], constraints: [] }) }))) }] }) }, generic_params: [], modifier: None }, Outlives("'_")]) LayerIds() {
        Egui.memory_layer_ids();
    
    }
    
    public bool HadFocusLastFrame(Id id) {
        Egui.memory_had_focus_last_frame(TODO_ARG(id));
    
    }
    
    public bool HasFocus(Id id) {
        Egui.memory_has_focus(TODO_ARG(id));
    
    }
    
    public Id? Focused() {
        Egui.memory_focused();
    
    }
    
    public void SetFocusLockFilter(Id id, EventFilter eventFilter) {
        Egui.memory_set_focus_lock_filter(TODO_ARG(id), TODO_ARG(eventFilter));
    
    }
    
    public void RequestFocus(Id id) {
        Egui.memory_request_focus(TODO_ARG(id));
    
    }
    
    public void SurrenderFocus(Id id) {
        Egui.memory_surrender_focus(TODO_ARG(id));
    
    }
    
    public bool IsAboveModalLayer(LayerId layerId) {
        Egui.memory_is_above_modal_layer(TODO_ARG(layerId));
    
    }
    
    public bool AllowsInteraction(LayerId layerId) {
        Egui.memory_allows_interaction(TODO_ARG(layerId));
    
    }
    
    public void InterestedInFocus(Id id, LayerId layerId) {
        Egui.memory_interested_in_focus(TODO_ARG(id), TODO_ARG(layerId));
    
    }
    
    public void SetModalLayer(LayerId layerId) {
        Egui.memory_set_modal_layer(TODO_ARG(layerId));
    
    }
    
    public LayerId? TopModalLayer() {
        Egui.memory_top_modal_layer();
    
    }
    
    public void StopTextInput() {
        Egui.memory_stop_text_input();
    
    }
    
    public bool IsAnythingBeingDragged() {
        Egui.memory_is_anything_being_dragged();
    
    }
    
    public bool IsBeingDragged(Id id) {
        Egui.memory_is_being_dragged(TODO_ARG(id));
    
    }
    
    public Id? DraggedId() {
        Egui.memory_dragged_id();
    
    }
    
    public void SetDraggedId(Id id) {
        Egui.memory_set_dragged_id(TODO_ARG(id));
    
    }
    
    public void StopDragging() {
        Egui.memory_stop_dragging();
    
    }
    
    public bool DraggingSomethingElse(Id notThis) {
        Egui.memory_dragging_something_else(TODO_ARG(notThis));
    
    }
    
    public void ResetAreas() {
        Egui.memory_reset_areas();
    
    }
    
    public Rect? AreaRect(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Id", id: Id(158), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) id) {
        Egui.memory_area_rect(TODO_ARG(id));
    
    }
    
    public bool IsPopupOpen(Id popupId) {
        Egui.memory_is_popup_open(TODO_ARG(popupId));
    
    }
    
    public bool AnyPopupOpen() {
        Egui.memory_any_popup_open();
    
    }
    
    public void OpenPopup(Id popupId) {
        Egui.memory_open_popup(TODO_ARG(popupId));
    
    }
    
    public void ClosePopup() {
        Egui.memory_close_popup();
    
    }
    
    public void TogglePopup(Id popupId) {
        Egui.memory_toggle_popup(TODO_ARG(popupId));
    
    }
    
    public bool EverythingIsVisible() {
        Egui.memory_everything_is_visible();
    
    }
    
    public void SetEverythingIsVisible(bool value) {
        Egui.memory_set_everything_is_visible(TODO_ARG(value));
    
    }
}

/// <summary>
/// Stores the state for the context menu.
/// </summary>
public unsafe partial sealed class MenuRootManager : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_menu_root_manager_drop(pointer);
    }
    public InnerResponse? Show(Response button, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.menu_root_manager_show(TODO_ARG(button), TODO_ARG(addContents));
    
    }
}

/// <summary>
/// Components of menu state, public for advanced usage.
/// 
/// Usually you don't need to use it directly.
/// </summary>
public unsafe partial sealed class MenuState : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_menu_state_drop(pointer);
    }
    public MenuState(Pos2 position) {
        Egui.menu_state_new(TODO_ARG(position));
    
    }
    
    public void Close() {
        Egui.menu_state_close();
    
    }
    
    public bool AreaContains(Pos2 pos) {
        Egui.menu_state_area_contains(TODO_ARG(pos));
    
    }
}

/// <summary>
/// A modal dialog.
/// Similar to a <c>Window</c> but centered and with a backdrop that
/// blocks input to the rest of the UI.
/// 
/// You can show multiple modals on top of each other. The topmost modal will always be
/// the most recently shown one.
/// </summary>
public unsafe partial sealed class Modal : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_modal_drop(pointer);
    }
    public Modal(Id id) {
        Egui.modal_new(TODO_ARG(id));
    
    }
    
    public static Area DefaultArea(Id id) {
        Egui.modal_default_area(TODO_ARG(id));
    
    }
    
    public Modal Frame(Frame frame) {
        Egui.modal_frame(TODO_ARG(frame));
    
    }
    
    public Modal BackdropColor(Color32 color) {
        Egui.modal_backdrop_color(TODO_ARG(color));
    
    }
    
    public Modal Area(Area area) {
        Egui.modal_area(TODO_ARG(area));
    
    }
    
    public ModalResponse Show(Context ctx, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("T")) }) }, generic_params: [], modifier: None }]) content) {
        Egui.modal_show(TODO_ARG(ctx), TODO_ARG(content));
    
    }
}

/// <summary>
/// The response of a modal dialog.
/// </summary>
public unsafe partial sealed class ModalResponse : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_modal_response_drop(pointer);
    }
    public bool ShouldClose() {
        Egui.modal_response_should_close();
    
    }
}

/// <summary>
/// Some global options that you can read and write.
/// 
/// See also <c>DebugOptions</c>.
/// </summary>
public unsafe partial sealed class Options : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_options_drop(pointer);
    }
    public void Ui(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "crate::Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui) {
        Egui.options_ui(TODO_ARG(ui));
    
    }
}

/// <summary>
/// Helper to paint shapes and text to a specific region on a specific layer.
/// 
/// All coordinates are screen coordinates in the unit points (one point can consist of many physical pixels).
/// 
/// A <c>Painter</c> never outlive a single frame/pass.
/// </summary>
public unsafe partial sealed class Painter : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_painter_drop(pointer);
    }
    public Painter(Context ctx, LayerId layerId, Rect clipRect) {
        Egui.painter_new(TODO_ARG(ctx), TODO_ARG(layerId), TODO_ARG(clipRect));
    
    }
    
    public Painter WithLayerId(LayerId layerId) {
        Egui.painter_with_layer_id(TODO_ARG(layerId));
    
    }
    
    public Painter WithClipRect(Rect rect) {
        Egui.painter_with_clip_rect(TODO_ARG(rect));
    
    }
    
    public void SetLayerId(LayerId layerId) {
        Egui.painter_set_layer_id(TODO_ARG(layerId));
    
    }
    
    public void SetFadeToColor(Color32? fadeToColor) {
        Egui.painter_set_fade_to_color(TODO_ARG(fadeToColor));
    
    }
    
    public void SetOpacity(float opacity) {
        Egui.painter_set_opacity(TODO_ARG(opacity));
    
    }
    
    public void MultiplyOpacity(float opacity) {
        Egui.painter_multiply_opacity(TODO_ARG(opacity));
    
    }
    
    public float Opacity() {
        Egui.painter_opacity();
    
    }
    
    public bool IsVisible() {
        Egui.painter_is_visible();
    
    }
    
    public void SetInvisible() {
        Egui.painter_set_invisible();
    
    }
    
    public Context Ctx() {
        Egui.painter_ctx();
    
    }
    
    public float PixelsPerPoint() {
        Egui.painter_pixels_per_point();
    
    }
    
    public Generic("R") Fonts(ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: false, type_: ResolvedPath(Path { path: "Fonts", id: Id(1335), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) reader) {
        Egui.painter_fonts(TODO_ARG(reader));
    
    }
    
    public LayerId LayerId() {
        Egui.painter_layer_id();
    
    }
    
    public Rect ClipRect() {
        Egui.painter_clip_rect();
    
    }
    
    public void ShrinkClipRect(Rect newClipRect) {
        Egui.painter_shrink_clip_rect(TODO_ARG(newClipRect));
    
    }
    
    public void SetClipRect(Rect clipRect) {
        Egui.painter_set_clip_rect(TODO_ARG(clipRect));
    
    }
    
    public float RoundToPixelCenter(float point) {
        Egui.painter_round_to_pixel_center(TODO_ARG(point));
    
    }
    
    public Pos2 RoundPosToPixelCenter(Pos2 pos) {
        Egui.painter_round_pos_to_pixel_center(TODO_ARG(pos));
    
    }
    
    public float RoundToPixel(float point) {
        Egui.painter_round_to_pixel(TODO_ARG(point));
    
    }
    
    public Vec2 RoundVecToPixels(Vec2 vec) {
        Egui.painter_round_vec_to_pixels(TODO_ARG(vec));
    
    }
    
    public Pos2 RoundPosToPixels(Pos2 pos) {
        Egui.painter_round_pos_to_pixels(TODO_ARG(pos));
    
    }
    
    public Rect RoundRectToPixels(Rect rect) {
        Egui.painter_round_rect_to_pixels(TODO_ARG(rect));
    
    }
    
    public ShapeIdx Add(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Shape", id: Id(520), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) shape) {
        Egui.painter_add(TODO_ARG(shape));
    
    }
    
    public void Extend(Generic("I") shapes) {
        Egui.painter_extend(TODO_ARG(shapes));
    
    }
    
    public void Set(ShapeIdx idx, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Shape", id: Id(520), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) shape) {
        Egui.painter_set(TODO_ARG(idx), TODO_ARG(shape));
    
    }
    
    public void ForEachShape(ImplTrait([TraitBound { trait_: Path { path: "FnMut", id: Id(1319), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: false, type_: ResolvedPath(Path { path: "ClippedShape", id: Id(1435), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: None }) }, generic_params: [], modifier: None }]) reader) {
        Egui.painter_for_each_shape(TODO_ARG(reader));
    
    }
    
    public void DebugRect(Rect rect, Color32 color, ImplTrait([TraitBound { trait_: Path { path: "ToString", id: Id(1298), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.painter_debug_rect(TODO_ARG(rect), TODO_ARG(color), TODO_ARG(text));
    
    }
    
    public Rect Error(Pos2 pos, ImplTrait([TraitBound { trait_: Path { path: "std::fmt::Display", id: Id(1297), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.painter_error(TODO_ARG(pos), TODO_ARG(text));
    
    }
    
    public Rect DebugText(Pos2 pos, Align2 anchor, Color32 color, ImplTrait([TraitBound { trait_: Path { path: "ToString", id: Id(1298), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.painter_debug_text(TODO_ARG(pos), TODO_ARG(anchor), TODO_ARG(color), TODO_ARG(text));
    
    }
    
    public ShapeIdx LineSegment(Array { type_: ResolvedPath(Path { path: "Pos2", id: Id(144), args: Some(AngleBracketed { args: [], constraints: [] }) }), len: "2" } points, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Stroke", id: Id(479), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) stroke) {
        Egui.painter_line_segment(TODO_ARG(points), TODO_ARG(stroke));
    
    }
    
    public ShapeIdx Line(List<Pos2> points, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "PathStroke", id: Id(4049), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) stroke) {
        Egui.painter_line(TODO_ARG(points), TODO_ARG(stroke));
    
    }
    
    public ShapeIdx Hline(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Rangef", id: Id(696), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) x, float y, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Stroke", id: Id(479), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) stroke) {
        Egui.painter_hline(TODO_ARG(x), TODO_ARG(y), TODO_ARG(stroke));
    
    }
    
    public ShapeIdx Vline(float x, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Rangef", id: Id(696), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) y, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Stroke", id: Id(479), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) stroke) {
        Egui.painter_vline(TODO_ARG(x), TODO_ARG(y), TODO_ARG(stroke));
    
    }
    
    public ShapeIdx Circle(Pos2 center, float radius, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Color32", id: Id(477), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) fillColor, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Stroke", id: Id(479), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) stroke) {
        Egui.painter_circle(TODO_ARG(center), TODO_ARG(radius), TODO_ARG(fillColor), TODO_ARG(stroke));
    
    }
    
    public ShapeIdx CircleFilled(Pos2 center, float radius, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Color32", id: Id(477), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) fillColor) {
        Egui.painter_circle_filled(TODO_ARG(center), TODO_ARG(radius), TODO_ARG(fillColor));
    
    }
    
    public ShapeIdx CircleStroke(Pos2 center, float radius, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Stroke", id: Id(479), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) stroke) {
        Egui.painter_circle_stroke(TODO_ARG(center), TODO_ARG(radius), TODO_ARG(stroke));
    
    }
    
    public ShapeIdx Rect(Rect rect, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "CornerRadius", id: Id(482), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) cornerRadius, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Color32", id: Id(477), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) fillColor, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Stroke", id: Id(479), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) stroke, StrokeKind strokeKind) {
        Egui.painter_rect(TODO_ARG(rect), TODO_ARG(cornerRadius), TODO_ARG(fillColor), TODO_ARG(stroke), TODO_ARG(strokeKind));
    
    }
    
    public ShapeIdx RectFilled(Rect rect, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "CornerRadius", id: Id(482), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) cornerRadius, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Color32", id: Id(477), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) fillColor) {
        Egui.painter_rect_filled(TODO_ARG(rect), TODO_ARG(cornerRadius), TODO_ARG(fillColor));
    
    }
    
    public ShapeIdx RectStroke(Rect rect, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "CornerRadius", id: Id(482), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) cornerRadius, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Stroke", id: Id(479), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) stroke, StrokeKind strokeKind) {
        Egui.painter_rect_stroke(TODO_ARG(rect), TODO_ARG(cornerRadius), TODO_ARG(stroke), TODO_ARG(strokeKind));
    
    }
    
    public void Arrow(Pos2 origin, Vec2 vec, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Stroke", id: Id(479), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) stroke) {
        Egui.painter_arrow(TODO_ARG(origin), TODO_ARG(vec), TODO_ARG(stroke));
    
    }
    
    public ShapeIdx Image(TextureId textureId, Rect rect, Rect uv, Color32 tint) {
        Egui.painter_image(TODO_ARG(textureId), TODO_ARG(rect), TODO_ARG(uv), TODO_ARG(tint));
    
    }
    
    public Rect Text(Pos2 pos, Align2 anchor, ImplTrait([TraitBound { trait_: Path { path: "ToString", id: Id(1298), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) text, FontId fontId, Color32 textColor) {
        Egui.painter_text(TODO_ARG(pos), TODO_ARG(anchor), TODO_ARG(text), TODO_ARG(fontId), TODO_ARG(textColor));
    
    }
    
    public Arc Layout(string text, FontId fontId, Color32 color, float wrapWidth) {
        Egui.painter_layout(TODO_ARG(text), TODO_ARG(fontId), TODO_ARG(color), TODO_ARG(wrapWidth));
    
    }
    
    public Arc LayoutNoWrap(string text, FontId fontId, Color32 color) {
        Egui.painter_layout_no_wrap(TODO_ARG(text), TODO_ARG(fontId), TODO_ARG(color));
    
    }
    
    public Arc LayoutJob(LayoutJob layoutJob) {
        Egui.painter_layout_job(TODO_ARG(layoutJob));
    
    }
    
    public void Galley(Pos2 pos, Arc galley, Color32 fallbackColor) {
        Egui.painter_galley(TODO_ARG(pos), TODO_ARG(galley), TODO_ARG(fallbackColor));
    
    }
    
    public void GalleyWithOverrideTextColor(Pos2 pos, Arc galley, Color32 textColor) {
        Egui.painter_galley_with_override_text_color(TODO_ARG(pos), TODO_ARG(galley), TODO_ARG(textColor));
    
    }
    
    public void GalleyWithColor(Pos2 pos, Arc galley, Color32 textColor) {
        Egui.painter_galley_with_color(TODO_ARG(pos), TODO_ARG(galley), TODO_ARG(textColor));
    
    }
}

/// <summary>
/// State that is collected during a pass, then saved for the next pass,
/// and then cleared.
/// 
/// (NOTE: we usually run only one pass per frame).
/// 
/// One per viewport.
/// </summary>
public unsafe partial sealed class PassState : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_pass_state_drop(pointer);
    }
}

public unsafe partial sealed class PerLayerState : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_per_layer_state_drop(pointer);
    }
}

public unsafe partial sealed class PerWidgetTooltipState : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_per_widget_tooltip_state_drop(pointer);
    }
}

/// <summary>
/// Mouse or touch state.
/// </summary>
public unsafe partial sealed class PointerState : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_pointer_state_drop(pointer);
    }
    public Vec2 Delta() {
        Egui.pointer_state_delta();
    
    }
    
    public Vec2? Motion() {
        Egui.pointer_state_motion();
    
    }
    
    public Vec2 Velocity() {
        Egui.pointer_state_velocity();
    
    }
    
    public Vec2 Direction() {
        Egui.pointer_state_direction();
    
    }
    
    public Pos2? PressOrigin() {
        Egui.pointer_state_press_origin();
    
    }
    
    public double? PressStartTime() {
        Egui.pointer_state_press_start_time();
    
    }
    
    public Pos2? LatestPos() {
        Egui.pointer_state_latest_pos();
    
    }
    
    public Pos2? HoverPos() {
        Egui.pointer_state_hover_pos();
    
    }
    
    public Pos2? InteractPos() {
        Egui.pointer_state_interact_pos();
    
    }
    
    public bool HasPointer() {
        Egui.pointer_state_has_pointer();
    
    }
    
    public bool IsStill() {
        Egui.pointer_state_is_still();
    
    }
    
    public bool IsMoving() {
        Egui.pointer_state_is_moving();
    
    }
    
    public float TimeSinceLastMovement() {
        Egui.pointer_state_time_since_last_movement();
    
    }
    
    public float TimeSinceLastClick() {
        Egui.pointer_state_time_since_last_click();
    
    }
    
    public bool AnyPressed() {
        Egui.pointer_state_any_pressed();
    
    }
    
    public bool AnyReleased() {
        Egui.pointer_state_any_released();
    
    }
    
    public bool ButtonPressed(PointerButton button) {
        Egui.pointer_state_button_pressed(TODO_ARG(button));
    
    }
    
    public bool ButtonReleased(PointerButton button) {
        Egui.pointer_state_button_released(TODO_ARG(button));
    
    }
    
    public bool PrimaryPressed() {
        Egui.pointer_state_primary_pressed();
    
    }
    
    public bool SecondaryPressed() {
        Egui.pointer_state_secondary_pressed();
    
    }
    
    public bool PrimaryReleased() {
        Egui.pointer_state_primary_released();
    
    }
    
    public bool SecondaryReleased() {
        Egui.pointer_state_secondary_released();
    
    }
    
    public bool AnyDown() {
        Egui.pointer_state_any_down();
    
    }
    
    public bool AnyClick() {
        Egui.pointer_state_any_click();
    
    }
    
    public bool ButtonClicked(PointerButton button) {
        Egui.pointer_state_button_clicked(TODO_ARG(button));
    
    }
    
    public bool ButtonDoubleClicked(PointerButton button) {
        Egui.pointer_state_button_double_clicked(TODO_ARG(button));
    
    }
    
    public bool ButtonTripleClicked(PointerButton button) {
        Egui.pointer_state_button_triple_clicked(TODO_ARG(button));
    
    }
    
    public bool PrimaryClicked() {
        Egui.pointer_state_primary_clicked();
    
    }
    
    public bool SecondaryClicked() {
        Egui.pointer_state_secondary_clicked();
    
    }
    
    public bool ButtonDown(PointerButton button) {
        Egui.pointer_state_button_down(TODO_ARG(button));
    
    }
    
    public bool CouldAnyButtonBeClick() {
        Egui.pointer_state_could_any_button_be_click();
    
    }
    
    public bool IsDecidedlyDragging() {
        Egui.pointer_state_is_decidedly_dragging();
    
    }
    
    public bool PrimaryDown() {
        Egui.pointer_state_primary_down();
    
    }
    
    public bool SecondaryDown() {
        Egui.pointer_state_secondary_down();
    
    }
    
    public bool MiddleDown() {
        Egui.pointer_state_middle_down();
    
    }
    
    public void Ui(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "crate::Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui) {
        Egui.pointer_state_ui(TODO_ARG(ui));
    
    }
}

public unsafe partial sealed class Prepared : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_prepared_drop(pointer);
    }
    public Response AllocateSpace(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui) {
        Egui.prepared_allocate_space(TODO_ARG(ui));
    
    }
    
    public void Paint(Ui ui) {
        Egui.prepared_paint(TODO_ARG(ui));
    
    }
    
    public Response End(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui) {
        Egui.prepared_end(TODO_ARG(ui));
    
    }
}

/// <summary>
/// A simple progress bar.
/// 
/// See also: <c>Spinner</c>.
/// </summary>
public unsafe partial sealed class ProgressBar : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_progress_bar_drop(pointer);
    }
    public ProgressBar(float progress) {
        Egui.progress_bar_new(TODO_ARG(progress));
    
    }
    
    public ProgressBar DesiredWidth(float desiredWidth) {
        Egui.progress_bar_desired_width(TODO_ARG(desiredWidth));
    
    }
    
    public ProgressBar DesiredHeight(float desiredHeight) {
        Egui.progress_bar_desired_height(TODO_ARG(desiredHeight));
    
    }
    
    public ProgressBar Fill(Color32 color) {
        Egui.progress_bar_fill(TODO_ARG(color));
    
    }
    
    public ProgressBar Text(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.progress_bar_text(TODO_ARG(text));
    
    }
    
    public ProgressBar ShowPercentage() {
        Egui.progress_bar_show_percentage();
    
    }
    
    public ProgressBar Animate(bool animate) {
        Egui.progress_bar_animate(TODO_ARG(animate));
    
    }
    
    public ProgressBar CornerRadius(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "CornerRadius", id: Id(482), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) cornerRadius) {
        Egui.progress_bar_corner_radius(TODO_ARG(cornerRadius));
    
    }
    
    public ProgressBar Rounding(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "CornerRadius", id: Id(482), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) cornerRadius) {
        Egui.progress_bar_rounding(TODO_ARG(cornerRadius));
    
    }
}

/// <summary>
/// One out of several alternatives, either selected or not.
/// 
/// Usually you'd use <c>RadioValue</c> or <c>Radio</c> instead.
/// </summary>
public unsafe partial sealed class RadioButton : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_radio_button_drop(pointer);
    }
    public RadioButton(bool checked, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.radio_button_new(TODO_ARG(checked), TODO_ARG(text));
    
    }
}

/// <summary>
/// A region that can be resized by dragging the bottom right corner.
/// </summary>
public unsafe partial sealed class Resize : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_resize_drop(pointer);
    }
    public Resize Id(Id id) {
        Egui.resize_id(TODO_ARG(id));
    
    }
    
    public Resize IdSource(ImplTrait([TraitBound { trait_: Path { path: "std::hash::Hash", id: Id(83), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) idSalt) {
        Egui.resize_id_source(TODO_ARG(idSalt));
    
    }
    
    public Resize IdSalt(ImplTrait([TraitBound { trait_: Path { path: "std::hash::Hash", id: Id(83), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) idSalt) {
        Egui.resize_id_salt(TODO_ARG(idSalt));
    
    }
    
    public Resize DefaultWidth(float width) {
        Egui.resize_default_width(TODO_ARG(width));
    
    }
    
    public Resize DefaultHeight(float height) {
        Egui.resize_default_height(TODO_ARG(height));
    
    }
    
    public Resize DefaultSize(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Vec2", id: Id(150), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) defaultSize) {
        Egui.resize_default_size(TODO_ARG(defaultSize));
    
    }
    
    public Resize MinSize(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Vec2", id: Id(150), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) minSize) {
        Egui.resize_min_size(TODO_ARG(minSize));
    
    }
    
    public Resize MinWidth(float minWidth) {
        Egui.resize_min_width(TODO_ARG(minWidth));
    
    }
    
    public Resize MinHeight(float minHeight) {
        Egui.resize_min_height(TODO_ARG(minHeight));
    
    }
    
    public Resize MaxSize(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Vec2", id: Id(150), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) maxSize) {
        Egui.resize_max_size(TODO_ARG(maxSize));
    
    }
    
    public Resize MaxWidth(float maxWidth) {
        Egui.resize_max_width(TODO_ARG(maxWidth));
    
    }
    
    public Resize MaxHeight(float maxHeight) {
        Egui.resize_max_height(TODO_ARG(maxHeight));
    
    }
    
    public Resize Resizable(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Vec2b", id: Id(868), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) resizable) {
        Egui.resize_resizable(TODO_ARG(resizable));
    
    }
    
    public Vec2b IsResizable() {
        Egui.resize_is_resizable();
    
    }
    
    public Resize AutoSized() {
        Egui.resize_auto_sized();
    
    }
    
    public Resize FixedSize(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Vec2", id: Id(150), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) size) {
        Egui.resize_fixed_size(TODO_ARG(size));
    
    }
    
    public Resize WithStroke(bool withStroke) {
        Egui.resize_with_stroke(TODO_ARG(withStroke));
    
    }
    
    public Generic("R") Show(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.resize_show(TODO_ARG(ui), TODO_ARG(addContents));
    
    }
}

/// <summary>
/// The result of adding a widget to a <c>Ui</c>.
/// 
/// A <c>Response</c> lets you know whether a widget is being hovered, clicked or dragged.
/// It also lets you easily show a tooltip on hover.
/// 
/// Whenever something gets added to a <c>Ui</c>, a <c>Response</c> object is returned.
/// <c>Ui.add</c> returns a <c>Response</c>, as does <c>Ui.button</c>, and all similar shortcuts.
/// 
/// ⚠️ The <c>Response</c> contains a clone of <c>Context</c>, and many methods lock the <c>Context</c>.
/// It can therefore be a deadlock to use <c>Context</c> from within a context-locking closures,
/// such as <c>Input</c>.
/// </summary>
public unsafe partial sealed class Response : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_response_drop(pointer);
    }
    public bool Clicked() {
        Egui.response_clicked();
    
    }
    
    public bool ClickedBy(PointerButton button) {
        Egui.response_clicked_by(TODO_ARG(button));
    
    }
    
    public bool SecondaryClicked() {
        Egui.response_secondary_clicked();
    
    }
    
    public bool LongTouched() {
        Egui.response_long_touched();
    
    }
    
    public bool MiddleClicked() {
        Egui.response_middle_clicked();
    
    }
    
    public bool DoubleClicked() {
        Egui.response_double_clicked();
    
    }
    
    public bool TripleClicked() {
        Egui.response_triple_clicked();
    
    }
    
    public bool DoubleClickedBy(PointerButton button) {
        Egui.response_double_clicked_by(TODO_ARG(button));
    
    }
    
    public bool TripleClickedBy(PointerButton button) {
        Egui.response_triple_clicked_by(TODO_ARG(button));
    
    }
    
    public bool ClickedElsewhere() {
        Egui.response_clicked_elsewhere();
    
    }
    
    public bool Enabled() {
        Egui.response_enabled();
    
    }
    
    public bool Hovered() {
        Egui.response_hovered();
    
    }
    
    public bool ContainsPointer() {
        Egui.response_contains_pointer();
    
    }
    
    public bool HasFocus() {
        Egui.response_has_focus();
    
    }
    
    public bool GainedFocus() {
        Egui.response_gained_focus();
    
    }
    
    public bool LostFocus() {
        Egui.response_lost_focus();
    
    }
    
    public void RequestFocus() {
        Egui.response_request_focus();
    
    }
    
    public void SurrenderFocus() {
        Egui.response_surrender_focus();
    
    }
    
    public bool DragStarted() {
        Egui.response_drag_started();
    
    }
    
    public bool DragStartedBy(PointerButton button) {
        Egui.response_drag_started_by(TODO_ARG(button));
    
    }
    
    public bool Dragged() {
        Egui.response_dragged();
    
    }
    
    public bool DraggedBy(PointerButton button) {
        Egui.response_dragged_by(TODO_ARG(button));
    
    }
    
    public bool DragStopped() {
        Egui.response_drag_stopped();
    
    }
    
    public bool DragStoppedBy(PointerButton button) {
        Egui.response_drag_stopped_by(TODO_ARG(button));
    
    }
    
    public bool DragReleased() {
        Egui.response_drag_released();
    
    }
    
    public bool DragReleasedBy(PointerButton button) {
        Egui.response_drag_released_by(TODO_ARG(button));
    
    }
    
    public Vec2 DragDelta() {
        Egui.response_drag_delta();
    
    }
    
    public Vec2 DragMotion() {
        Egui.response_drag_motion();
    
    }
    
    public void DndSetDragPayload(Generic("Payload") payload) {
        Egui.response_dnd_set_drag_payload(TODO_ARG(payload));
    
    }
    
    public Arc? DndHoverPayload() {
        Egui.response_dnd_hover_payload();
    
    }
    
    public Arc? DndReleasePayload() {
        Egui.response_dnd_release_payload();
    
    }
    
    public Pos2? InteractPointerPos() {
        Egui.response_interact_pointer_pos();
    
    }
    
    public Pos2? HoverPos() {
        Egui.response_hover_pos();
    
    }
    
    public bool IsPointerButtonDownOn() {
        Egui.response_is_pointer_button_down_on();
    
    }
    
    public bool Changed() {
        Egui.response_changed();
    
    }
    
    public void MarkChanged() {
        Egui.response_mark_changed();
    
    }
    
    public Response OnHoverUi(ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: None }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.response_on_hover_ui(TODO_ARG(addContents));
    
    }
    
    public Response OnDisabledHoverUi(ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: None }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.response_on_disabled_hover_ui(TODO_ARG(addContents));
    
    }
    
    public Response OnHoverUiAtPointer(ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: None }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.response_on_hover_ui_at_pointer(TODO_ARG(addContents));
    
    }
    
    public void ShowTooltipUi(ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: None }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.response_show_tooltip_ui(TODO_ARG(addContents));
    
    }
    
    public void ShowTooltipText(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.response_show_tooltip_text(TODO_ARG(text));
    
    }
    
    public bool IsTooltipOpen() {
        Egui.response_is_tooltip_open();
    
    }
    
    public Response OnHoverTextAtPointer(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.response_on_hover_text_at_pointer(TODO_ARG(text));
    
    }
    
    public Response OnHoverText(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.response_on_hover_text(TODO_ARG(text));
    
    }
    
    public Response Highlight() {
        Egui.response_highlight();
    
    }
    
    public Response OnDisabledHoverText(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.response_on_disabled_hover_text(TODO_ARG(text));
    
    }
    
    public Response OnHoverCursor(CursorIcon cursor) {
        Egui.response_on_hover_cursor(TODO_ARG(cursor));
    
    }
    
    public Response OnHoverAndDragCursor(CursorIcon cursor) {
        Egui.response_on_hover_and_drag_cursor(TODO_ARG(cursor));
    
    }
    
    public Response Interact(Sense sense) {
        Egui.response_interact(TODO_ARG(sense));
    
    }
    
    public void ScrollToMe(Align? align) {
        Egui.response_scroll_to_me(TODO_ARG(align));
    
    }
    
    public void ScrollToMeAnimation(Align? align, ScrollAnimation animation) {
        Egui.response_scroll_to_me_animation(TODO_ARG(align), TODO_ARG(animation));
    
    }
    
    public void WidgetInfo(ImplTrait([TraitBound { trait_: Path { path: "Fn", id: Id(455), args: Some(Parenthesized { inputs: [], output: Some(ResolvedPath(Path { path: "crate::WidgetInfo", id: Id(1351), args: Some(AngleBracketed { args: [], constraints: [] }) })) }) }, generic_params: [], modifier: None }]) makeInfo) {
        Egui.response_widget_info(TODO_ARG(makeInfo));
    
    }
    
    public void OutputEvent(crate::output::OutputEvent event) {
        Egui.response_output_event(TODO_ARG(event));
    
    }
    
    public Response LabelledBy(Id id) {
        Egui.response_labelled_by(TODO_ARG(id));
    
    }
    
    public InnerResponse? ContextMenu(ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: None }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.response_context_menu(TODO_ARG(addContents));
    
    }
    
    public bool ContextMenuOpened() {
        Egui.response_context_menu_opened();
    
    }
    
    public void PaintDebugInfo() {
        Egui.response_paint_debug_info();
    
    }
    
    public Response Union(Response other) {
        Egui.response_union(TODO_ARG(other));
    
    }
    
    public Response WithNewRect(Rect rect) {
        Egui.response_with_new_rect(TODO_ARG(rect));
    
    }
}

/// <summary>
/// Text and optional style choices for it.
/// 
/// The style choices (font, color) are applied to the entire text.
/// For more detailed control, use <c>LayoutJob</c> instead.
/// 
/// A <c>RichText</c> can be used in most widgets and helper functions, e.g. <c>Label</c> and <c>Button</c>.
/// 
/// ### Example
/// </summary>
public unsafe partial sealed class RichText : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_rich_text_drop(pointer);
    }
    public RichText(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "String", id: Id(1295), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.rich_text_new(TODO_ARG(text));
    
    }
    
    public bool IsEmpty() {
        Egui.rich_text_is_empty();
    
    }
    
    public str Text() {
        Egui.rich_text_text();
    
    }
    
    public RichText Size(float size) {
        Egui.rich_text_size(TODO_ARG(size));
    
    }
    
    public RichText ExtraLetterSpacing(float extraLetterSpacing) {
        Egui.rich_text_extra_letter_spacing(TODO_ARG(extraLetterSpacing));
    
    }
    
    public RichText LineHeight(float? lineHeight) {
        Egui.rich_text_line_height(TODO_ARG(lineHeight));
    
    }
    
    public RichText Family(FontFamily family) {
        Egui.rich_text_family(TODO_ARG(family));
    
    }
    
    public RichText Font(crate::FontId fontId) {
        Egui.rich_text_font(TODO_ARG(fontId));
    
    }
    
    public RichText TextStyle(TextStyle textStyle) {
        Egui.rich_text_text_style(TODO_ARG(textStyle));
    
    }
    
    public RichText FallbackTextStyle(TextStyle textStyle) {
        Egui.rich_text_fallback_text_style(TODO_ARG(textStyle));
    
    }
    
    public RichText Heading() {
        Egui.rich_text_heading();
    
    }
    
    public RichText Monospace() {
        Egui.rich_text_monospace();
    
    }
    
    public RichText Code() {
        Egui.rich_text_code();
    
    }
    
    public RichText Strong() {
        Egui.rich_text_strong();
    
    }
    
    public RichText Weak() {
        Egui.rich_text_weak();
    
    }
    
    public RichText Underline() {
        Egui.rich_text_underline();
    
    }
    
    public RichText Strikethrough() {
        Egui.rich_text_strikethrough();
    
    }
    
    public RichText Italics() {
        Egui.rich_text_italics();
    
    }
    
    public RichText Small() {
        Egui.rich_text_small();
    
    }
    
    public RichText SmallRaised() {
        Egui.rich_text_small_raised();
    
    }
    
    public RichText Raised() {
        Egui.rich_text_raised();
    
    }
    
    public RichText BackgroundColor(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Color32", id: Id(477), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) backgroundColor) {
        Egui.rich_text_background_color(TODO_ARG(backgroundColor));
    
    }
    
    public RichText Color(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Color32", id: Id(477), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) color) {
        Egui.rich_text_color(TODO_ARG(color));
    
    }
    
    public float FontHeight(epaint::Fonts fonts, Style style) {
        Egui.rich_text_font_height(TODO_ARG(fonts), TODO_ARG(style));
    
    }
    
    public void AppendTo(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "LayoutJob", id: Id(4070), args: Some(AngleBracketed { args: [], constraints: [] }) }) } layoutJob, Style style, FontSelection fallbackFont, Align defaultValign) {
        Egui.rich_text_append_to(TODO_ARG(layoutJob), TODO_ARG(style), TODO_ARG(fallbackFont), TODO_ARG(defaultValign));
    
    }
}

/// <summary>
/// A container that allows you to zoom and pan.
/// 
/// This is similar to <c>ScrollArea</c> but:
/// * Supports zooming
/// * Has no scroll bars
/// * Has no limits on the scrolling
/// </summary>
public unsafe partial sealed class Scene : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_scene_drop(pointer);
    }
    public Scene() {
        Egui.scene_new();
    
    }
    
    public Scene ZoomRange(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Rangef", id: Id(696), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) zoomRange) {
        Egui.scene_zoom_range(TODO_ARG(zoomRange));
    
    }
    
    public Scene MaxInnerSize(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Vec2", id: Id(150), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) maxInnerSize) {
        Egui.scene_max_inner_size(TODO_ARG(maxInnerSize));
    
    }
    
    public InnerResponse Show(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } parentUi, BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Rect", id: Id(162), args: Some(AngleBracketed { args: [], constraints: [] }) }) } sceneRect, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.scene_show(TODO_ARG(parentUi), TODO_ARG(sceneRect), TODO_ARG(addContents));
    
    }
    
    public void RegisterPanAndZoom(Ui ui, BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Response", id: Id(282), args: Some(AngleBracketed { args: [], constraints: [] }) }) } resp, BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "TSTransform", id: Id(908), args: Some(AngleBracketed { args: [], constraints: [] }) }) } toGlobal) {
        Egui.scene_register_pan_and_zoom(TODO_ARG(ui), TODO_ARG(resp), TODO_ARG(toGlobal));
    
    }
}

/// <summary>
/// Add vertical and/or horizontal scrolling to a contained <c>Ui</c>.
/// 
/// By default, scroll bars only show up when needed, i.e. when the contents
/// is larger than the container.
/// This is controlled by <c>ScrollBarVisibility</c>.
/// 
/// There are two flavors of scroll areas: solid and floating.
/// Solid scroll bars use up space, reducing the amount of space available
/// to the contents. Floating scroll bars float on top of the contents, covering it.
/// You can change the scroll style by changing the <c>Scroll</c>.
/// 
/// ### Coordinate system
/// * content: size of contents (generally large; that's why we want scroll bars)
/// * outer: size of scroll area including scroll bar(s)
/// * inner: excluding scroll bar(s). The area we clip the contents to.
/// 
/// If the floating scroll bars settings is turned on then <c>Inner==Outer</c>.
/// 
/// ## ExampleYou can scroll to an element using <c>ScrollToMe</c>, <c>ScrollToCursor</c> and <c>ScrollToRect</c>.
/// 
/// ## See also
/// If you want to allow zooming, use <c>Scene</c>.
/// </summary>
public unsafe partial sealed class ScrollArea : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_scroll_area_drop(pointer);
    }
    public static ScrollArea Horizontal() {
        Egui.scroll_area_horizontal();
    
    }
    
    public static ScrollArea Vertical() {
        Egui.scroll_area_vertical();
    
    }
    
    public static ScrollArea Both() {
        Egui.scroll_area_both();
    
    }
    
    public static ScrollArea Neither() {
        Egui.scroll_area_neither();
    
    }
    
    public ScrollArea(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Vec2b", id: Id(868), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) scrollEnabled) {
        Egui.scroll_area_new(TODO_ARG(scrollEnabled));
    
    }
    
    public ScrollArea MaxWidth(float maxWidth) {
        Egui.scroll_area_max_width(TODO_ARG(maxWidth));
    
    }
    
    public ScrollArea MaxHeight(float maxHeight) {
        Egui.scroll_area_max_height(TODO_ARG(maxHeight));
    
    }
    
    public ScrollArea MinScrolledWidth(float minScrolledWidth) {
        Egui.scroll_area_min_scrolled_width(TODO_ARG(minScrolledWidth));
    
    }
    
    public ScrollArea MinScrolledHeight(float minScrolledHeight) {
        Egui.scroll_area_min_scrolled_height(TODO_ARG(minScrolledHeight));
    
    }
    
    public ScrollArea ScrollBarVisibility(ScrollBarVisibility scrollBarVisibility) {
        Egui.scroll_area_scroll_bar_visibility(TODO_ARG(scrollBarVisibility));
    
    }
    
    public ScrollArea ScrollBarRect(Rect scrollBarRect) {
        Egui.scroll_area_scroll_bar_rect(TODO_ARG(scrollBarRect));
    
    }
    
    public ScrollArea IdSource(ImplTrait([TraitBound { trait_: Path { path: "std::hash::Hash", id: Id(83), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) idSalt) {
        Egui.scroll_area_id_source(TODO_ARG(idSalt));
    
    }
    
    public ScrollArea IdSalt(ImplTrait([TraitBound { trait_: Path { path: "std::hash::Hash", id: Id(83), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) idSalt) {
        Egui.scroll_area_id_salt(TODO_ARG(idSalt));
    
    }
    
    public ScrollArea ScrollOffset(Vec2 offset) {
        Egui.scroll_area_scroll_offset(TODO_ARG(offset));
    
    }
    
    public ScrollArea VerticalScrollOffset(float offset) {
        Egui.scroll_area_vertical_scroll_offset(TODO_ARG(offset));
    
    }
    
    public ScrollArea HorizontalScrollOffset(float offset) {
        Egui.scroll_area_horizontal_scroll_offset(TODO_ARG(offset));
    
    }
    
    public ScrollArea Hscroll(bool hscroll) {
        Egui.scroll_area_hscroll(TODO_ARG(hscroll));
    
    }
    
    public ScrollArea Vscroll(bool vscroll) {
        Egui.scroll_area_vscroll(TODO_ARG(vscroll));
    
    }
    
    public ScrollArea Scroll(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Vec2b", id: Id(868), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) scrollEnabled) {
        Egui.scroll_area_scroll(TODO_ARG(scrollEnabled));
    
    }
    
    public ScrollArea Scroll2(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Vec2b", id: Id(868), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) scrollEnabled) {
        Egui.scroll_area_scroll2(TODO_ARG(scrollEnabled));
    
    }
    
    public ScrollArea EnableScrolling(bool enable) {
        Egui.scroll_area_enable_scrolling(TODO_ARG(enable));
    
    }
    
    public ScrollArea DragToScroll(bool dragToScroll) {
        Egui.scroll_area_drag_to_scroll(TODO_ARG(dragToScroll));
    
    }
    
    public ScrollArea AutoShrink(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Vec2b", id: Id(868), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) autoShrink) {
        Egui.scroll_area_auto_shrink(TODO_ARG(autoShrink));
    
    }
    
    public ScrollArea Animated(bool animated) {
        Egui.scroll_area_animated(TODO_ARG(animated));
    
    }
    
    public ScrollArea StickToRight(bool stick) {
        Egui.scroll_area_stick_to_right(TODO_ARG(stick));
    
    }
    
    public ScrollArea StickToBottom(bool stick) {
        Egui.scroll_area_stick_to_bottom(TODO_ARG(stick));
    
    }
    
    public ScrollAreaOutput Show(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.scroll_area_show(TODO_ARG(ui), TODO_ARG(addContents));
    
    }
    
    public ScrollAreaOutput ShowRows(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui, float rowHeightSansSpacing, nuint totalRows, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }, ResolvedPath(Path { path: "std::ops::Range", id: Id(1068), args: Some(AngleBracketed { args: [Type(Primitive("usize"))], constraints: [] }) })], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.scroll_area_show_rows(TODO_ARG(ui), TODO_ARG(rowHeightSansSpacing), TODO_ARG(totalRows), TODO_ARG(addContents));
    
    }
    
    public ScrollAreaOutput ShowViewport(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }, ResolvedPath(Path { path: "Rect", id: Id(162), args: Some(AngleBracketed { args: [], constraints: [] }) })], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.scroll_area_show_viewport(TODO_ARG(ui), TODO_ARG(addContents));
    
    }
}

public unsafe partial sealed class ScrollAreaOutput : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_scroll_area_output_drop(pointer);
    }
}

public unsafe partial sealed class ScrollTarget : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_scroll_target_drop(pointer);
    }
}

/// <summary>
/// One out of several alternatives, either selected or not.
/// Will mark selected items with a different background color.
/// An alternative to <c>RadioButton</c> and <c>Checkbox</c>.
/// 
/// Usually you'd use <c>SelectableValue</c> or <c>SelectableLabel</c> instead.
/// </summary>
public unsafe partial sealed class SelectableLabel : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_selectable_label_drop(pointer);
    }
    public SelectableLabel(bool selected, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.selectable_label_new(TODO_ARG(selected), TODO_ARG(text));
    
    }
}

/// <summary>
/// A visual separator. A horizontal or vertical line (depending on <c>Layout</c>).
/// 
/// Usually you'd use the shorter version <c>Separator</c>.
/// </summary>
public unsafe partial sealed class Separator : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_separator_drop(pointer);
    }
    public Separator Spacing(float spacing) {
        Egui.separator_spacing(TODO_ARG(spacing));
    
    }
    
    public Separator Horizontal() {
        Egui.separator_horizontal();
    
    }
    
    public Separator Vertical() {
        Egui.separator_vertical();
    
    }
    
    public Separator Grow(float extra) {
        Egui.separator_grow(TODO_ARG(extra));
    
    }
    
    public Separator Shrink(float shrink) {
        Egui.separator_shrink(TODO_ARG(shrink));
    
    }
}

/// <summary>
/// A panel that covers the entire left or right side of a <c>Ui</c> or screen.
/// 
/// The order in which you add panels matter!
/// The first panel you add will always be the outermost, and the last you add will always be the innermost.
/// 
/// ⚠ Always add any <c>CentralPanel</c> last.
/// 
/// See the module level docs for more details.See also <c>TopBottomPanel</c>.
/// </summary>
public unsafe partial sealed class SidePanel : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_side_panel_drop(pointer);
    }
    public static SidePanel Left(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Id", id: Id(158), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) id) {
        Egui.side_panel_left(TODO_ARG(id));
    
    }
    
    public static SidePanel Right(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Id", id: Id(158), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) id) {
        Egui.side_panel_right(TODO_ARG(id));
    
    }
    
    public SidePanel(Side side, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Id", id: Id(158), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) id) {
        Egui.side_panel_new(TODO_ARG(side), TODO_ARG(id));
    
    }
    
    public SidePanel Resizable(bool resizable) {
        Egui.side_panel_resizable(TODO_ARG(resizable));
    
    }
    
    public SidePanel ShowSeparatorLine(bool showSeparatorLine) {
        Egui.side_panel_show_separator_line(TODO_ARG(showSeparatorLine));
    
    }
    
    public SidePanel DefaultWidth(float defaultWidth) {
        Egui.side_panel_default_width(TODO_ARG(defaultWidth));
    
    }
    
    public SidePanel MinWidth(float minWidth) {
        Egui.side_panel_min_width(TODO_ARG(minWidth));
    
    }
    
    public SidePanel MaxWidth(float maxWidth) {
        Egui.side_panel_max_width(TODO_ARG(maxWidth));
    
    }
    
    public SidePanel WidthRange(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Rangef", id: Id(696), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) widthRange) {
        Egui.side_panel_width_range(TODO_ARG(widthRange));
    
    }
    
    public SidePanel ExactWidth(float width) {
        Egui.side_panel_exact_width(TODO_ARG(width));
    
    }
    
    public SidePanel Frame(Frame frame) {
        Egui.side_panel_frame(TODO_ARG(frame));
    
    }
    
    public InnerResponse ShowInside(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.side_panel_show_inside(TODO_ARG(ui), TODO_ARG(addContents));
    
    }
    
    public InnerResponse Show(Context ctx, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.side_panel_show(TODO_ARG(ctx), TODO_ARG(addContents));
    
    }
    
    public InnerResponse? ShowAnimated(Context ctx, bool isExpanded, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.side_panel_show_animated(TODO_ARG(ctx), TODO_ARG(isExpanded), TODO_ARG(addContents));
    
    }
    
    public InnerResponse? ShowAnimatedInside(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui, bool isExpanded, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.side_panel_show_animated_inside(TODO_ARG(ui), TODO_ARG(isExpanded), TODO_ARG(addContents));
    
    }
    
    public static InnerResponse? ShowAnimatedBetween(Context ctx, bool isExpanded, SidePanel collapsedPanel, SidePanel expandedPanel, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }, Primitive("f32")], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.side_panel_show_animated_between(TODO_ARG(ctx), TODO_ARG(isExpanded), TODO_ARG(collapsedPanel), TODO_ARG(expandedPanel), TODO_ARG(addContents));
    
    }
    
    public static InnerResponse ShowAnimatedBetweenInside(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui, bool isExpanded, SidePanel collapsedPanel, SidePanel expandedPanel, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }, Primitive("f32")], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.side_panel_show_animated_between_inside(TODO_ARG(ui), TODO_ARG(isExpanded), TODO_ARG(collapsedPanel), TODO_ARG(expandedPanel), TODO_ARG(addContents));
    
    }
}

/// <summary>
/// Put some widgets on the left and right sides of a ui.
/// 
/// The result will look like this:The width of the gap is dynamic, based on the max width of the parent <c>Ui</c>.
/// When the parent is being auto-sized (<c>IsSizingPass</c>) the gap will be as small as possible.
/// 
/// If the parent is not wide enough to fit all widgets, the parent will be expanded to the right.
/// 
/// The left widgets are first added to the ui, left-to-right.
/// Then the right widgets are added, right-to-left.
/// </summary>
public unsafe partial sealed class Sides : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_sides_drop(pointer);
    }
    public Sides() {
        Egui.sides_new();
    
    }
    
    public Sides Height(float height) {
        Egui.sides_height(TODO_ARG(height));
    
    }
    
    public Sides Spacing(float spacing) {
        Egui.sides_spacing(TODO_ARG(spacing));
    
    }
    
    public Tuple([Generic("RetL"), Generic("RetR")]) Show(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("RetL")) }) }, generic_params: [], modifier: None }]) addLeft, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("RetR")) }) }, generic_params: [], modifier: None }]) addRight) {
        Egui.sides_show(TODO_ARG(ui), TODO_ARG(addLeft), TODO_ARG(addRight));
    
    }
}

/// <summary>
/// Control a number with a slider.
/// 
/// The slider range defines the values you get when pulling the slider to the far edges.
/// By default all values are clamped to this range, even when not interacted with.
/// You can change this behavior by passing <c>False</c> to <c>ClampToRange</c>.
/// 
/// The range can include any numbers, and go from low-to-high or from high-to-low.
/// 
/// The slider consists of three parts: a slider, a value display, and an optional text.
/// The user can click the value display to edit its value. It can be turned off with <c>.showValue(false)</c>.The default <c>Slider</c> size is set by <c>SliderWidth</c>.
/// </summary>
public unsafe partial sealed class Slider : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_slider_drop(pointer);
    }
    public Slider(BorrowedRef { lifetime: Some("'a"), is_mutable: true, type_: Generic("Num") } value, RangeInclusive range) {
        Egui.slider_new(TODO_ARG(value), TODO_ARG(range));
    
    }
    
    public static Slider FromGetSet(RangeInclusive range, ImplTrait([Outlives("'a"), TraitBound { trait_: Path { path: "FnMut", id: Id(1319), args: Some(Parenthesized { inputs: [ResolvedPath(Path { path: "Option", id: Id(118), args: Some(AngleBracketed { args: [Type(Primitive("f64"))], constraints: [] }) })], output: Some(Primitive("f64")) }) }, generic_params: [], modifier: None }]) getSetValue) {
        Egui.slider_from_get_set(TODO_ARG(range), TODO_ARG(getSetValue));
    
    }
    
    public Slider ShowValue(bool showValue) {
        Egui.slider_show_value(TODO_ARG(showValue));
    
    }
    
    public Slider Prefix(ImplTrait([TraitBound { trait_: Path { path: "ToString", id: Id(1298), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) prefix) {
        Egui.slider_prefix(TODO_ARG(prefix));
    
    }
    
    public Slider Suffix(ImplTrait([TraitBound { trait_: Path { path: "ToString", id: Id(1298), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) suffix) {
        Egui.slider_suffix(TODO_ARG(suffix));
    
    }
    
    public Slider Text(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.slider_text(TODO_ARG(text));
    
    }
    
    public Slider TextColor(Color32 textColor) {
        Egui.slider_text_color(TODO_ARG(textColor));
    
    }
    
    public Slider Orientation(SliderOrientation orientation) {
        Egui.slider_orientation(TODO_ARG(orientation));
    
    }
    
    public Slider Vertical() {
        Egui.slider_vertical();
    
    }
    
    public Slider Logarithmic(bool logarithmic) {
        Egui.slider_logarithmic(TODO_ARG(logarithmic));
    
    }
    
    public Slider SmallestPositive(double smallestPositive) {
        Egui.slider_smallest_positive(TODO_ARG(smallestPositive));
    
    }
    
    public Slider LargestFinite(double largestFinite) {
        Egui.slider_largest_finite(TODO_ARG(largestFinite));
    
    }
    
    public Slider Clamping(SliderClamping clamping) {
        Egui.slider_clamping(TODO_ARG(clamping));
    
    }
    
    public Slider ClampToRange(bool clampToRange) {
        Egui.slider_clamp_to_range(TODO_ARG(clampToRange));
    
    }
    
    public Slider SmartAim(bool smartAim) {
        Egui.slider_smart_aim(TODO_ARG(smartAim));
    
    }
    
    public Slider StepBy(double step) {
        Egui.slider_step_by(TODO_ARG(step));
    
    }
    
    public Slider DragValueSpeed(double dragValueSpeed) {
        Egui.slider_drag_value_speed(TODO_ARG(dragValueSpeed));
    
    }
    
    public Slider MinDecimals(nuint minDecimals) {
        Egui.slider_min_decimals(TODO_ARG(minDecimals));
    
    }
    
    public Slider MaxDecimals(nuint maxDecimals) {
        Egui.slider_max_decimals(TODO_ARG(maxDecimals));
    
    }
    
    public Slider MaxDecimalsOpt(nuint? maxDecimals) {
        Egui.slider_max_decimals_opt(TODO_ARG(maxDecimals));
    
    }
    
    public Slider FixedDecimals(nuint numDecimals) {
        Egui.slider_fixed_decimals(TODO_ARG(numDecimals));
    
    }
    
    public Slider TrailingFill(bool trailingFill) {
        Egui.slider_trailing_fill(TODO_ARG(trailingFill));
    
    }
    
    public Slider HandleShape(HandleShape handleShape) {
        Egui.slider_handle_shape(TODO_ARG(handleShape));
    
    }
    
    public Slider CustomFormatter(ImplTrait([Outlives("'a"), TraitBound { trait_: Path { path: "Fn", id: Id(455), args: Some(Parenthesized { inputs: [Primitive("f64"), ResolvedPath(Path { path: "RangeInclusive", id: Id(2598), args: Some(AngleBracketed { args: [Type(Primitive("usize"))], constraints: [] }) })], output: Some(ResolvedPath(Path { path: "String", id: Id(1295), args: Some(AngleBracketed { args: [], constraints: [] }) })) }) }, generic_params: [], modifier: None }]) formatter) {
        Egui.slider_custom_formatter(TODO_ARG(formatter));
    
    }
    
    public Slider CustomParser(ImplTrait([Outlives("'a"), TraitBound { trait_: Path { path: "Fn", id: Id(455), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: false, type_: Primitive("str") }], output: Some(ResolvedPath(Path { path: "Option", id: Id(118), args: Some(AngleBracketed { args: [Type(Primitive("f64"))], constraints: [] }) })) }) }, generic_params: [], modifier: None }]) parser) {
        Egui.slider_custom_parser(TODO_ARG(parser));
    
    }
    
    public Slider Binary(nuint minWidth, bool twosComplement) {
        Egui.slider_binary(TODO_ARG(minWidth), TODO_ARG(twosComplement));
    
    }
    
    public Slider Octal(nuint minWidth, bool twosComplement) {
        Egui.slider_octal(TODO_ARG(minWidth), TODO_ARG(twosComplement));
    
    }
    
    public Slider Hexadecimal(nuint minWidth, bool twosComplement, bool upper) {
        Egui.slider_hexadecimal(TODO_ARG(minWidth), TODO_ARG(twosComplement), TODO_ARG(upper));
    
    }
    
    public Slider Integer() {
        Egui.slider_integer();
    
    }
}

/// <summary>
/// A spinner widget used to indicate loading.
/// 
/// See also: <c>ProgressBar</c>.
/// </summary>
public unsafe partial sealed class Spinner : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_spinner_drop(pointer);
    }
    public Spinner() {
        Egui.spinner_new();
    
    }
    
    public Spinner Size(float size) {
        Egui.spinner_size(TODO_ARG(size));
    
    }
    
    public Spinner Color(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Color32", id: Id(477), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) color) {
        Egui.spinner_color(TODO_ARG(color));
    
    }
    
    public void PaintAt(Ui ui, Rect rect) {
        Egui.spinner_paint_at(TODO_ARG(ui), TODO_ARG(rect));
    
    }
}

public unsafe partial sealed class State : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_state_drop(pointer);
    }
    public static State? Load(Context ctx, Id id) {
        Egui.state_load(TODO_ARG(ctx), TODO_ARG(id));
    
    }
    
    public void Store(Context ctx, Id id) {
        Egui.state_store(TODO_ARG(ctx), TODO_ARG(id));
    
    }
    
    public Vec2 Velocity() {
        Egui.state_velocity();
    
    }
}

public unsafe partial sealed class SubMenu : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_sub_menu_drop(pointer);
    }
    public InnerResponse Show(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.sub_menu_show(TODO_ARG(ui), TODO_ARG(addContents));
    
    }
}

public unsafe partial sealed class SubMenuButton : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_sub_menu_button_drop(pointer);
    }
    public SubMenuButton Icon(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) icon) {
        Egui.sub_menu_button_icon(TODO_ARG(icon));
    
    }
}

/// <summary>
/// The state of a text cursor selection.
/// 
/// Used for <c>TextEdit</c> and <c>Label</c>.
/// </summary>
public unsafe partial sealed class TextCursorState : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_text_cursor_state_drop(pointer);
    }
    public bool IsEmpty() {
        Egui.text_cursor_state_is_empty();
    
    }
    
    public CCursorRange? CharRange() {
        Egui.text_cursor_state_char_range();
    
    }
    
    public CursorRange? Range(Galley galley) {
        Egui.text_cursor_state_range(TODO_ARG(galley));
    
    }
    
    public void SetCharRange(CCursorRange? ccursorRange) {
        Egui.text_cursor_state_set_char_range(TODO_ARG(ccursorRange));
    
    }
    
    public void SetRange(CursorRange? cursorRange) {
        Egui.text_cursor_state_set_range(TODO_ARG(cursorRange));
    
    }
    
    public bool PointerInteraction(Ui ui, Response response, Cursor cursorAtPointer, Galley galley, bool isBeingDragged) {
        Egui.text_cursor_state_pointer_interaction(TODO_ARG(ui), TODO_ARG(response), TODO_ARG(cursorAtPointer), TODO_ARG(galley), TODO_ARG(isBeingDragged));
    
    }
}

/// <summary>
/// A text region that the user can edit the contents of.
/// 
/// See also <c>TextEditSingleline</c> and <c>TextEditMultiline</c>.
/// 
/// Example:To fill an <c>Ui</c> with a <c>TextEdit</c> use <c>AddSized</c>:You can also use <c>TextEdit</c> to show text that can be selected, but not edited.
/// To do so, pass in a <c>&mut</c> reference to a <c>&str</c>, for instance:## Advanced usage
/// See <c>Show</c>.
/// 
/// ## Other
/// The background color of a <c>TextEdit</c> is <c>ExtremeBgColor</c> or can be set with <c>BackgroundColor</c>.
/// </summary>
public unsafe partial sealed class TextEdit : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_text_edit_drop(pointer);
    }
    public static TextEditState? LoadState(Context ctx, Id id) {
        Egui.text_edit_load_state(TODO_ARG(ctx), TODO_ARG(id));
    
    }
    
    public static void StoreState(Context ctx, Id id, TextEditState state) {
        Egui.text_edit_store_state(TODO_ARG(ctx), TODO_ARG(id), TODO_ARG(state));
    
    }
    
    public static TextEdit Singleline(BorrowedRef { lifetime: Some("'t"), is_mutable: true, type_: DynTrait(DynTrait { traits: [PolyTrait { trait_: Path { path: "TextBuffer", id: Id(5351), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [] }], lifetime: None }) } text) {
        Egui.text_edit_singleline(TODO_ARG(text));
    
    }
    
    public static TextEdit Multiline(BorrowedRef { lifetime: Some("'t"), is_mutable: true, type_: DynTrait(DynTrait { traits: [PolyTrait { trait_: Path { path: "TextBuffer", id: Id(5351), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [] }], lifetime: None }) } text) {
        Egui.text_edit_multiline(TODO_ARG(text));
    
    }
    
    public TextEdit CodeEditor() {
        Egui.text_edit_code_editor();
    
    }
    
    public TextEdit Id(Id id) {
        Egui.text_edit_id(TODO_ARG(id));
    
    }
    
    public TextEdit IdSource(ImplTrait([TraitBound { trait_: Path { path: "std::hash::Hash", id: Id(83), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) idSalt) {
        Egui.text_edit_id_source(TODO_ARG(idSalt));
    
    }
    
    public TextEdit IdSalt(ImplTrait([TraitBound { trait_: Path { path: "std::hash::Hash", id: Id(83), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) idSalt) {
        Egui.text_edit_id_salt(TODO_ARG(idSalt));
    
    }
    
    public TextEdit HintText(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) hintText) {
        Egui.text_edit_hint_text(TODO_ARG(hintText));
    
    }
    
    public TextEdit BackgroundColor(Color32 color) {
        Egui.text_edit_background_color(TODO_ARG(color));
    
    }
    
    public TextEdit HintTextFont(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "FontSelection", id: Id(4433), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) hintTextFont) {
        Egui.text_edit_hint_text_font(TODO_ARG(hintTextFont));
    
    }
    
    public TextEdit Password(bool password) {
        Egui.text_edit_password(TODO_ARG(password));
    
    }
    
    public TextEdit Font(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "FontSelection", id: Id(4433), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) fontSelection) {
        Egui.text_edit_font(TODO_ARG(fontSelection));
    
    }
    
    public TextEdit TextColor(Color32 textColor) {
        Egui.text_edit_text_color(TODO_ARG(textColor));
    
    }
    
    public TextEdit TextColorOpt(Color32? textColor) {
        Egui.text_edit_text_color_opt(TODO_ARG(textColor));
    
    }
    
    public TextEdit Layouter(BorrowedRef { lifetime: Some("'t"), is_mutable: true, type_: DynTrait(DynTrait { traits: [PolyTrait { trait_: Path { path: "FnMut", id: Id(1319), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: false, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }, BorrowedRef { lifetime: None, is_mutable: false, type_: Primitive("str") }, Primitive("f32")], output: Some(ResolvedPath(Path { path: "Arc", id: Id(1246), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Galley", id: Id(4068), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) })) }) }, generic_params: [] }], lifetime: None }) } layouter) {
        Egui.text_edit_layouter(TODO_ARG(layouter));
    
    }
    
    public TextEdit Interactive(bool interactive) {
        Egui.text_edit_interactive(TODO_ARG(interactive));
    
    }
    
    public TextEdit Frame(bool frame) {
        Egui.text_edit_frame(TODO_ARG(frame));
    
    }
    
    public TextEdit Margin(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Margin", id: Id(474), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) margin) {
        Egui.text_edit_margin(TODO_ARG(margin));
    
    }
    
    public TextEdit DesiredWidth(float desiredWidth) {
        Egui.text_edit_desired_width(TODO_ARG(desiredWidth));
    
    }
    
    public TextEdit DesiredRows(nuint desiredHeightRows) {
        Egui.text_edit_desired_rows(TODO_ARG(desiredHeightRows));
    
    }
    
    public TextEdit LockFocus(bool tabWillIndent) {
        Egui.text_edit_lock_focus(TODO_ARG(tabWillIndent));
    
    }
    
    public TextEdit CursorAtEnd(bool b) {
        Egui.text_edit_cursor_at_end(TODO_ARG(b));
    
    }
    
    public TextEdit ClipText(bool b) {
        Egui.text_edit_clip_text(TODO_ARG(b));
    
    }
    
    public TextEdit CharLimit(nuint limit) {
        Egui.text_edit_char_limit(TODO_ARG(limit));
    
    }
    
    public TextEdit HorizontalAlign(Align align) {
        Egui.text_edit_horizontal_align(TODO_ARG(align));
    
    }
    
    public TextEdit VerticalAlign(Align align) {
        Egui.text_edit_vertical_align(TODO_ARG(align));
    
    }
    
    public TextEdit MinSize(Vec2 minSize) {
        Egui.text_edit_min_size(TODO_ARG(minSize));
    
    }
    
    public TextEdit ReturnKey(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Option", id: Id(118), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "KeyboardShortcut", id: Id(1372), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) returnKey) {
        Egui.text_edit_return_key(TODO_ARG(returnKey));
    
    }
    
    public TextEditOutput Show(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui) {
        Egui.text_edit_show(TODO_ARG(ui));
    
    }
}

/// <summary>
/// The output from a <c>TextEdit</c>.
/// </summary>
public unsafe partial sealed class TextEditOutput : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_text_edit_output_drop(pointer);
    }
    public Pos2 TextDrawPos() {
        Egui.text_edit_output_text_draw_pos();
    
    }
}

/// <summary>
/// The text edit state stored between frames.
/// 
/// Attention: You also need to <c>Store</c> the updated state.
/// </summary>
public unsafe partial sealed class TextEditState : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_text_edit_state_drop(pointer);
    }
    public static TextEditState? Load(Context ctx, Id id) {
        Egui.text_edit_state_load(TODO_ARG(ctx), TODO_ARG(id));
    
    }
    
    public void Store(Context ctx, Id id) {
        Egui.text_edit_state_store(TODO_ARG(ctx), TODO_ARG(id));
    
    }
    
    public CCursorRange? CcursorRange() {
        Egui.text_edit_state_ccursor_range();
    
    }
    
    public void SetCcursorRange(CCursorRange? ccursorRange) {
        Egui.text_edit_state_set_ccursor_range(TODO_ARG(ccursorRange));
    
    }
    
    public void SetCursorRange(CursorRange? cursorRange) {
        Egui.text_edit_state_set_cursor_range(TODO_ARG(cursorRange));
    
    }
    
    public crate::util::undoer::Undoer Undoer() {
        Egui.text_edit_state_undoer();
    
    }
    
    public void SetUndoer(crate::util::undoer::Undoer undoer) {
        Egui.text_edit_state_set_undoer(TODO_ARG(undoer));
    
    }
    
    public void ClearUndoer() {
        Egui.text_edit_state_clear_undoer();
    
    }
    
    public CursorRange? CursorRange(Galley galley) {
        Egui.text_edit_state_cursor_range(TODO_ARG(galley));
    
    }
}

/// <summary>
/// Reset at the start of each frame.
/// </summary>
public unsafe partial sealed class TooltipPassState : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_tooltip_pass_state_drop(pointer);
    }
}

/// <summary>
/// A panel that covers the entire top or bottom of a <c>Ui</c> or screen.
/// 
/// The order in which you add panels matter!
/// The first panel you add will always be the outermost, and the last you add will always be the innermost.
/// 
/// ⚠ Always add any <c>CentralPanel</c> last.
/// 
/// See the module level docs for more details.See also <c>SidePanel</c>.
/// </summary>
public unsafe partial sealed class TopBottomPanel : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_top_bottom_panel_drop(pointer);
    }
    public static TopBottomPanel Top(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Id", id: Id(158), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) id) {
        Egui.top_bottom_panel_top(TODO_ARG(id));
    
    }
    
    public static TopBottomPanel Bottom(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Id", id: Id(158), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) id) {
        Egui.top_bottom_panel_bottom(TODO_ARG(id));
    
    }
    
    public TopBottomPanel(TopBottomSide side, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Id", id: Id(158), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) id) {
        Egui.top_bottom_panel_new(TODO_ARG(side), TODO_ARG(id));
    
    }
    
    public TopBottomPanel Resizable(bool resizable) {
        Egui.top_bottom_panel_resizable(TODO_ARG(resizable));
    
    }
    
    public TopBottomPanel ShowSeparatorLine(bool showSeparatorLine) {
        Egui.top_bottom_panel_show_separator_line(TODO_ARG(showSeparatorLine));
    
    }
    
    public TopBottomPanel DefaultHeight(float defaultHeight) {
        Egui.top_bottom_panel_default_height(TODO_ARG(defaultHeight));
    
    }
    
    public TopBottomPanel MinHeight(float minHeight) {
        Egui.top_bottom_panel_min_height(TODO_ARG(minHeight));
    
    }
    
    public TopBottomPanel MaxHeight(float maxHeight) {
        Egui.top_bottom_panel_max_height(TODO_ARG(maxHeight));
    
    }
    
    public TopBottomPanel HeightRange(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Rangef", id: Id(696), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) heightRange) {
        Egui.top_bottom_panel_height_range(TODO_ARG(heightRange));
    
    }
    
    public TopBottomPanel ExactHeight(float height) {
        Egui.top_bottom_panel_exact_height(TODO_ARG(height));
    
    }
    
    public TopBottomPanel Frame(Frame frame) {
        Egui.top_bottom_panel_frame(TODO_ARG(frame));
    
    }
    
    public InnerResponse ShowInside(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.top_bottom_panel_show_inside(TODO_ARG(ui), TODO_ARG(addContents));
    
    }
    
    public InnerResponse Show(Context ctx, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.top_bottom_panel_show(TODO_ARG(ctx), TODO_ARG(addContents));
    
    }
    
    public InnerResponse? ShowAnimated(Context ctx, bool isExpanded, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.top_bottom_panel_show_animated(TODO_ARG(ctx), TODO_ARG(isExpanded), TODO_ARG(addContents));
    
    }
    
    public InnerResponse? ShowAnimatedInside(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui, bool isExpanded, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.top_bottom_panel_show_animated_inside(TODO_ARG(ui), TODO_ARG(isExpanded), TODO_ARG(addContents));
    
    }
    
    public static InnerResponse? ShowAnimatedBetween(Context ctx, bool isExpanded, TopBottomPanel collapsedPanel, TopBottomPanel expandedPanel, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }, Primitive("f32")], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.top_bottom_panel_show_animated_between(TODO_ARG(ctx), TODO_ARG(isExpanded), TODO_ARG(collapsedPanel), TODO_ARG(expandedPanel), TODO_ARG(addContents));
    
    }
    
    public static InnerResponse ShowAnimatedBetweenInside(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui, bool isExpanded, TopBottomPanel collapsedPanel, TopBottomPanel expandedPanel, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }, Primitive("f32")], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.top_bottom_panel_show_animated_between_inside(TODO_ARG(ui), TODO_ARG(isExpanded), TODO_ARG(collapsedPanel), TODO_ARG(expandedPanel), TODO_ARG(addContents));
    
    }
}

/// <summary>
/// This is what you use to place widgets.
/// 
/// Represents a region of the screen with a type of layout (horizontal or vertical).
/// </summary>
public unsafe partial sealed class Ui : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_ui_drop(pointer);
    }
    public Ui(Context ctx, Id id, UiBuilder uiBuilder) {
        Egui.ui_new(TODO_ARG(ctx), TODO_ARG(id), TODO_ARG(uiBuilder));
    
    }
    
    public Ui ChildUi(Rect maxRect, Layout layout, UiStackInfo? uiStackInfo) {
        Egui.ui_child_ui(TODO_ARG(maxRect), TODO_ARG(layout), TODO_ARG(uiStackInfo));
    
    }
    
    public Ui ChildUiWithIdSource(Rect maxRect, Layout layout, ImplTrait([TraitBound { trait_: Path { path: "Hash", id: Id(83), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) idSalt, UiStackInfo? uiStackInfo) {
        Egui.ui_child_ui_with_id_source(TODO_ARG(maxRect), TODO_ARG(layout), TODO_ARG(idSalt), TODO_ARG(uiStackInfo));
    
    }
    
    public Ui NewChild(UiBuilder uiBuilder) {
        Egui.ui_new_child(TODO_ARG(uiBuilder));
    
    }
    
    public void SetSizingPass() {
        Egui.ui_set_sizing_pass();
    
    }
    
    public bool IsSizingPass() {
        Egui.ui_is_sizing_pass();
    
    }
    
    public Id Id() {
        Egui.ui_id();
    
    }
    
    public Id UniqueId() {
        Egui.ui_unique_id();
    
    }
    
    public Arc Style() {
        Egui.ui_style();
    
    }
    
    public BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Style", id: Id(493), args: Some(AngleBracketed { args: [], constraints: [] }) }) } StyleMut() {
        Egui.ui_style_mut();
    
    }
    
    public void SetStyle(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Arc", id: Id(1246), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Style", id: Id(493), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) style) {
        Egui.ui_set_style(TODO_ARG(style));
    
    }
    
    public void ResetStyle() {
        Egui.ui_reset_style();
    
    }
    
    public Spacing Spacing() {
        Egui.ui_spacing();
    
    }
    
    public BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "crate::style::Spacing", id: Id(4468), args: Some(AngleBracketed { args: [], constraints: [] }) }) } SpacingMut() {
        Egui.ui_spacing_mut();
    
    }
    
    public Visuals Visuals() {
        Egui.ui_visuals();
    
    }
    
    public BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "crate::Visuals", id: Id(1408), args: Some(AngleBracketed { args: [], constraints: [] }) }) } VisualsMut() {
        Egui.ui_visuals_mut();
    
    }
    
    public Arc Stack() {
        Egui.ui_stack();
    
    }
    
    public Context Ctx() {
        Egui.ui_ctx();
    
    }
    
    public Painter Painter() {
        Egui.ui_painter();
    
    }
    
    public float PixelsPerPoint() {
        Egui.ui_pixels_per_point();
    
    }
    
    public bool IsEnabled() {
        Egui.ui_is_enabled();
    
    }
    
    public void Disable() {
        Egui.ui_disable();
    
    }
    
    public void SetEnabled(bool enabled) {
        Egui.ui_set_enabled(TODO_ARG(enabled));
    
    }
    
    public bool IsVisible() {
        Egui.ui_is_visible();
    
    }
    
    public void SetInvisible() {
        Egui.ui_set_invisible();
    
    }
    
    public void SetVisible(bool visible) {
        Egui.ui_set_visible(TODO_ARG(visible));
    
    }
    
    public void SetOpacity(float opacity) {
        Egui.ui_set_opacity(TODO_ARG(opacity));
    
    }
    
    public void MultiplyOpacity(float opacity) {
        Egui.ui_multiply_opacity(TODO_ARG(opacity));
    
    }
    
    public float Opacity() {
        Egui.ui_opacity();
    
    }
    
    public Layout Layout() {
        Egui.ui_layout();
    
    }
    
    public TextWrapMode WrapMode() {
        Egui.ui_wrap_mode();
    
    }
    
    public bool WrapText() {
        Egui.ui_wrap_text();
    
    }
    
    public Align TextValign() {
        Egui.ui_text_valign();
    
    }
    
    public Painter PainterAt(Rect rect) {
        Egui.ui_painter_at(TODO_ARG(rect));
    
    }
    
    public LayerId LayerId() {
        Egui.ui_layer_id();
    
    }
    
    public float TextStyleHeight(TextStyle style) {
        Egui.ui_text_style_height(TODO_ARG(style));
    
    }
    
    public Rect ClipRect() {
        Egui.ui_clip_rect();
    
    }
    
    public void ShrinkClipRect(Rect newClipRect) {
        Egui.ui_shrink_clip_rect(TODO_ARG(newClipRect));
    
    }
    
    public void SetClipRect(Rect clipRect) {
        Egui.ui_set_clip_rect(TODO_ARG(clipRect));
    
    }
    
    public bool IsRectVisible(Rect rect) {
        Egui.ui_is_rect_visible(TODO_ARG(rect));
    
    }
    
    public Generic("R") Input(ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: false, type_: ResolvedPath(Path { path: "InputState", id: Id(1249), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) reader) {
        Egui.ui_input(TODO_ARG(reader));
    
    }
    
    public Generic("R") InputMut(ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "InputState", id: Id(1249), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) writer) {
        Egui.ui_input_mut(TODO_ARG(writer));
    
    }
    
    public Generic("R") Memory(ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: false, type_: ResolvedPath(Path { path: "Memory", id: Id(1312), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) reader) {
        Egui.ui_memory(TODO_ARG(reader));
    
    }
    
    public Generic("R") MemoryMut(ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Memory", id: Id(1312), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) writer) {
        Egui.ui_memory_mut(TODO_ARG(writer));
    
    }
    
    public Generic("R") Data(ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: false, type_: ResolvedPath(Path { path: "IdTypeMap", id: Id(1328), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) reader) {
        Egui.ui_data(TODO_ARG(reader));
    
    }
    
    public Generic("R") DataMut(ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "IdTypeMap", id: Id(1328), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) writer) {
        Egui.ui_data_mut(TODO_ARG(writer));
    
    }
    
    public Generic("R") Output(ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: false, type_: ResolvedPath(Path { path: "PlatformOutput", id: Id(1262), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) reader) {
        Egui.ui_output(TODO_ARG(reader));
    
    }
    
    public Generic("R") OutputMut(ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "PlatformOutput", id: Id(1262), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) writer) {
        Egui.ui_output_mut(TODO_ARG(writer));
    
    }
    
    public Generic("R") Fonts(ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: false, type_: ResolvedPath(Path { path: "Fonts", id: Id(1335), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) reader) {
        Egui.ui_fonts(TODO_ARG(reader));
    
    }
    
    public Rect MinRect() {
        Egui.ui_min_rect();
    
    }
    
    public Vec2 MinSize() {
        Egui.ui_min_size();
    
    }
    
    public Rect MaxRect() {
        Egui.ui_max_rect();
    
    }
    
    public void SetMaxSize(Vec2 size) {
        Egui.ui_set_max_size(TODO_ARG(size));
    
    }
    
    public void SetMaxWidth(float width) {
        Egui.ui_set_max_width(TODO_ARG(width));
    
    }
    
    public void SetMaxHeight(float height) {
        Egui.ui_set_max_height(TODO_ARG(height));
    
    }
    
    public void SetMinSize(Vec2 size) {
        Egui.ui_set_min_size(TODO_ARG(size));
    
    }
    
    public void SetMinWidth(float width) {
        Egui.ui_set_min_width(TODO_ARG(width));
    
    }
    
    public void SetMinHeight(float height) {
        Egui.ui_set_min_height(TODO_ARG(height));
    
    }
    
    public void ShrinkWidthToCurrent() {
        Egui.ui_shrink_width_to_current();
    
    }
    
    public void ShrinkHeightToCurrent() {
        Egui.ui_shrink_height_to_current();
    
    }
    
    public void ExpandToIncludeRect(Rect rect) {
        Egui.ui_expand_to_include_rect(TODO_ARG(rect));
    
    }
    
    public void SetWidthRange(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Rangef", id: Id(696), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) width) {
        Egui.ui_set_width_range(TODO_ARG(width));
    
    }
    
    public void SetHeightRange(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Rangef", id: Id(696), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) height) {
        Egui.ui_set_height_range(TODO_ARG(height));
    
    }
    
    public void SetWidth(float width) {
        Egui.ui_set_width(TODO_ARG(width));
    
    }
    
    public void SetHeight(float height) {
        Egui.ui_set_height(TODO_ARG(height));
    
    }
    
    public void ExpandToIncludeX(float x) {
        Egui.ui_expand_to_include_x(TODO_ARG(x));
    
    }
    
    public void ExpandToIncludeY(float y) {
        Egui.ui_expand_to_include_y(TODO_ARG(y));
    
    }
    
    public Vec2 AvailableSize() {
        Egui.ui_available_size();
    
    }
    
    public float AvailableWidth() {
        Egui.ui_available_width();
    
    }
    
    public float AvailableHeight() {
        Egui.ui_available_height();
    
    }
    
    public Vec2 AvailableSizeBeforeWrap() {
        Egui.ui_available_size_before_wrap();
    
    }
    
    public Rect AvailableRectBeforeWrap() {
        Egui.ui_available_rect_before_wrap();
    
    }
    
    public Id MakePersistentId(Generic("IdSource") idSalt) {
        Egui.ui_make_persistent_id(TODO_ARG(idSalt));
    
    }
    
    public Id NextAutoId() {
        Egui.ui_next_auto_id();
    
    }
    
    public Id AutoIdWith(Generic("IdSource") idSalt) {
        Egui.ui_auto_id_with(TODO_ARG(idSalt));
    
    }
    
    public void SkipAheadAutoIds(nuint count) {
        Egui.ui_skip_ahead_auto_ids(TODO_ARG(count));
    
    }
    
    public Response Interact(Rect rect, Id id, Sense sense) {
        Egui.ui_interact(TODO_ARG(rect), TODO_ARG(id), TODO_ARG(sense));
    
    }
    
    public Response InteractWithHovered(Rect rect, bool containsPointer, Id id, Sense sense) {
        Egui.ui_interact_with_hovered(TODO_ARG(rect), TODO_ARG(containsPointer), TODO_ARG(id), TODO_ARG(sense));
    
    }
    
    public Response Response() {
        Egui.ui_response();
    
    }
    
    public Response InteractBg(Sense sense) {
        Egui.ui_interact_bg(TODO_ARG(sense));
    
    }
    
    public bool RectContainsPointer(Rect rect) {
        Egui.ui_rect_contains_pointer(TODO_ARG(rect));
    
    }
    
    public bool UiContainsPointer() {
        Egui.ui_ui_contains_pointer();
    
    }
    
    public Response AllocateResponse(Vec2 desiredSize, Sense sense) {
        Egui.ui_allocate_response(TODO_ARG(desiredSize), TODO_ARG(sense));
    
    }
    
    public Tuple([ResolvedPath(Path { path: "Rect", id: Id(162), args: Some(AngleBracketed { args: [], constraints: [] }) }), ResolvedPath(Path { path: "Response", id: Id(282), args: Some(AngleBracketed { args: [], constraints: [] }) })]) AllocateExactSize(Vec2 desiredSize, Sense sense) {
        Egui.ui_allocate_exact_size(TODO_ARG(desiredSize), TODO_ARG(sense));
    
    }
    
    public Tuple([ResolvedPath(Path { path: "Rect", id: Id(162), args: Some(AngleBracketed { args: [], constraints: [] }) }), ResolvedPath(Path { path: "Response", id: Id(282), args: Some(AngleBracketed { args: [], constraints: [] }) })]) AllocateAtLeast(Vec2 desiredSize, Sense sense) {
        Egui.ui_allocate_at_least(TODO_ARG(desiredSize), TODO_ARG(sense));
    
    }
    
    public Tuple([ResolvedPath(Path { path: "Id", id: Id(158), args: Some(AngleBracketed { args: [], constraints: [] }) }), ResolvedPath(Path { path: "Rect", id: Id(162), args: Some(AngleBracketed { args: [], constraints: [] }) })]) AllocateSpace(Vec2 desiredSize) {
        Egui.ui_allocate_space(TODO_ARG(desiredSize));
    
    }
    
    public Response AllocateRect(Rect rect, Sense sense) {
        Egui.ui_allocate_rect(TODO_ARG(rect), TODO_ARG(sense));
    
    }
    
    public Id AdvanceCursorAfterRect(Rect rect) {
        Egui.ui_advance_cursor_after_rect(TODO_ARG(rect));
    
    }
    
    public Rect Cursor() {
        Egui.ui_cursor();
    
    }
    
    public Pos2 NextWidgetPosition() {
        Egui.ui_next_widget_position();
    
    }
    
    public InnerResponse AllocateUi(Vec2 desiredSize, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: Generic("Self") }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_allocate_ui(TODO_ARG(desiredSize), TODO_ARG(addContents));
    
    }
    
    public InnerResponse AllocateUiWithLayout(Vec2 desiredSize, Layout layout, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: Generic("Self") }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_allocate_ui_with_layout(TODO_ARG(desiredSize), TODO_ARG(layout), TODO_ARG(addContents));
    
    }
    
    public InnerResponse AllocateUiAtRect(Rect maxRect, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: Generic("Self") }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_allocate_ui_at_rect(TODO_ARG(maxRect), TODO_ARG(addContents));
    
    }
    
    public InnerResponse AllocateNewUi(UiBuilder uiBuilder, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: Generic("Self") }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_allocate_new_ui(TODO_ARG(uiBuilder), TODO_ARG(addContents));
    
    }
    
    public Tuple([ResolvedPath(Path { path: "Response", id: Id(282), args: Some(AngleBracketed { args: [], constraints: [] }) }), ResolvedPath(Path { path: "Painter", id: Id(1353), args: Some(AngleBracketed { args: [], constraints: [] }) })]) AllocatePainter(Vec2 desiredSize, Sense sense) {
        Egui.ui_allocate_painter(TODO_ARG(desiredSize), TODO_ARG(sense));
    
    }
    
    public void ScrollToRect(Rect rect, Align? align) {
        Egui.ui_scroll_to_rect(TODO_ARG(rect), TODO_ARG(align));
    
    }
    
    public void ScrollToRectAnimation(Rect rect, Align? align, ScrollAnimation animation) {
        Egui.ui_scroll_to_rect_animation(TODO_ARG(rect), TODO_ARG(align), TODO_ARG(animation));
    
    }
    
    public void ScrollToCursor(Align? align) {
        Egui.ui_scroll_to_cursor(TODO_ARG(align));
    
    }
    
    public void ScrollToCursorAnimation(Align? align, ScrollAnimation animation) {
        Egui.ui_scroll_to_cursor_animation(TODO_ARG(align), TODO_ARG(animation));
    
    }
    
    public void ScrollWithDelta(Vec2 delta) {
        Egui.ui_scroll_with_delta(TODO_ARG(delta));
    
    }
    
    public void ScrollWithDeltaAnimation(Vec2 delta, ScrollAnimation animation) {
        Egui.ui_scroll_with_delta_animation(TODO_ARG(delta), TODO_ARG(animation));
    
    }
    
    public Response Add(ImplTrait([TraitBound { trait_: Path { path: "Widget", id: Id(550), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) widget) {
        Egui.ui_add(TODO_ARG(widget));
    
    }
    
    public Response AddSized(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Vec2", id: Id(150), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) maxSize, ImplTrait([TraitBound { trait_: Path { path: "Widget", id: Id(550), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) widget) {
        Egui.ui_add_sized(TODO_ARG(maxSize), TODO_ARG(widget));
    
    }
    
    public Response Put(Rect maxRect, ImplTrait([TraitBound { trait_: Path { path: "Widget", id: Id(550), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) widget) {
        Egui.ui_put(TODO_ARG(maxRect), TODO_ARG(widget));
    
    }
    
    public Response AddEnabled(bool enabled, ImplTrait([TraitBound { trait_: Path { path: "Widget", id: Id(550), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) widget) {
        Egui.ui_add_enabled(TODO_ARG(enabled), TODO_ARG(widget));
    
    }
    
    public InnerResponse AddEnabledUi(bool enabled, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_add_enabled_ui(TODO_ARG(enabled), TODO_ARG(addContents));
    
    }
    
    public Response AddVisible(bool visible, ImplTrait([TraitBound { trait_: Path { path: "Widget", id: Id(550), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) widget) {
        Egui.ui_add_visible(TODO_ARG(visible), TODO_ARG(widget));
    
    }
    
    public InnerResponse AddVisibleUi(bool visible, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_add_visible_ui(TODO_ARG(visible), TODO_ARG(addContents));
    
    }
    
    public void AddSpace(float amount) {
        Egui.ui_add_space(TODO_ARG(amount));
    
    }
    
    public Response Label(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.ui_label(TODO_ARG(text));
    
    }
    
    public Response ColoredLabel(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Color32", id: Id(477), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) color, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "RichText", id: Id(5339), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.ui_colored_label(TODO_ARG(color), TODO_ARG(text));
    
    }
    
    public Response Heading(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "RichText", id: Id(5339), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.ui_heading(TODO_ARG(text));
    
    }
    
    public Response Monospace(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "RichText", id: Id(5339), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.ui_monospace(TODO_ARG(text));
    
    }
    
    public Response Code(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "RichText", id: Id(5339), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.ui_code(TODO_ARG(text));
    
    }
    
    public Response Small(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "RichText", id: Id(5339), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.ui_small(TODO_ARG(text));
    
    }
    
    public Response Strong(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "RichText", id: Id(5339), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.ui_strong(TODO_ARG(text));
    
    }
    
    public Response Weak(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "RichText", id: Id(5339), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.ui_weak(TODO_ARG(text));
    
    }
    
    public Response Link(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.ui_link(TODO_ARG(text));
    
    }
    
    public Response Hyperlink(ImplTrait([TraitBound { trait_: Path { path: "ToString", id: Id(1298), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) url) {
        Egui.ui_hyperlink(TODO_ARG(url));
    
    }
    
    public Response HyperlinkTo(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) label, ImplTrait([TraitBound { trait_: Path { path: "ToString", id: Id(1298), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) url) {
        Egui.ui_hyperlink_to(TODO_ARG(label), TODO_ARG(url));
    
    }
    
    public Response TextEditSingleline(BorrowedRef { lifetime: None, is_mutable: true, type_: Generic("S") } text) {
        Egui.ui_text_edit_singleline(TODO_ARG(text));
    
    }
    
    public Response TextEditMultiline(BorrowedRef { lifetime: None, is_mutable: true, type_: Generic("S") } text) {
        Egui.ui_text_edit_multiline(TODO_ARG(text));
    
    }
    
    public Response CodeEditor(BorrowedRef { lifetime: None, is_mutable: true, type_: Generic("S") } text) {
        Egui.ui_code_editor(TODO_ARG(text));
    
    }
    
    public Response Button(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.ui_button(TODO_ARG(text));
    
    }
    
    public Response SmallButton(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.ui_small_button(TODO_ARG(text));
    
    }
    
    public Response Checkbox(BorrowedRef { lifetime: None, is_mutable: true, type_: Primitive("bool") } checked, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.ui_checkbox(TODO_ARG(checked), TODO_ARG(text));
    
    }
    
    public Response ToggleValue(BorrowedRef { lifetime: None, is_mutable: true, type_: Primitive("bool") } selected, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.ui_toggle_value(TODO_ARG(selected), TODO_ARG(text));
    
    }
    
    public Response Radio(bool selected, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.ui_radio(TODO_ARG(selected), TODO_ARG(text));
    
    }
    
    public Response RadioValue(BorrowedRef { lifetime: None, is_mutable: true, type_: Generic("Value") } currentValue, Generic("Value") alternative, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.ui_radio_value(TODO_ARG(currentValue), TODO_ARG(alternative), TODO_ARG(text));
    
    }
    
    public Response SelectableLabel(bool checked, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.ui_selectable_label(TODO_ARG(checked), TODO_ARG(text));
    
    }
    
    public Response SelectableValue(BorrowedRef { lifetime: None, is_mutable: true, type_: Generic("Value") } currentValue, Generic("Value") selectedValue, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) text) {
        Egui.ui_selectable_value(TODO_ARG(currentValue), TODO_ARG(selectedValue), TODO_ARG(text));
    
    }
    
    public Response Separator() {
        Egui.ui_separator();
    
    }
    
    public Response Spinner() {
        Egui.ui_spinner();
    
    }
    
    public Response DragAngle(BorrowedRef { lifetime: None, is_mutable: true, type_: Primitive("f32") } radians) {
        Egui.ui_drag_angle(TODO_ARG(radians));
    
    }
    
    public Response DragAngleTau(BorrowedRef { lifetime: None, is_mutable: true, type_: Primitive("f32") } radians) {
        Egui.ui_drag_angle_tau(TODO_ARG(radians));
    
    }
    
    public Response Image(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "ImageSource", id: Id(3592), args: Some(AngleBracketed { args: [Lifetime("'a")], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) source) {
        Egui.ui_image(TODO_ARG(source));
    
    }
    
    public Response ColorEditButtonSrgba(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Color32", id: Id(477), args: Some(AngleBracketed { args: [], constraints: [] }) }) } srgba) {
        Egui.ui_color_edit_button_srgba(TODO_ARG(srgba));
    
    }
    
    public Response ColorEditButtonHsva(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Hsva", id: Id(5374), args: Some(AngleBracketed { args: [], constraints: [] }) }) } hsva) {
        Egui.ui_color_edit_button_hsva(TODO_ARG(hsva));
    
    }
    
    public Response ColorEditButtonSrgb(BorrowedRef { lifetime: None, is_mutable: true, type_: Array { type_: Primitive("u8"), len: "3" } } srgb) {
        Egui.ui_color_edit_button_srgb(TODO_ARG(srgb));
    
    }
    
    public Response ColorEditButtonRgb(BorrowedRef { lifetime: None, is_mutable: true, type_: Array { type_: Primitive("f32"), len: "3" } } rgb) {
        Egui.ui_color_edit_button_rgb(TODO_ARG(rgb));
    
    }
    
    public Response ColorEditButtonSrgbaPremultiplied(BorrowedRef { lifetime: None, is_mutable: true, type_: Array { type_: Primitive("u8"), len: "4" } } srgba) {
        Egui.ui_color_edit_button_srgba_premultiplied(TODO_ARG(srgba));
    
    }
    
    public Response ColorEditButtonSrgbaUnmultiplied(BorrowedRef { lifetime: None, is_mutable: true, type_: Array { type_: Primitive("u8"), len: "4" } } srgba) {
        Egui.ui_color_edit_button_srgba_unmultiplied(TODO_ARG(srgba));
    
    }
    
    public Response ColorEditButtonRgbaPremultiplied(BorrowedRef { lifetime: None, is_mutable: true, type_: Array { type_: Primitive("f32"), len: "4" } } rgbaPremul) {
        Egui.ui_color_edit_button_rgba_premultiplied(TODO_ARG(rgbaPremul));
    
    }
    
    public Response ColorEditButtonRgbaUnmultiplied(BorrowedRef { lifetime: None, is_mutable: true, type_: Array { type_: Primitive("f32"), len: "4" } } rgbaUnmul) {
        Egui.ui_color_edit_button_rgba_unmultiplied(TODO_ARG(rgbaUnmul));
    
    }
    
    public InnerResponse Group(ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_group(TODO_ARG(addContents));
    
    }
    
    public InnerResponse PushId(ImplTrait([TraitBound { trait_: Path { path: "Hash", id: Id(83), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) idSalt, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_push_id(TODO_ARG(idSalt), TODO_ARG(addContents));
    
    }
    
    public InnerResponse PushStackInfo(UiStackInfo uiStackInfo, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_push_stack_info(TODO_ARG(uiStackInfo), TODO_ARG(addContents));
    
    }
    
    public InnerResponse Scope(ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_scope(TODO_ARG(addContents));
    
    }
    
    public InnerResponse ScopeBuilder(UiBuilder uiBuilder, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_scope_builder(TODO_ARG(uiBuilder), TODO_ARG(addContents));
    
    }
    
    public InnerResponse ScopeDyn(UiBuilder uiBuilder, Box addContents) {
        Egui.ui_scope_dyn(TODO_ARG(uiBuilder), TODO_ARG(addContents));
    
    }
    
    public InnerResponse WithLayerId(LayerId layerId, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: Generic("Self") }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_with_layer_id(TODO_ARG(layerId), TODO_ARG(addContents));
    
    }
    
    public CollapsingResponse Collapsing(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) heading, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_collapsing(TODO_ARG(heading), TODO_ARG(addContents));
    
    }
    
    public InnerResponse Indent(ImplTrait([TraitBound { trait_: Path { path: "Hash", id: Id(83), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) idSalt, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_indent(TODO_ARG(idSalt), TODO_ARG(addContents));
    
    }
    
    public InnerResponse Horizontal(ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_horizontal(TODO_ARG(addContents));
    
    }
    
    public InnerResponse HorizontalCentered(ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_horizontal_centered(TODO_ARG(addContents));
    
    }
    
    public InnerResponse HorizontalTop(ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_horizontal_top(TODO_ARG(addContents));
    
    }
    
    public InnerResponse HorizontalWrapped(ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_horizontal_wrapped(TODO_ARG(addContents));
    
    }
    
    public InnerResponse Vertical(ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_vertical(TODO_ARG(addContents));
    
    }
    
    public InnerResponse VerticalCentered(ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_vertical_centered(TODO_ARG(addContents));
    
    }
    
    public InnerResponse VerticalCenteredJustified(ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_vertical_centered_justified(TODO_ARG(addContents));
    
    }
    
    public InnerResponse WithLayout(Layout layout, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: Generic("Self") }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_with_layout(TODO_ARG(layout), TODO_ARG(addContents));
    
    }
    
    public InnerResponse CenteredAndJustified(ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: Generic("Self") }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_centered_and_justified(TODO_ARG(addContents));
    
    }
    
    public void EndRow() {
        Egui.ui_end_row();
    
    }
    
    public void SetRowHeight(float height) {
        Egui.ui_set_row_height(TODO_ARG(height));
    
    }
    
    public Generic("R") Columns(nuint numColumns, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: Slice(Generic("Self")) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_columns(TODO_ARG(numColumns), TODO_ARG(addContents));
    
    }
    
    public Generic("R") ColumnsConst(ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: Array { type_: Generic("Self"), len: "NUM_COL" } }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_columns_const(TODO_ARG(addContents));
    
    }
    
    public InnerResponse DndDragSource(Id id, Generic("Payload") payload, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: Generic("Self") }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_dnd_drag_source(TODO_ARG(id), TODO_ARG(payload), TODO_ARG(addContents));
    
    }
    
    public Tuple([ResolvedPath(Path { path: "InnerResponse", id: Id(239), args: Some(AngleBracketed { args: [Type(Generic("R"))], constraints: [] }) }), ResolvedPath(Path { path: "Option", id: Id(118), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Arc", id: Id(1246), args: Some(AngleBracketed { args: [Type(Generic("Payload"))], constraints: [] }) }))], constraints: [] }) })]) DndDropZone(Frame frame, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_dnd_drop_zone(TODO_ARG(frame), TODO_ARG(addContents));
    
    }
    
    public InnerResponse WithVisualTransform(emath::TSTransform transform, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: Generic("Self") }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_with_visual_transform(TODO_ARG(transform), TODO_ARG(addContents));
    
    }
    
    public void CloseMenu() {
        Egui.ui_close_menu();
    
    }
    
    public InnerResponse MenuButton(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) title, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_menu_button(TODO_ARG(title), TODO_ARG(addContents));
    
    }
    
    public InnerResponse MenuImageButton(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Image", id: Id(1424), args: Some(AngleBracketed { args: [Lifetime("'a")], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) image, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_menu_image_button(TODO_ARG(image), TODO_ARG(addContents));
    
    }
    
    public InnerResponse MenuImageTextButton(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Image", id: Id(1424), args: Some(AngleBracketed { args: [Lifetime("'a")], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) image, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) title, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.ui_menu_image_text_button(TODO_ARG(image), TODO_ARG(title), TODO_ARG(addContents));
    
    }
    
    public void DebugPaintCursor() {
        Egui.ui_debug_paint_cursor();
    
    }
}

/// <summary>
/// Information about a <c>Ui</c> and its parents.
/// 
/// <c>UiStack</c> serves to keep track of the current hierarchy of <c>Ui</c>s, such
/// that nested widgets or user code may adapt to the surrounding context or obtain layout information
/// from a <c>Ui</c> that might be several steps higher in the hierarchy.
/// 
/// Note: since <c>UiStack</c> contains a reference to its parent, it is both a stack, and a node within
/// that stack. Most of its methods are about the specific node, but some methods walk up the
/// hierarchy to provide information about the entire stack.
/// </summary>
public unsafe partial sealed class UiStack : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_ui_stack_drop(pointer);
    }
    public UiKind? Kind() {
        Egui.ui_stack_kind();
    
    }
    
    public Frame Frame() {
        Egui.ui_stack_frame();
    
    }
    
    public UiTags Tags() {
        Egui.ui_stack_tags();
    
    }
    
    public bool IsPanelUi() {
        Egui.ui_stack_is_panel_ui();
    
    }
    
    public bool IsAreaUi() {
        Egui.ui_stack_is_area_ui();
    
    }
    
    public bool IsRootUi() {
        Egui.ui_stack_is_root_ui();
    
    }
    
    public bool HasVisibleFrame() {
        Egui.ui_stack_has_visible_frame();
    
    }
    
    public UiStackIterator Iter() {
        Egui.ui_stack_iter();
    
    }
    
    public bool ContainedIn(UiKind kind) {
        Egui.ui_stack_contained_in(TODO_ARG(kind));
    
    }
}

/// <summary>
/// Iterator that walks up a stack of <c>StackFrame</c>s.
/// 
/// See <c>Iter</c>.
/// </summary>
public unsafe partial sealed class UiStackIterator : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_ui_stack_iterator_drop(pointer);
    }
}

/// <summary>
/// Automatic undo system.
/// 
/// Every frame you feed it the most recent state.
/// The <c>Undoer</c> compares it with the latest undo point
/// and if there is a change it may create a new undo point.
/// 
/// <c>Undoer</c> follows two simple rules:
/// 
/// 1) If the state has changed since the latest undo point, but has
///    remained stable for <c>StableTime</c> seconds, an new undo point is created.
/// 2) If the state does not stabilize within <c>AutoSaveInterval</c> seconds, an undo point is created.
/// 
/// Rule 1) will make sure an undo point is not created until you _stop_ dragging that slider.
/// Rule 2) will make sure that you will get some undo points even if you are constantly changing the state.
/// </summary>
public unsafe partial sealed class Undoer : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_undoer_drop(pointer);
    }
    public static Undoer WithSettings(Settings settings) {
        Egui.undoer_with_settings(TODO_ARG(settings));
    
    }
    
    public bool HasUndo(Generic("State") currentState) {
        Egui.undoer_has_undo(TODO_ARG(currentState));
    
    }
    
    public bool HasRedo(Generic("State") currentState) {
        Egui.undoer_has_redo(TODO_ARG(currentState));
    
    }
    
    public bool IsInFlux() {
        Egui.undoer_is_in_flux();
    
    }
    
    public Generic("State")? Undo(Generic("State") currentState) {
        Egui.undoer_undo(TODO_ARG(currentState));
    
    }
    
    public Generic("State")? Redo(Generic("State") currentState) {
        Egui.undoer_redo(TODO_ARG(currentState));
    
    }
    
    public void AddUndo(Generic("State") currentState) {
        Egui.undoer_add_undo(TODO_ARG(currentState));
    
    }
    
    public void FeedState(double currentTime, Generic("State") currentState) {
        Egui.undoer_feed_state(TODO_ARG(currentTime), TODO_ARG(currentState));
    
    }
}

/// <summary>
/// State stored per viewport.
/// 
/// Mostly for internal use.
/// Things here may move and change without warning.
/// </summary>
public unsafe partial sealed class ViewportState : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_viewport_state_drop(pointer);
    }
}

/// <summary>
/// Result of a hit-test against <c>WidgetRects</c>.
/// 
/// Answers the question "what is under the mouse pointer?".
/// 
/// Note that this doesn't care if the mouse button is pressed or not,
/// or if we're currently already dragging something.
/// </summary>
public unsafe partial sealed class WidgetHits : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_widget_hits_drop(pointer);
    }
}

/// <summary>
/// Stores the <c>WidgetRect</c>s of all widgets generated during a single egui update/frame.
/// 
/// All <c>Ui</c>s have a <c>WidgetRect</c>. It is created in <c>New</c> with <c>Nothing</c>
/// and updated with the correct <c>Rect</c> when the <c>Ui</c> is dropped.
/// </summary>
public unsafe partial sealed class WidgetRects : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_widget_rects_drop(pointer);
    }
    public ImplTrait([TraitBound { trait_: Path { path: "ExactSizeIterator", id: Id(3114), args: Some(AngleBracketed { args: [], constraints: [AssocItemConstraint { name: "Item", args: AngleBracketed { args: [], constraints: [] }, binding: Equality(Type(ResolvedPath(Path { path: "LayerId", id: Id(209), args: Some(AngleBracketed { args: [], constraints: [] }) }))) }] }) }, generic_params: [], modifier: None }, Outlives("'_")]) LayerIds() {
        Egui.widget_rects_layer_ids();
    
    }
    
    public ImplTrait([TraitBound { trait_: Path { path: "Iterator", id: Id(5613), args: Some(AngleBracketed { args: [], constraints: [AssocItemConstraint { name: "Item", args: AngleBracketed { args: [], constraints: [] }, binding: Equality(Type(Tuple([BorrowedRef { lifetime: None, is_mutable: false, type_: ResolvedPath(Path { path: "LayerId", id: Id(209), args: Some(AngleBracketed { args: [], constraints: [] }) }) }, BorrowedRef { lifetime: None, is_mutable: false, type_: Slice(ResolvedPath(Path { path: "WidgetRect", id: Id(2750), args: Some(AngleBracketed { args: [], constraints: [] }) })) }]))) }] }) }, generic_params: [], modifier: None }, Outlives("'_")]) Layers() {
        Egui.widget_rects_layers();
    
    }
    
    public WidgetRect? Get(Id id) {
        Egui.widget_rects_get(TODO_ARG(id));
    
    }
    
    public Tuple([ResolvedPath(Path { path: "LayerId", id: Id(209), args: Some(AngleBracketed { args: [], constraints: [] }) }), Primitive("usize")])? Order(Id id) {
        Egui.widget_rects_order(TODO_ARG(id));
    
    }
    
    public bool Contains(Id id) {
        Egui.widget_rects_contains(TODO_ARG(id));
    
    }
    
    public ImplTrait([TraitBound { trait_: Path { path: "Iterator", id: Id(5613), args: Some(AngleBracketed { args: [], constraints: [AssocItemConstraint { name: "Item", args: AngleBracketed { args: [], constraints: [] }, binding: Equality(Type(BorrowedRef { lifetime: None, is_mutable: false, type_: ResolvedPath(Path { path: "WidgetRect", id: Id(2750), args: Some(AngleBracketed { args: [], constraints: [] }) }) })) }] }) }, generic_params: [], modifier: None }, Outlives("'_")]) GetLayer(LayerId layerId) {
        Egui.widget_rects_get_layer(TODO_ARG(layerId));
    
    }
    
    public void Clear() {
        Egui.widget_rects_clear();
    
    }
    
    public void Insert(LayerId layerId, WidgetRect widgetRect) {
        Egui.widget_rects_insert(TODO_ARG(layerId), TODO_ARG(widgetRect));
    
    }
    
    public void SetInfo(Id id, WidgetInfo info) {
        Egui.widget_rects_set_info(TODO_ARG(id), TODO_ARG(info));
    
    }
    
    public WidgetInfo? Info(Id id) {
        Egui.widget_rects_info(TODO_ARG(id));
    
    }
}

/// <summary>
/// Builder for a floating window which can be dragged, closed, collapsed, resized and scrolled (off by default).
/// 
/// You can customize:
/// * title
/// * default, minimum, maximum and/or fixed size, collapsed/expanded
/// * if the window has a scroll area (off by default)
/// * if the window can be collapsed (minimized) to just the title bar (yes, by default)
/// * if there should be a close button (none by default)The previous rectangle used by this window can be obtained through <c>AreaRect()</c>.
/// 
/// Note that this is NOT a native OS window.
/// To create a new native OS window, use <c>ShowViewportDeferred</c>.
/// </summary>
public unsafe partial sealed class Window : EguiHandle {
    /// <inheritdoc/>
    protected override void Free(EguiObject* pointer) {
        Egui.gui_window_drop(pointer);
    }
    public Window(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "WidgetText", id: Id(343), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) title) {
        Egui.window_new(TODO_ARG(title));
    
    }
    
    public Window Id(Id id) {
        Egui.window_id(TODO_ARG(id));
    
    }
    
    public Window Open(BorrowedRef { lifetime: Some("'open"), is_mutable: true, type_: Primitive("bool") } open) {
        Egui.window_open(TODO_ARG(open));
    
    }
    
    public Window Enabled(bool enabled) {
        Egui.window_enabled(TODO_ARG(enabled));
    
    }
    
    public Window Interactable(bool interactable) {
        Egui.window_interactable(TODO_ARG(interactable));
    
    }
    
    public Window Movable(bool movable) {
        Egui.window_movable(TODO_ARG(movable));
    
    }
    
    public Window Order(Order order) {
        Egui.window_order(TODO_ARG(order));
    
    }
    
    public Window FadeIn(bool fadeIn) {
        Egui.window_fade_in(TODO_ARG(fadeIn));
    
    }
    
    public Window FadeOut(bool fadeOut) {
        Egui.window_fade_out(TODO_ARG(fadeOut));
    
    }
    
    public Window Mutate(ImplTrait([TraitBound { trait_: Path { path: "Fn", id: Id(455), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: Generic("Self") }], output: None }) }, generic_params: [], modifier: None }]) mutate) {
        Egui.window_mutate(TODO_ARG(mutate));
    
    }
    
    public Window Resize(ImplTrait([TraitBound { trait_: Path { path: "Fn", id: Id(455), args: Some(Parenthesized { inputs: [ResolvedPath(Path { path: "Resize", id: Id(148), args: Some(AngleBracketed { args: [], constraints: [] }) })], output: Some(ResolvedPath(Path { path: "Resize", id: Id(148), args: Some(AngleBracketed { args: [], constraints: [] }) })) }) }, generic_params: [], modifier: None }]) mutate) {
        Egui.window_resize(TODO_ARG(mutate));
    
    }
    
    public Window Frame(Frame frame) {
        Egui.window_frame(TODO_ARG(frame));
    
    }
    
    public Window MinWidth(float minWidth) {
        Egui.window_min_width(TODO_ARG(minWidth));
    
    }
    
    public Window MinHeight(float minHeight) {
        Egui.window_min_height(TODO_ARG(minHeight));
    
    }
    
    public Window MinSize(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Vec2", id: Id(150), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) minSize) {
        Egui.window_min_size(TODO_ARG(minSize));
    
    }
    
    public Window MaxWidth(float maxWidth) {
        Egui.window_max_width(TODO_ARG(maxWidth));
    
    }
    
    public Window MaxHeight(float maxHeight) {
        Egui.window_max_height(TODO_ARG(maxHeight));
    
    }
    
    public Window MaxSize(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Vec2", id: Id(150), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) maxSize) {
        Egui.window_max_size(TODO_ARG(maxSize));
    
    }
    
    public Window CurrentPos(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Pos2", id: Id(144), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) currentPos) {
        Egui.window_current_pos(TODO_ARG(currentPos));
    
    }
    
    public Window DefaultPos(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Pos2", id: Id(144), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) defaultPos) {
        Egui.window_default_pos(TODO_ARG(defaultPos));
    
    }
    
    public Window FixedPos(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Pos2", id: Id(144), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) pos) {
        Egui.window_fixed_pos(TODO_ARG(pos));
    
    }
    
    public Window Constrain(bool constrain) {
        Egui.window_constrain(TODO_ARG(constrain));
    
    }
    
    public Window ConstrainTo(Rect constrainRect) {
        Egui.window_constrain_to(TODO_ARG(constrainRect));
    
    }
    
    public Window Pivot(Align2 pivot) {
        Egui.window_pivot(TODO_ARG(pivot));
    
    }
    
    public Window Anchor(Align2 align, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Vec2", id: Id(150), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) offset) {
        Egui.window_anchor(TODO_ARG(align), TODO_ARG(offset));
    
    }
    
    public Window DefaultOpen(bool defaultOpen) {
        Egui.window_default_open(TODO_ARG(defaultOpen));
    
    }
    
    public Window DefaultSize(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Vec2", id: Id(150), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) defaultSize) {
        Egui.window_default_size(TODO_ARG(defaultSize));
    
    }
    
    public Window DefaultWidth(float defaultWidth) {
        Egui.window_default_width(TODO_ARG(defaultWidth));
    
    }
    
    public Window DefaultHeight(float defaultHeight) {
        Egui.window_default_height(TODO_ARG(defaultHeight));
    
    }
    
    public Window FixedSize(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Vec2", id: Id(150), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) size) {
        Egui.window_fixed_size(TODO_ARG(size));
    
    }
    
    public Window DefaultRect(Rect rect) {
        Egui.window_default_rect(TODO_ARG(rect));
    
    }
    
    public Window FixedRect(Rect rect) {
        Egui.window_fixed_rect(TODO_ARG(rect));
    
    }
    
    public Window Resizable(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Vec2b", id: Id(868), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) resizable) {
        Egui.window_resizable(TODO_ARG(resizable));
    
    }
    
    public Window Collapsible(bool collapsible) {
        Egui.window_collapsible(TODO_ARG(collapsible));
    
    }
    
    public Window TitleBar(bool titleBar) {
        Egui.window_title_bar(TODO_ARG(titleBar));
    
    }
    
    public Window AutoSized() {
        Egui.window_auto_sized();
    
    }
    
    public Window Scroll(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Vec2b", id: Id(868), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) scroll) {
        Egui.window_scroll(TODO_ARG(scroll));
    
    }
    
    public Window Scroll2(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Vec2b", id: Id(868), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) scroll) {
        Egui.window_scroll2(TODO_ARG(scroll));
    
    }
    
    public Window Hscroll(bool hscroll) {
        Egui.window_hscroll(TODO_ARG(hscroll));
    
    }
    
    public Window Vscroll(bool vscroll) {
        Egui.window_vscroll(TODO_ARG(vscroll));
    
    }
    
    public Window DragToScroll(bool dragToScroll) {
        Egui.window_drag_to_scroll(TODO_ARG(dragToScroll));
    
    }
    
    public Window ScrollBarVisibility(ScrollBarVisibility visibility) {
        Egui.window_scroll_bar_visibility(TODO_ARG(visibility));
    
    }
    
    public InnerResponse? Show(Context ctx, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.window_show(TODO_ARG(ctx), TODO_ARG(addContents));
    
    }
}

/// <summary>
/// State of an <c>Area</c> that is persisted between frames.
/// 
/// Areas back <c>Window</c>s and other floating containers,
/// like tooltips and the popups of <c>ComboBox</c>.
/// </summary>
public unsafe partial struct AreaState {
    /// <summary>
    /// Returns the "default value" for a type.
    /// </summary>
    public static readonly AreaState Default = (AreaState)Egui.area_state_default();

    /// <summary>
    /// Last known position of the pivot.
    /// </summary>
    public Pos2? PivotPos;
    
    /* UNIMPLEMENTED (field) 
    /// <summary>
    /// The anchor point of the area, i.e. where on the area the <c>PivotPos</c> refers to.
    /// </summary>
    public crate::Align2 Pivot;
    */
    
    /// <summary>
    /// Last known size.
    /// 
    /// Area size is intentionally NOT persisted between sessions,
    /// so that a bad tooltip or menu size won't be remembered forever.
    /// A resizable <c>Window</c> remembers the size the user picked using
    /// the state in the <c>Resize</c> container.
    /// </summary>
    public Vec2? Size;
    
    /// <summary>
    /// If false, clicks goes straight through to what is behind us. Useful for tooltips etc.
    /// </summary>
    public bool Interactable;
    
    /// <summary>
    /// At what time was this area first shown?
    /// 
    /// Used to fade in the area.
    /// </summary>
    public double? LastBecameVisibleAt;
    
    public static AreaState? Load(Context ctx, Id id) {
        Egui.area_state_load(TODO_ARG(ctx), TODO_ARG(id));
    
    }
    
    public Pos2 LeftTopPos() {
        Egui.area_state_left_top_pos();
    
    }
    
    public void SetLeftTopPos(Pos2 pos) {
        Egui.area_state_set_left_top_pos(TODO_ARG(pos));
    
    }
    
    public Rect Rect() {
        Egui.area_state_rect();
    
    }
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static AreaState operator(EguiAreaState value) => new AreaState {
        PivotPos = value.pivot_pos.has_value ? (EguiPos2)value.pivot_pos.value : null,
        Pivot = value.pivot,
        Size = value.size.has_value ? (EguiVec2)value.size.value : null,
        Interactable = value.interactable,
        LastBecameVisibleAt = value.last_became_visible_at.has_value ? value.last_became_visible_at.value : null,
    }
    */
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiAreaState operator(AreaState value) => new EguiAreaState {
        pivot_pos = new EguiOptionPos2 {
            has_value = value.PivotPos.HasValue,
            value = value.PivotPos.GetValueOrDefault(),
        },
        pivot = value.Pivot,
        size = new EguiOptionVec2 {
            has_value = value.Size.HasValue,
            value = value.Size.GetValueOrDefault(),
        },
        interactable = value.Interactable,
        last_became_visible_at = new EguiOptionF64 {
            has_value = value.LastBecameVisibleAt.HasValue,
            value = value.LastBecameVisibleAt.GetValueOrDefault(),
        },
    }
    */
}

/// <summary>
/// A selected text range (could be a range of length zero).
/// 
/// The selection is based on character count (NOT byte count!).
/// </summary>
public unsafe partial struct CCursorRange {
    /// <summary>
    /// Returns the "default value" for a type.
    /// </summary>
    public static readonly CCursorRange Default = (CCursorRange)Egui.c_cursor_range_default();

    /// <summary>
    /// When selecting with a mouse, this is where the mouse was released.
    /// When moving with e.g. shift+arrows, this is what moves.
    /// Note that the two ends can come in any order, and also be equal (no selection).
    /// </summary>
    public CCursor Primary;
    
    /// <summary>
    /// When selecting with a mouse, this is where the mouse was first pressed.
    /// This part of the cursor does not move when shift is down.
    /// </summary>
    public CCursor Secondary;
    
    public static CCursorRange One(CCursor ccursor) {
        Egui.c_cursor_range_one(TODO_ARG(ccursor));
    
    }
    
    public static CCursorRange Two(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "CCursor", id: Id(5032), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) min, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "CCursor", id: Id(5032), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) max) {
        Egui.c_cursor_range_two(TODO_ARG(min), TODO_ARG(max));
    
    }
    
    public bool IsSorted() {
        Egui.c_cursor_range_is_sorted();
    
    }
    
    public Array { type_: ResolvedPath(Path { path: "CCursor", id: Id(5032), args: Some(AngleBracketed { args: [], constraints: [] }) }), len: "2" } Sorted() {
        Egui.c_cursor_range_sorted();
    
    }
    
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static CCursorRange operator(EguiCCursorRange value) => new CCursorRange {
        Primary = (CCursor)value.primary,
        Secondary = (CCursor)value.secondary,
    }
    
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiCCursorRange operator(CCursorRange value) => new EguiCCursorRange {
        primary = (EguiCCursor)value.Primary,
        secondary = (EguiCCursor)value.Secondary,
    }
}

/// <summary>
/// A selected text range (could be a range of length zero).
/// </summary>
public unsafe partial struct CursorRange {
    /// <summary>
    /// Returns the "default value" for a type.
    /// </summary>
    public static readonly CursorRange Default = (CursorRange)Egui.cursor_range_default();

    /// <summary>
    /// When selecting with a mouse, this is where the mouse was released.
    /// When moving with e.g. shift+arrows, this is what moves.
    /// Note that the two ends can come in any order, and also be equal (no selection).
    /// </summary>
    public Cursor Primary;
    
    /// <summary>
    /// When selecting with a mouse, this is where the mouse was first pressed.
    /// This part of the cursor does not move when shift is down.
    /// </summary>
    public Cursor Secondary;
    
    public static CursorRange One(Cursor cursor) {
        Egui.cursor_range_one(TODO_ARG(cursor));
    
    }
    
    public static CursorRange Two(Cursor min, Cursor max) {
        Egui.cursor_range_two(TODO_ARG(min), TODO_ARG(max));
    
    }
    
    public static CursorRange SelectAll(Galley galley) {
        Egui.cursor_range_select_all(TODO_ARG(galley));
    
    }
    
    public CCursorRange AsCcursorRange() {
        Egui.cursor_range_as_ccursor_range();
    
    }
    
    public std::ops::Range AsSortedCharRange() {
        Egui.cursor_range_as_sorted_char_range();
    
    }
    
    public bool IsEmpty() {
        Egui.cursor_range_is_empty();
    
    }
    
    public bool Contains(CursorRange other) {
        Egui.cursor_range_contains(TODO_ARG(other));
    
    }
    
    public Cursor? Single() {
        Egui.cursor_range_single();
    
    }
    
    public bool IsSorted() {
        Egui.cursor_range_is_sorted();
    
    }
    
    public CursorRange Sorted() {
        Egui.cursor_range_sorted();
    
    }
    
    public Array { type_: ResolvedPath(Path { path: "Cursor", id: Id(4983), args: Some(AngleBracketed { args: [], constraints: [] }) }), len: "2" } SortedCursors() {
        Egui.cursor_range_sorted_cursors();
    
    }
    
    public str SliceStr(str text) {
        Egui.cursor_range_slice_str(TODO_ARG(text));
    
    }
    
    public bool OnKeyPress(OperatingSystem os, Galley galley, Modifiers modifiers, Key key) {
        Egui.cursor_range_on_key_press(TODO_ARG(os), TODO_ARG(galley), TODO_ARG(modifiers), TODO_ARG(key));
    
    }
    
    public bool OnEvent(OperatingSystem os, Event event, Galley galley, Id widgetId) {
        Egui.cursor_range_on_event(TODO_ARG(os), TODO_ARG(event), TODO_ARG(galley), TODO_ARG(widgetId));
    
    }
    
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static CursorRange operator(EguiCursorRange value) => new CursorRange {
        Primary = (Cursor)value.primary,
        Secondary = (Cursor)value.secondary,
    }
    
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiCursorRange operator(CursorRange value) => new EguiCursorRange {
        primary = (EguiCursor)value.Primary,
        secondary = (EguiCursor)value.Secondary,
    }
}

/// <summary>
/// Options for help debug egui by adding extra visualization
/// </summary>
public unsafe partial struct DebugOptions {
    /// <summary>
    /// Returns the "default value" for a type.
    /// </summary>
    public static readonly DebugOptions Default = (DebugOptions)Egui.debug_options_default();

    /// <summary>
    /// Always show callstack to ui on hover.
    /// 
    /// Useful for figuring out where in the code some UI is being created.
    /// 
    /// Only works in debug builds.
    /// Requires the <c>Callstack</c> feature.
    /// Does not work on web.
    /// </summary>
    public bool DebugOnHover;
    
    /// <summary>
    /// Show callstack for the current widget on hover if all modifier keys are pressed down.
    /// 
    /// Useful for figuring out where in the code some UI is being created.
    /// 
    /// Only works in debug builds.
    /// Requires the <c>Callstack</c> feature.
    /// Does not work on web.
    /// 
    /// Default is <c>True</c> in debug builds, on native, if the <c>Callstack</c> feature is enabled.
    /// </summary>
    public bool DebugOnHoverWithAllModifiers;
    
    /// <summary>
    /// If we show the hover ui, include where the next widget is placed.
    /// </summary>
    public bool HoverShowsNext;
    
    /// <summary>
    /// Show which widgets make their parent wider
    /// </summary>
    public bool ShowExpandWidth;
    
    /// <summary>
    /// Show which widgets make their parent higher
    /// </summary>
    public bool ShowExpandHeight;
    
    public bool ShowResize;
    
    /// <summary>
    /// Show an overlay on all interactive widgets.
    /// </summary>
    public bool ShowInteractiveWidgets;
    
    /// <summary>
    /// Show interesting widgets under the mouse cursor.
    /// </summary>
    public bool ShowWidgetHits;
    
    /// <summary>
    /// If true, highlight widgets that are not aligned to <c>GuiRounding</c>.
    /// 
    /// See <c>GuiRounding</c> for more.
    /// </summary>
    public bool ShowUnaligned;
    
    public void Ui(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "crate::Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui) {
        Egui.debug_options_ui(TODO_ARG(ui));
    
    }
    
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static DebugOptions operator(EguiDebugOptions value) => new DebugOptions {
        DebugOnHover = value.debug_on_hover,
        DebugOnHoverWithAllModifiers = value.debug_on_hover_with_all_modifiers,
        HoverShowsNext = value.hover_shows_next,
        ShowExpandWidth = value.show_expand_width,
        ShowExpandHeight = value.show_expand_height,
        ShowResize = value.show_resize,
        ShowInteractiveWidgets = value.show_interactive_widgets,
        ShowWidgetHits = value.show_widget_hits,
        ShowUnaligned = value.show_unaligned,
    }
    
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiDebugOptions operator(DebugOptions value) => new EguiDebugOptions {
        debug_on_hover = value.DebugOnHover,
        debug_on_hover_with_all_modifiers = value.DebugOnHoverWithAllModifiers,
        hover_shows_next = value.HoverShowsNext,
        show_expand_width = value.ShowExpandWidth,
        show_expand_height = value.ShowExpandHeight,
        show_resize = value.ShowResize,
        show_interactive_widgets = value.ShowInteractiveWidgets,
        show_widget_hits = value.ShowWidgetHits,
        show_unaligned = value.ShowUnaligned,
    }
}

/// <summary>
/// A file dropped into egui.
/// </summary>
public unsafe partial struct DroppedFile {
    /// <summary>
    /// Returns the "default value" for a type.
    /// </summary>
    public static readonly DroppedFile Default = (DroppedFile)Egui.dropped_file_default();

    /* UNIMPLEMENTED (field) 
    /// <summary>
    /// Set by the <c>EguiWinit</c> backend.
    /// </summary>
    public std::path::PathBuf? Path;
    */
    
    /// <summary>
    /// Name of the file. Set by the <c>Eframe</c> web backend.
    /// </summary>
    public string Name;
    
    /// <summary>
    /// With the <c>Eframe</c> web backend, this is set to the mime-type of the file (if available).
    /// </summary>
    public string Mime;
    
    /// <summary>
    /// Set by the <c>Eframe</c> web backend.
    /// </summary>
    public DateTime? LastModified;
    
    /* UNIMPLEMENTED (field) 
    /// <summary>
    /// Set by the <c>Eframe</c> web backend.
    /// </summary>
    public std::sync::Arc? Bytes;
    */
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static DroppedFile operator(EguiDroppedFile value) => new DroppedFile {
        Path = value.path.has_value ? value.path.value : null,
        Name = STRING_CONV_TODO,
        Mime = STRING_CONV_TODO,
        LastModified = value.last_modified.has_value ? TIME_CONV_TODO(value.last_modified.value) : null,
        Bytes = value.bytes.has_value ? value.bytes.value : null,
    }
    */
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiDroppedFile operator(DroppedFile value) => new EguiDroppedFile {
        path = new EguiOptionStd::path::pathBuf {
            has_value = value.Path.HasValue,
            value = value.Path.GetValueOrDefault(),
        },
        name = STRING_CONV_TODO,
        mime = STRING_CONV_TODO,
        last_modified = new EguiOptionPosixTime {
            has_value = value.LastModified.HasValue,
            value = value.LastModified.GetValueOrDefault(),
        },
        bytes = new EguiOptionStd::sync::arc {
            has_value = value.Bytes.HasValue,
            value = value.Bytes.GetValueOrDefault(),
        },
    }
    */
}

/// <summary>
/// Controls which events that a focused widget will have exclusive access to.
/// 
/// Currently this only controls a few special keyboard events,
/// but in the future this <c>Struct</c> should be extended into a full callback thing.
/// 
/// Any events not covered by the filter are given to the widget, but are not exclusive.
/// </summary>
public unsafe partial struct EventFilter {
    /// <summary>
    /// Returns the "default value" for a type.
    /// </summary>
    public static readonly EventFilter Default = (EventFilter)Egui.event_filter_default();

    /// <summary>
    /// If <c>True</c>, pressing tab will act on the widget,
    /// and NOT move focus away from the focused widget.
    /// 
    /// Default: <c>False</c>
    /// </summary>
    public bool Tab;
    
    /// <summary>
    /// If <c>True</c>, pressing horizontal arrows will act on the
    /// widget, and NOT move focus away from the focused widget.
    /// 
    /// Default: <c>False</c>
    /// </summary>
    public bool HorizontalArrows;
    
    /// <summary>
    /// If <c>True</c>, pressing vertical arrows will act on the
    /// widget, and NOT move focus away from the focused widget.
    /// 
    /// Default: <c>False</c>
    /// </summary>
    public bool VerticalArrows;
    
    /// <summary>
    /// If <c>True</c>, pressing escape will act on the widget,
    /// and NOT surrender focus from the focused widget.
    /// 
    /// Default: <c>False</c>
    /// </summary>
    public bool Escape;
    
    public bool Matches(Event event) {
        Egui.event_filter_matches(TODO_ARG(event));
    
    }
    
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static EventFilter operator(EguiEventFilter value) => new EventFilter {
        Tab = value.tab,
        HorizontalArrows = value.horizontal_arrows,
        VerticalArrows = value.vertical_arrows,
        Escape = value.escape,
    }
    
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiEventFilter operator(EventFilter value) => new EguiEventFilter {
        tab = value.Tab,
        horizontal_arrows = value.HorizontalArrows,
        vertical_arrows = value.VerticalArrows,
        escape = value.Escape,
    }
}

/// <summary>
/// A frame around some content, including margin, colors, etc.
/// 
/// ## Definitions
/// The total (outer) size of a frame is
/// <c>ContentSize+InnerMargin+2*Stroke.width+OuterMargin</c>.
/// 
/// Everything within the stroke is filled with the fill color (if any).The four rectangles, from inside to outside, are:
/// * <c>ContentRect</c>: the rectangle that is made available to the inner <c>Ui</c> or widget.
/// * <c>FillRect</c>: the rectangle that is filled with the fill color (inside the stroke, if any).
/// * <c>WidgetRect</c>: is the interactive part of the widget (what sense clicks etc).
/// * <c>OuterRect</c>: what is allocated in the outer <c>Ui</c>, and is what is returned by <c>Rect</c>.
/// 
/// ## Usage## Dynamic color
/// If you want to change the color of the frame based on the response of
/// the widget, you need to break it up into multiple steps:You can also respond to the hovering of the frame itself:Note that you cannot change the margins after calling <c>Begin</c>.
/// </summary>
public unsafe partial struct Frame {
    /// <summary>
    /// Returns the "default value" for a type.
    /// </summary>
    public static readonly Frame Default = (Frame)Egui.frame_default();

    /// <summary>
    /// Margin within the painted frame.
    /// 
    /// Known as <c>Padding</c> in CSS.
    /// </summary>
    public Margin InnerMargin;
    
    /// <summary>
    /// The background fill color of the frame, within the <c>Stroke</c>.
    /// 
    /// Known as <c>Background</c> in CSS.
    /// </summary>
    public Color32 Fill;
    
    /// <summary>
    /// The width and color of the outline around the frame.
    /// 
    /// The width of the stroke is part of the total margin/padding of the frame.
    /// </summary>
    public Stroke Stroke;
    
    /// <summary>
    /// The rounding of the _outer_ corner of the <c>Stroke</c>
    /// (or, if there is no stroke, the outer corner of <c>Fill</c>).
    /// 
    /// In other words, this is the corner radius of the _widget rect_.
    /// </summary>
    public CornerRadius CornerRadius;
    
    /// <summary>
    /// Margin outside the painted frame.
    /// 
    /// Similar to what is called <c>Margin</c> in CSS.
    /// However, egui does NOT do "Margin Collapse" like in CSS,
    /// i.e. when placing two frames next to each other,
    /// the distance between their borders is the SUM
    /// of their other margins.
    /// In CSS the distance would be the MAX of their outer margins.
    /// Supporting margin collapse is difficult, and would
    /// requires complicating the already complicated egui layout code.
    /// 
    /// Consider using <c>ItemSpacing</c>
    /// for adding space between widgets.
    /// </summary>
    public Margin OuterMargin;
    
    /// <summary>
    /// Optional drop-shadow behind the frame.
    /// </summary>
    public Shadow Shadow;
    
    public Frame() {
        Egui.frame_new();
    
    }
    
    public static Frame None() {
        Egui.frame_none();
    
    }
    
    public static Frame Group(Style style) {
        Egui.frame_group(TODO_ARG(style));
    
    }
    
    public static Frame SideTopPanel(Style style) {
        Egui.frame_side_top_panel(TODO_ARG(style));
    
    }
    
    public static Frame CentralPanel(Style style) {
        Egui.frame_central_panel(TODO_ARG(style));
    
    }
    
    public static Frame Window(Style style) {
        Egui.frame_window(TODO_ARG(style));
    
    }
    
    public static Frame Menu(Style style) {
        Egui.frame_menu(TODO_ARG(style));
    
    }
    
    public static Frame Popup(Style style) {
        Egui.frame_popup(TODO_ARG(style));
    
    }
    
    public static Frame Canvas(Style style) {
        Egui.frame_canvas(TODO_ARG(style));
    
    }
    
    public static Frame DarkCanvas(Style style) {
        Egui.frame_dark_canvas(TODO_ARG(style));
    
    }
    
    public Frame InnerMargin(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Margin", id: Id(474), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) innerMargin) {
        Egui.frame_inner_margin(TODO_ARG(innerMargin));
    
    }
    
    public Frame Fill(Color32 fill) {
        Egui.frame_fill(TODO_ARG(fill));
    
    }
    
    public Frame Stroke(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Stroke", id: Id(479), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) stroke) {
        Egui.frame_stroke(TODO_ARG(stroke));
    
    }
    
    public Frame CornerRadius(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "CornerRadius", id: Id(482), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) cornerRadius) {
        Egui.frame_corner_radius(TODO_ARG(cornerRadius));
    
    }
    
    public Frame Rounding(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "CornerRadius", id: Id(482), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) cornerRadius) {
        Egui.frame_rounding(TODO_ARG(cornerRadius));
    
    }
    
    public Frame OuterMargin(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Margin", id: Id(474), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) outerMargin) {
        Egui.frame_outer_margin(TODO_ARG(outerMargin));
    
    }
    
    public Frame Shadow(Shadow shadow) {
        Egui.frame_shadow(TODO_ARG(shadow));
    
    }
    
    public Frame MultiplyWithOpacity(float opacity) {
        Egui.frame_multiply_with_opacity(TODO_ARG(opacity));
    
    }
    
    public Marginf TotalMargin() {
        Egui.frame_total_margin();
    
    }
    
    public Rect FillRect(Rect contentRect) {
        Egui.frame_fill_rect(TODO_ARG(contentRect));
    
    }
    
    public Rect WidgetRect(Rect contentRect) {
        Egui.frame_widget_rect(TODO_ARG(contentRect));
    
    }
    
    public Rect OuterRect(Rect contentRect) {
        Egui.frame_outer_rect(TODO_ARG(contentRect));
    
    }
    
    public Prepared Begin(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui) {
        Egui.frame_begin(TODO_ARG(ui));
    
    }
    
    public InnerResponse Show(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.frame_show(TODO_ARG(ui), TODO_ARG(addContents));
    
    }
    
    public InnerResponse ShowDyn(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui, Box addContents) {
        Egui.frame_show_dyn(TODO_ARG(ui), TODO_ARG(addContents));
    
    }
    
    public Shape Paint(Rect contentRect) {
        Egui.frame_paint(TODO_ARG(contentRect));
    
    }
    
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static Frame operator(EguiFrame value) => new Frame {
        InnerMargin = (Margin)value.inner_margin,
        Fill = (Color32)value.fill,
        Stroke = (Stroke)value.stroke,
        CornerRadius = (CornerRadius)value.corner_radius,
        OuterMargin = (Margin)value.outer_margin,
        Shadow = (Shadow)value.shadow,
    }
    
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiFrame operator(Frame value) => new EguiFrame {
        inner_margin = (EguiMargin)value.InnerMargin,
        fill = (EguiColor32)value.Fill,
        stroke = (EguiStroke)value.Stroke,
        corner_radius = (EguiCornerRadius)value.CornerRadius,
        outer_margin = (EguiMargin)value.OuterMargin,
        shadow = (EguiShadow)value.Shadow,
    }
}

/// <summary>
/// A file about to be dropped into egui.
/// </summary>
public unsafe partial struct HoveredFile {
    /// <summary>
    /// Returns the "default value" for a type.
    /// </summary>
    public static readonly HoveredFile Default = (HoveredFile)Egui.hovered_file_default();

    /* UNIMPLEMENTED (field) 
    /// <summary>
    /// Set by the <c>EguiWinit</c> backend.
    /// </summary>
    public std::path::PathBuf? Path;
    */
    
    /// <summary>
    /// With the <c>Eframe</c> web backend, this is set to the mime-type of the file (if available).
    /// </summary>
    public string Mime;
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static HoveredFile operator(EguiHoveredFile value) => new HoveredFile {
        Path = value.path.has_value ? value.path.value : null,
        Mime = STRING_CONV_TODO,
    }
    */
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiHoveredFile operator(HoveredFile value) => new EguiHoveredFile {
        path = new EguiOptionStd::path::pathBuf {
            has_value = value.Path.HasValue,
            value = value.Path.GetValueOrDefault(),
        },
        mime = STRING_CONV_TODO,
    }
    */
}

/// <summary>
/// Information about text being edited.
/// 
/// Useful for IME.
/// </summary>
public unsafe partial struct IMEOutput {
    /// <summary>
    /// Where the <c>TextEdit</c> is located on screen.
    /// </summary>
    public Rect Rect;
    
    /// <summary>
    /// Where the primary cursor is.
    /// 
    /// This is a very thin rectangle.
    /// </summary>
    public Rect CursorRect;
    
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static IMEOutput operator(EguiIMEOutput value) => new IMEOutput {
        Rect = (Rect)value.rect,
        CursorRect = (Rect)value.cursor_rect,
    }
    
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiIMEOutput operator(IMEOutput value) => new EguiIMEOutput {
        rect = (EguiRect)value.Rect,
        cursor_rect = (EguiRect)value.CursorRect,
    }
}

public unsafe partial struct ImageOptions {
    /// <summary>
    /// Returns the "default value" for a type.
    /// </summary>
    public static readonly ImageOptions Default = (ImageOptions)Egui.image_options_default();

    /// <summary>
    /// Select UV range. Default is (0,0) in top-left, (1,1) bottom right.
    /// </summary>
    public Rect Uv;
    
    /// <summary>
    /// A solid color to put behind the image. Useful for transparent images.
    /// </summary>
    public Color32 BgFill;
    
    /// <summary>
    /// Multiply image color with this. Default is WHITE (no tint).
    /// </summary>
    public Color32 Tint;
    
    /* UNIMPLEMENTED (field) 
    /// <summary>
    /// Rotate the image about an origin by some angle
    /// 
    /// Positive angle is clockwise.
    /// Origin is a vector in normalized UV space ((0,0) in top-left, (1,1) bottom right).
    /// 
    /// To rotate about the center you can pass <c>Splat(0.5)</c> as the origin.
    /// 
    /// Due to limitations in the current implementation,
    /// this will turn off rounding of the image.
    /// </summary>
    public Tuple([ResolvedPath(Path { path: "emath::Rot2", id: Id(6930), args: Some(AngleBracketed { args: [], constraints: [] }) }), ResolvedPath(Path { path: "crate::Vec2", id: Id(150), args: Some(AngleBracketed { args: [], constraints: [] }) })])? Rotation;
    */
    
    /// <summary>
    /// Round the corners of the image.
    /// 
    /// The default is no rounding (<c>Zero</c>).
    /// 
    /// Due to limitations in the current implementation,
    /// this will turn off any rotation of the image.
    /// </summary>
    public CornerRadius CornerRadius;
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static ImageOptions operator(EguiImageOptions value) => new ImageOptions {
        Uv = (Rect)value.uv,
        BgFill = (Color32)value.bg_fill,
        Tint = (Color32)value.tint,
        Rotation = value.rotation.has_value ? value.rotation.value : null,
        CornerRadius = (CornerRadius)value.corner_radius,
    }
    */
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiImageOptions operator(ImageOptions value) => new EguiImageOptions {
        uv = (EguiRect)value.Uv,
        bg_fill = (EguiColor32)value.BgFill,
        tint = (EguiColor32)value.Tint,
        rotation = new EguiOptionTuple([resolvedPath(path{Path:"emath::rot2",Id:Id(6930),Args:Some(angleBracketed{Args:[],Constraints:[]})}),ResolvedPath(path{Path:"crate::vec2",Id:Id(150),Args:Some(angleBracketed{Args:[],Constraints:[]})})]) {
            has_value = value.Rotation.HasValue,
            value = value.Rotation.GetValueOrDefault(),
        },
        corner_radius = (EguiCornerRadius)value.CornerRadius,
    }
    */
}

/// <summary>
/// This type determines the constraints on how
/// the size of an image should be calculated.
/// </summary>
public unsafe partial struct ImageSize {
    /// <summary>
    /// Returns the "default value" for a type.
    /// </summary>
    public static readonly ImageSize Default = (ImageSize)Egui.image_size_default();

    /// <summary>
    /// Whether or not the final size should maintain the original aspect ratio.
    /// 
    /// This setting is applied last.
    /// 
    /// This defaults to <c>True</c>.
    /// </summary>
    public bool MaintainAspectRatio;
    
    /// <summary>
    /// Determines the maximum size of the image.
    /// 
    /// Defaults to <c>Infinity</c> (no limit).
    /// </summary>
    public Vec2 MaxSize;
    
    /* UNIMPLEMENTED (field) 
    /// <summary>
    /// Determines how the image should shrink/expand/stretch/etc. to fit within its allocated space.
    /// 
    /// This setting is applied first.
    /// 
    /// Defaults to <c>Fraction(1,1)</c>
    /// </summary>
    public ImageFit Fit;
    */
    
    public SizeHint Hint(Vec2 availableSize, float pixelsPerPoint) {
        Egui.image_size_hint(TODO_ARG(availableSize), TODO_ARG(pixelsPerPoint));
    
    }
    
    public Vec2 CalcSize(Vec2 availableSize, Vec2 originalImageSize) {
        Egui.image_size_calc_size(TODO_ARG(availableSize), TODO_ARG(originalImageSize));
    
    }
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static ImageSize operator(EguiImageSize value) => new ImageSize {
        MaintainAspectRatio = value.maintain_aspect_ratio,
        MaxSize = (Vec2)value.max_size,
        Fit = value.fit,
    }
    */
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiImageSize operator(ImageSize value) => new EguiImageSize {
        maintain_aspect_ratio = value.MaintainAspectRatio,
        max_size = (EguiVec2)value.MaxSize,
        fit = value.Fit,
    }
    */
}

/// <summary>
/// How and when interaction happens.
/// </summary>
public unsafe partial struct Interaction {
    /// <summary>
    /// Returns the "default value" for a type.
    /// </summary>
    public static readonly Interaction Default = (Interaction)Egui.interaction_default();

    /// <summary>
    /// How close a widget must be to the mouse to have a chance to register as a click or drag.
    /// 
    /// If this is larger than zero, it gets easier to hit widgets,
    /// which is important for e.g. touch screens.
    /// </summary>
    public float InteractRadius;
    
    /// <summary>
    /// Radius of the interactive area of the side of a window during drag-to-resize.
    /// </summary>
    public float ResizeGrabRadiusSide;
    
    /// <summary>
    /// Radius of the interactive area of the corner of a window during drag-to-resize.
    /// </summary>
    public float ResizeGrabRadiusCorner;
    
    /// <summary>
    /// If <c>False</c>, tooltips will show up anytime you hover anything, even if mouse is still moving
    /// </summary>
    public bool ShowTooltipsOnlyWhenStill;
    
    /// <summary>
    /// Delay in seconds before showing tooltips after the mouse stops moving
    /// </summary>
    public float TooltipDelay;
    
    /// <summary>
    /// If you have waited for a tooltip and then hover some other widget within
    /// this many seconds, then show the new tooltip right away,
    /// skipping <c>TooltipDelay</c>.
    /// 
    /// This lets the user quickly move over some dead space to hover the next thing.
    /// </summary>
    public float TooltipGraceTime;
    
    /// <summary>
    /// Can you select the text on a <c>Label</c> by default?
    /// </summary>
    public bool SelectableLabels;
    
    /// <summary>
    /// Can the user select text that span multiple labels?
    /// 
    /// The default is <c>True</c>, but text selection can be slightly glitchy,
    /// so you may want to disable it.
    /// </summary>
    public bool MultiWidgetTextSelect;
    
    public void Ui(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "crate::Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui) {
        Egui.interaction_ui(TODO_ARG(ui));
    
    }
    
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static Interaction operator(EguiInteraction value) => new Interaction {
        InteractRadius = value.interact_radius,
        ResizeGrabRadiusSide = value.resize_grab_radius_side,
        ResizeGrabRadiusCorner = value.resize_grab_radius_corner,
        ShowTooltipsOnlyWhenStill = value.show_tooltips_only_when_still,
        TooltipDelay = value.tooltip_delay,
        TooltipGraceTime = value.tooltip_grace_time,
        SelectableLabels = value.selectable_labels,
        MultiWidgetTextSelect = value.multi_widget_text_select,
    }
    
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiInteraction operator(Interaction value) => new EguiInteraction {
        interact_radius = value.InteractRadius,
        resize_grab_radius_side = value.ResizeGrabRadiusSide,
        resize_grab_radius_corner = value.ResizeGrabRadiusCorner,
        show_tooltips_only_when_still = value.ShowTooltipsOnlyWhenStill,
        tooltip_delay = value.TooltipDelay,
        tooltip_grace_time = value.TooltipGraceTime,
        selectable_labels = value.SelectableLabels,
        multi_widget_text_select = value.MultiWidgetTextSelect,
    }
}

/// <summary>
/// A keyboard shortcut, e.g. <c>Ctrl+alt+w</c>.
/// 
/// Can be used with <c>ConsumeShortcut</c>
/// and <c>FormatShortcut</c>.
/// </summary>
public unsafe partial struct KeyboardShortcut {
    public Modifiers Modifiers;
    
    public Key LogicalKey;
    
    public KeyboardShortcut(Modifiers modifiers, Key logicalKey) {
        Egui.keyboard_shortcut_new(TODO_ARG(modifiers), TODO_ARG(logicalKey));
    
    }
    
    public string Format(ModifierNames names, bool isMac) {
        Egui.keyboard_shortcut_format(TODO_ARG(names), TODO_ARG(isMac));
    
    }
    
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static KeyboardShortcut operator(EguiKeyboardShortcut value) => new KeyboardShortcut {
        Modifiers = (Modifiers)value.modifiers,
        LogicalKey = (Key)value.logical_key,
    }
    
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiKeyboardShortcut operator(KeyboardShortcut value) => new EguiKeyboardShortcut {
        modifiers = (EguiModifiers)value.Modifiers,
        logical_key = (EguiKey)value.LogicalKey,
    }
}

/// <summary>
/// An identifier for a paint layer.
/// Also acts as an identifier for <c>Area</c>:s.
/// </summary>
public unsafe partial struct LayerId {
    public Order Order;
    
    public Id Id;
    
    public LayerId(Order order, Id id) {
        Egui.layer_id_new(TODO_ARG(order), TODO_ARG(id));
    
    }
    
    public static LayerId Debug() {
        Egui.layer_id_debug();
    
    }
    
    public static LayerId Background() {
        Egui.layer_id_background();
    
    }
    
    public bool AllowInteraction() {
        Egui.layer_id_allow_interaction();
    
    }
    
    public string ShortDebugFormat() {
        Egui.layer_id_short_debug_format();
    
    }
    
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static LayerId operator(EguiLayerId value) => new LayerId {
        Order = value.order.Cast<EguiOrder, Order>(),
        Id = (Id)value.id,
    }
    
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiLayerId operator(LayerId value) => new EguiLayerId {
        order = value.Order.Cast<Order, EguiOrder>(),
        id = (EguiId)value.Id,
    }
}

/// <summary>
/// The layout of a <c>Ui</c><c>Ui</c>, e.g. "vertical & centered".
/// </summary>
public unsafe partial struct Layout {
    /// <summary>
    /// Returns the "default value" for a type.
    /// </summary>
    public static readonly Layout Default = (Layout)Egui.layout_default();

    /// <summary>
    /// Main axis direction
    /// </summary>
    public Direction MainDir;
    
    /// <summary>
    /// If true, wrap around when reading the end of the main direction.
    /// For instance, for <c>LeftToRight</c> this will
    /// wrap to a new row when we reach the right side of the <c>MaxRect</c>.
    /// </summary>
    public bool MainWrap;
    
    /// <summary>
    /// How to align things on the main axis.
    /// </summary>
    public Align MainAlign;
    
    /// <summary>
    /// Justify the main axis?
    /// </summary>
    public bool MainJustify;
    
    /// <summary>
    /// How to align things on the cross axis.
    /// For vertical layouts: put things to left, center or right?
    /// For horizontal layouts: put things to top, center or bottom?
    /// </summary>
    public Align CrossAlign;
    
    /// <summary>
    /// Justify the cross axis?
    /// For vertical layouts justify mean all widgets get maximum width.
    /// For horizontal layouts justify mean all widgets get maximum height.
    /// </summary>
    public bool CrossJustify;
    
    public static Layout LeftToRight(Align valign) {
        Egui.layout_left_to_right(TODO_ARG(valign));
    
    }
    
    public static Layout RightToLeft(Align valign) {
        Egui.layout_right_to_left(TODO_ARG(valign));
    
    }
    
    public static Layout TopDown(Align halign) {
        Egui.layout_top_down(TODO_ARG(halign));
    
    }
    
    public static Layout TopDownJustified(Align halign) {
        Egui.layout_top_down_justified(TODO_ARG(halign));
    
    }
    
    public static Layout BottomUp(Align halign) {
        Egui.layout_bottom_up(TODO_ARG(halign));
    
    }
    
    public static Layout FromMainDirAndCrossAlign(Direction mainDir, Align crossAlign) {
        Egui.layout_from_main_dir_and_cross_align(TODO_ARG(mainDir), TODO_ARG(crossAlign));
    
    }
    
    public static Layout CenteredAndJustified(Direction mainDir) {
        Egui.layout_centered_and_justified(TODO_ARG(mainDir));
    
    }
    
    public Layout WithMainWrap(bool mainWrap) {
        Egui.layout_with_main_wrap(TODO_ARG(mainWrap));
    
    }
    
    public Layout WithMainAlign(Align mainAlign) {
        Egui.layout_with_main_align(TODO_ARG(mainAlign));
    
    }
    
    public Layout WithCrossAlign(Align crossAlign) {
        Egui.layout_with_cross_align(TODO_ARG(crossAlign));
    
    }
    
    public Layout WithMainJustify(bool mainJustify) {
        Egui.layout_with_main_justify(TODO_ARG(mainJustify));
    
    }
    
    public Layout WithCrossJustify(bool crossJustify) {
        Egui.layout_with_cross_justify(TODO_ARG(crossJustify));
    
    }
    
    public Direction MainDir() {
        Egui.layout_main_dir();
    
    }
    
    public bool MainWrap() {
        Egui.layout_main_wrap();
    
    }
    
    public Align CrossAlign() {
        Egui.layout_cross_align();
    
    }
    
    public bool CrossJustify() {
        Egui.layout_cross_justify();
    
    }
    
    public bool IsHorizontal() {
        Egui.layout_is_horizontal();
    
    }
    
    public bool IsVertical() {
        Egui.layout_is_vertical();
    
    }
    
    public bool PreferRightToLeft() {
        Egui.layout_prefer_right_to_left();
    
    }
    
    public Align HorizontalPlacement() {
        Egui.layout_horizontal_placement();
    
    }
    
    public Align HorizontalAlign() {
        Egui.layout_horizontal_align();
    
    }
    
    public Align VerticalAlign() {
        Egui.layout_vertical_align();
    
    }
    
    public bool HorizontalJustify() {
        Egui.layout_horizontal_justify();
    
    }
    
    public bool VerticalJustify() {
        Egui.layout_vertical_justify();
    
    }
    
    public Rect AlignSizeWithinRect(Vec2 size, Rect outer) {
        Egui.layout_align_size_within_rect(TODO_ARG(size), TODO_ARG(outer));
    
    }
    
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static Layout operator(EguiLayout value) => new Layout {
        MainDir = value.main_dir.Cast<EguiDirection, Direction>(),
        MainWrap = value.main_wrap,
        MainAlign = (Align)value.main_align,
        MainJustify = value.main_justify,
        CrossAlign = (Align)value.cross_align,
        CrossJustify = value.cross_justify,
    }
    
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiLayout operator(Layout value) => new EguiLayout {
        main_dir = value.MainDir.Cast<Direction, EguiDirection>(),
        main_wrap = value.MainWrap,
        main_align = (EguiAlign)value.MainAlign,
        main_justify = value.MainJustify,
        cross_align = (EguiAlign)value.CrossAlign,
        cross_justify = value.CrossJustify,
    }
}

/// <summary>
/// Menu root associated with an Id from a Response
/// </summary>
public unsafe partial struct MenuRoot {
    /* UNIMPLEMENTED (field) 
    public std::sync::Arc MenuState;
    */
    
    public Id Id;
    
    public MenuRoot(Pos2 position, Id id) {
        Egui.menu_root_new(TODO_ARG(position), TODO_ARG(id));
    
    }
    
    public Tuple([ResolvedPath(Path { path: "MenuResponse", id: Id(3855), args: Some(AngleBracketed { args: [], constraints: [] }) }), ResolvedPath(Path { path: "Option", id: Id(118), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "InnerResponse", id: Id(239), args: Some(AngleBracketed { args: [Type(Generic("R"))], constraints: [] }) }))], constraints: [] }) })]) Show(Response button, ImplTrait([TraitBound { trait_: Path { path: "FnOnce", id: Id(237), args: Some(Parenthesized { inputs: [BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) }], output: Some(Generic("R")) }) }, generic_params: [], modifier: None }]) addContents) {
        Egui.menu_root_show(TODO_ARG(button), TODO_ARG(addContents));
    
    }
    
    public static MenuResponse ContextInteraction(Response response, BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Option", id: Id(118), args: Some(AngleBracketed { args: [Type(Generic("Self"))], constraints: [] }) }) } root) {
        Egui.menu_root_context_interaction(TODO_ARG(response), TODO_ARG(root));
    
    }
    
    public static void HandleMenuResponse(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "MenuRootManager", id: Id(3809), args: Some(AngleBracketed { args: [], constraints: [] }) }) } root, MenuResponse menuResponse) {
        Egui.menu_root_handle_menu_response(TODO_ARG(root), TODO_ARG(menuResponse));
    
    }
    
    public static void ContextClickInteraction(Response response, BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "MenuRootManager", id: Id(3809), args: Some(AngleBracketed { args: [], constraints: [] }) }) } root) {
        Egui.menu_root_context_click_interaction(TODO_ARG(response), TODO_ARG(root));
    
    }
    
    public static void StationaryClickInteraction(Response button, BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "MenuRootManager", id: Id(3809), args: Some(AngleBracketed { args: [], constraints: [] }) }) } root) {
        Egui.menu_root_stationary_click_interaction(TODO_ARG(button), TODO_ARG(root));
    
    }
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static MenuRoot operator(EguiMenuRoot value) => new MenuRoot {
        MenuState = value.menu_state,
        Id = (Id)value.id,
    }
    */
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiMenuRoot operator(MenuRoot value) => new EguiMenuRoot {
        menu_state = value.MenuState,
        id = (EguiId)value.Id,
    }
    */
}

/// <summary>
/// Names of different modifier keys.
/// 
/// Used to name modifiers.
/// </summary>
public unsafe partial struct ModifierNames {
    public bool IsShort;
    
    /* UNIMPLEMENTED (field) 
    public str Alt;
    */
    
    /* UNIMPLEMENTED (field) 
    public str Ctrl;
    */
    
    /* UNIMPLEMENTED (field) 
    public str Shift;
    */
    
    /* UNIMPLEMENTED (field) 
    public str MacCmd;
    */
    
    /* UNIMPLEMENTED (field) 
    public str MacAlt;
    */
    
    /* UNIMPLEMENTED (field) 
    /// <summary>
    /// What goes between the names
    /// </summary>
    public str Concat;
    */
    
    public string Format(Modifiers modifiers, bool isMac) {
        Egui.modifier_names_format(TODO_ARG(modifiers), TODO_ARG(isMac));
    
    }
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static ModifierNames operator(EguiModifierNames value) => new ModifierNames {
        IsShort = value.is_short,
        Alt = value.alt,
        Ctrl = value.ctrl,
        Shift = value.shift,
        MacCmd = value.mac_cmd,
        MacAlt = value.mac_alt,
        Concat = value.concat,
    }
    */
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiModifierNames operator(ModifierNames value) => new EguiModifierNames {
        is_short = value.IsShort,
        alt = value.Alt,
        ctrl = value.Ctrl,
        shift = value.Shift,
        mac_cmd = value.MacCmd,
        mac_alt = value.MacAlt,
        concat = value.Concat,
    }
    */
}

/// <summary>
/// State of the modifier keys. These must be fed to egui.
/// 
/// The best way to compare <c>Modifiers</c> is by using <c>Matches</c>.
/// 
/// NOTE: For cross-platform uses, ALT+SHIFT is a bad combination of modifiers
/// as on mac that is how you type special characters,
/// so those key presses are usually not reported to egui.
/// </summary>
public unsafe partial struct Modifiers {
    /// <summary>
    /// Returns the "default value" for a type.
    /// </summary>
    public static readonly Modifiers Default = (Modifiers)Egui.modifiers_default();

    /// <summary>
    /// Either of the alt keys are down (option ⌥ on Mac).
    /// </summary>
    public bool Alt;
    
    /// <summary>
    /// Either of the control keys are down.
    /// When checking for keyboard shortcuts, consider using <c>Command</c> instead.
    /// </summary>
    public bool Ctrl;
    
    /// <summary>
    /// Either of the shift keys are down.
    /// </summary>
    public bool Shift;
    
    /// <summary>
    /// The Mac ⌘ Command key. Should always be set to <c>False</c> on other platforms.
    /// </summary>
    public bool MacCmd;
    
    /// <summary>
    /// On Windows and Linux, set this to the same value as <c>Ctrl</c>.
    /// On Mac, this should be set whenever one of the ⌘ Command keys are down (same as <c>MacCmd</c>).
    /// This is so that egui can, for instance, select all text by checking for <c>Command+A</c>
    /// and it will work on both Mac and Windows.
    /// </summary>
    public bool Command;
    
    public Modifiers Plus(Modifiers rhs) {
        Egui.modifiers_plus(TODO_ARG(rhs));
    
    }
    
    public bool IsNone() {
        Egui.modifiers_is_none();
    
    }
    
    public bool Any() {
        Egui.modifiers_any();
    
    }
    
    public bool All() {
        Egui.modifiers_all();
    
    }
    
    public bool ShiftOnly() {
        Egui.modifiers_shift_only();
    
    }
    
    public bool CommandOnly() {
        Egui.modifiers_command_only();
    
    }
    
    public bool MatchesLogically(Modifiers pattern) {
        Egui.modifiers_matches_logically(TODO_ARG(pattern));
    
    }
    
    public bool MatchesExact(Modifiers pattern) {
        Egui.modifiers_matches_exact(TODO_ARG(pattern));
    
    }
    
    public bool Matches(Modifiers pattern) {
        Egui.modifiers_matches(TODO_ARG(pattern));
    
    }
    
    public bool CmdCtrlMatches(Modifiers pattern) {
        Egui.modifiers_cmd_ctrl_matches(TODO_ARG(pattern));
    
    }
    
    public bool Contains(Modifiers query) {
        Egui.modifiers_contains(TODO_ARG(query));
    
    }
    
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static Modifiers operator(EguiModifiers value) => new Modifiers {
        Alt = value.alt,
        Ctrl = value.ctrl,
        Shift = value.shift,
        MacCmd = value.mac_cmd,
        Command = value.command,
    }
    
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiModifiers operator(Modifiers value) => new EguiModifiers {
        alt = value.Alt,
        ctrl = value.Ctrl,
        shift = value.Shift,
        mac_cmd = value.MacCmd,
        command = value.Command,
    }
}

/// <summary>
/// All you probably need to know about a multi-touch gesture.
/// </summary>
public unsafe partial struct MultiTouchInfo {
    /// <summary>
    /// Point in time when the gesture started.
    /// </summary>
    public double StartTime;
    
    /// <summary>
    /// Position of the pointer at the time the gesture started.
    /// </summary>
    public Pos2 StartPos;
    
    /// <summary>
    /// Center position of the current gesture (average of all touch points).
    /// </summary>
    public Pos2 CenterPos;
    
    /// <summary>
    /// Number of touches (fingers) on the surface. Value is ≥ 2 since for a single touch no
    /// <c>MultiTouchInfo</c> is created.
    /// </summary>
    public nuint NumTouches;
    
    /// <summary>
    /// Proportional zoom factor (pinch gesture).
    /// * <c>Zoom=1</c>: no change
    /// * <c>Zoom<1</c>: pinch together
    /// * <c>Zoom>1</c>: pinch spread
    /// </summary>
    public float ZoomDelta;
    
    /// <summary>
    /// 2D non-proportional zoom factor (pinch gesture).
    /// 
    /// For horizontal pinches, this will return <c>Z,1</c>,
    /// for vertical pinches this will return <c>1,Z</c>,
    /// and otherwise this will return <c>Z,Z</c>,
    /// where <c>Z</c> is the zoom factor:
    /// * <c>Zoom=1</c>: no change
    /// * <c>Zoom<1</c>: pinch together
    /// * <c>Zoom>1</c>: pinch spread
    /// </summary>
    public Vec2 ZoomDelta2D;
    
    /// <summary>
    /// Rotation in radians. Moving fingers around each other will change this value. This is a
    /// relative value, comparing the orientation of fingers in the current frame with the previous
    /// frame. If all fingers are resting, this value is <c>0.0</c>.
    /// </summary>
    public float RotationDelta;
    
    /// <summary>
    /// Relative movement (comparing previous frame and current frame) of the average position of
    /// all touch points. Without movement this value is <c>Zero</c>.
    /// 
    /// Note that this may not necessarily be measured in screen points (although it _will_ be for
    /// most mobile devices). In general (depending on the touch device), touch coordinates cannot
    /// be directly mapped to the screen. A touch always is considered to start at the position of
    /// the pointer, but touch movement is always measured in the units delivered by the device,
    /// and may depend on hardware and system settings.
    /// </summary>
    public Vec2 TranslationDelta;
    
    /// <summary>
    /// Current force of the touch (average of the forces of the individual fingers). This is a
    /// value in the interval <c>0.0..=1.0</c>.
    /// 
    /// Note 1: A value of <c>0.0</c> either indicates a very light touch, or it means that the device
    /// is not capable of measuring the touch force at all.
    /// 
    /// Note 2: Just increasing the physical pressure without actually moving the finger may not
    /// necessarily lead to a change of this value.
    /// </summary>
    public float Force;
    
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static MultiTouchInfo operator(EguiMultiTouchInfo value) => new MultiTouchInfo {
        StartTime = value.start_time,
        StartPos = (Pos2)value.start_pos,
        CenterPos = (Pos2)value.center_pos,
        NumTouches = value.num_touches,
        ZoomDelta = value.zoom_delta,
        ZoomDelta2D = (Vec2)value.zoom_delta_2d,
        RotationDelta = value.rotation_delta,
        TranslationDelta = (Vec2)value.translation_delta,
        Force = value.force,
    }
    
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiMultiTouchInfo operator(MultiTouchInfo value) => new EguiMultiTouchInfo {
        start_time = value.StartTime,
        start_pos = (EguiPos2)value.StartPos,
        center_pos = (EguiPos2)value.CenterPos,
        num_touches = value.NumTouches,
        zoom_delta = value.ZoomDelta,
        zoom_delta_2d = (EguiVec2)value.ZoomDelta2D,
        rotation_delta = value.RotationDelta,
        translation_delta = (EguiVec2)value.TranslationDelta,
        force = value.Force,
    }
}

/// <summary>
/// What URL to open, and how.
/// 
/// Use with <c>OpenUrl</c>.
/// </summary>
public unsafe partial struct OpenUrl {
    public string Url;
    
    /// <summary>
    /// If <c>True</c>, open the url in a new tab.
    /// If <c>False</c> open it in the same tab.
    /// Only matters when in a web browser.
    /// </summary>
    public bool NewTab;
    
    public static OpenUrl SameTab(ImplTrait([TraitBound { trait_: Path { path: "ToString", id: Id(1298), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) url) {
        Egui.open_url_same_tab(TODO_ARG(url));
    
    }
    
    public static OpenUrl NewTab(ImplTrait([TraitBound { trait_: Path { path: "ToString", id: Id(1298), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) url) {
        Egui.open_url_new_tab(TODO_ARG(url));
    
    }
    
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static OpenUrl operator(EguiOpenUrl value) => new OpenUrl {
        Url = STRING_CONV_TODO,
        NewTab = value.new_tab,
    }
    
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiOpenUrl operator(OpenUrl value) => new EguiOpenUrl {
        url = STRING_CONV_TODO,
        new_tab = value.NewTab,
    }
}

public unsafe partial struct PCursorRange {
    /// <summary>
    /// Returns the "default value" for a type.
    /// </summary>
    public static readonly PCursorRange Default = (PCursorRange)Egui.p_cursor_range_default();

    /// <summary>
    /// When selecting with a mouse, this is where the mouse was released.
    /// When moving with e.g. shift+arrows, this is what moves.
    /// Note that the two ends can come in any order, and also be equal (no selection).
    /// </summary>
    public PCursor Primary;
    
    /// <summary>
    /// When selecting with a mouse, this is where the mouse was first pressed.
    /// This part of the cursor does not move when shift is down.
    /// </summary>
    public PCursor Secondary;
    
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static PCursorRange operator(EguiPCursorRange value) => new PCursorRange {
        Primary = (PCursor)value.primary,
        Secondary = (PCursor)value.secondary,
    }
    
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiPCursorRange operator(PCursorRange value) => new EguiPCursorRange {
        primary = (EguiPCursor)value.Primary,
        secondary = (EguiPCursor)value.Secondary,
    }
}

/// <summary>
/// The non-rendering part of what egui emits each frame.
/// 
/// You can access (and modify) this with <c>Output</c>.
/// 
/// The backend should use this.
/// </summary>
public unsafe partial struct PlatformOutput {
    /// <summary>
    /// Returns the "default value" for a type.
    /// </summary>
    public static readonly PlatformOutput Default = (PlatformOutput)Egui.platform_output_default();

    /* UNIMPLEMENTED (field) 
    /// <summary>
    /// Commands that the egui integration should execute at the end of a frame.
    /// </summary>
    public List<OutputCommand> Commands;
    */
    
    /// <summary>
    /// Set the cursor to this icon.
    /// </summary>
    public CursorIcon CursorIcon;
    
    /// <summary>
    /// If set, open this url.
    /// </summary>
    public OpenUrl? OpenUrl;
    
    /// <summary>
    /// If set, put this text in the system clipboard. Ignore if empty.
    /// 
    /// This is often a response to <c>Copy</c> or <c>Cut</c>.
    /// </summary>
    public string CopiedText;
    
    /* UNIMPLEMENTED (field) 
    /// <summary>
    /// Events that may be useful to e.g. a screen reader.
    /// </summary>
    public List<OutputEvent> Events;
    */
    
    /// <summary>
    /// Is there a mutable <c>TextEdit</c> under the cursor?
    /// Use by <c>Eframe</c> web to show/hide mobile keyboard and IME agent.
    /// </summary>
    public bool MutableTextUnderCursor;
    
    /// <summary>
    /// This is set if, and only if, the user is currently editing text.
    /// 
    /// Useful for IME.
    /// </summary>
    public IMEOutput? Ime;
    
    /// <summary>
    /// How many ui passes is this the sum of?
    /// 
    /// See <c>RequestDiscard</c> for details.
    /// 
    /// This is incremented at the END of each frame,
    /// so this will be <c>0</c> for the first pass.
    /// </summary>
    public nuint NumCompletedPasses;
    
    /* UNIMPLEMENTED (field) 
    /// <summary>
    /// Was <c>RequestDiscard</c> called during the latest pass?
    /// 
    /// If so, what was the reason(s) for it?
    /// 
    /// If empty, there was never any calls.
    /// </summary>
    public List<RepaintCause> RequestDiscardReasons;
    */
    
    public string EventsDescription() {
        Egui.platform_output_events_description();
    
    }
    
    public void Append(PlatformOutput newer) {
        Egui.platform_output_append(TODO_ARG(newer));
    
    }
    
    public PlatformOutput Take() {
        Egui.platform_output_take();
    
    }
    
    public bool RequestedDiscard() {
        Egui.platform_output_requested_discard();
    
    }
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static PlatformOutput operator(EguiPlatformOutput value) => new PlatformOutput {
        Commands = VEC_CONV_TODO(value.commands),
        CursorIcon = value.cursor_icon.Cast<EguiCursorIcon, CursorIcon>(),
        OpenUrl = value.open_url.has_value ? (EguiOpenUrl)value.open_url.value : null,
        CopiedText = STRING_CONV_TODO,
        Events = VEC_CONV_TODO(value.events),
        MutableTextUnderCursor = value.mutable_text_under_cursor,
        Ime = value.ime.has_value ? (EguiIMEOutput)value.ime.value : null,
        NumCompletedPasses = value.num_completed_passes,
        RequestDiscardReasons = VEC_CONV_TODO(value.request_discard_reasons),
    }
    */
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiPlatformOutput operator(PlatformOutput value) => new EguiPlatformOutput {
        commands = VEC_CONV_TODO(value.Commands),
        cursor_icon = value.CursorIcon.Cast<CursorIcon, EguiCursorIcon>(),
        open_url = new EguiOptionOpenUrl {
            has_value = value.OpenUrl.HasValue,
            value = value.OpenUrl.GetValueOrDefault(),
        },
        copied_text = STRING_CONV_TODO,
        events = VEC_CONV_TODO(value.Events),
        mutable_text_under_cursor = value.MutableTextUnderCursor,
        ime = new EguiOptionImeOutput {
            has_value = value.Ime.HasValue,
            value = value.Ime.GetValueOrDefault(),
        },
        num_completed_passes = value.NumCompletedPasses,
        request_discard_reasons = VEC_CONV_TODO(value.RequestDiscardReasons),
    }
    */
}

/// <summary>
/// What the integrations provides to egui at the start of each frame.
/// 
/// Set the values that make sense, leave the rest at their <c>Default()</c>.
/// 
/// You can check if <c>Egui</c> is using the inputs using
/// <c>WantsPointerInput</c> and <c>WantsKeyboardInput</c>.
/// 
/// All coordinates are in points (logical pixels) with origin (0, 0) in the top left .corner.
/// 
/// Ii "points" can be calculated from native physical pixels
/// using <c>PixelsPerPoint</c> = <c>ZoomFactor</c> * <c>NativePixelsPerPoint</c>;
/// </summary>
public unsafe partial struct RawInput {
    /// <summary>
    /// Returns the "default value" for a type.
    /// </summary>
    public static readonly RawInput Default = (RawInput)Egui.raw_input_default();

    /* UNIMPLEMENTED (field) 
    /// <summary>
    /// The id of the active viewport.
    /// </summary>
    public crate::ViewportId ViewportId;
    */
    
    /* UNIMPLEMENTED (field) 
    /// <summary>
    /// Information about all egui viewports.
    /// </summary>
    public crate::ViewportIdMap Viewports;
    */
    
    /// <summary>
    /// Position and size of the area that egui should use, in points.
    /// Usually you would set this to
    /// 
    /// <c>Default(),ScreenSizeInPoints))</c>.
    /// 
    /// but you could also constrain egui to some smaller portion of your window if you like.
    /// 
    /// <c>None</c> will be treated as "same as last frame", with the default being a very big area.
    /// </summary>
    public Rect? ScreenRect;
    
    /// <summary>
    /// Maximum size of one side of the font texture.
    /// 
    /// Ask your graphics drivers about this. This corresponds to <c>GlMaxTextureSize</c>.
    /// 
    /// The default is a very small (but very portable) 2048.
    /// </summary>
    public nuint? MaxTextureSide;
    
    /// <summary>
    /// Monotonically increasing time, in seconds. Relative to whatever. Used for animations.
    /// If <c>None</c> is provided, egui will assume a time delta of <c>PredictedDt</c> (default 1/60 seconds).
    /// </summary>
    public double? Time;
    
    /// <summary>
    /// Should be set to the expected time between frames when painting at vsync speeds.
    /// The default for this is 1/60.
    /// Can safely be left at its default value.
    /// </summary>
    public float PredictedDt;
    
    /// <summary>
    /// Which modifier keys are down at the start of the frame?
    /// </summary>
    public Modifiers Modifiers;
    
    /* UNIMPLEMENTED (field) 
    /// <summary>
    /// In-order events received this frame.
    /// 
    /// There is currently no way to know if egui handles a particular event,
    /// but you can check if egui is using the keyboard with <c>WantsKeyboardInput</c>
    /// and/or the pointer (mouse/touch) with <c>IsUsingPointer</c>.
    /// </summary>
    public List<Event> Events;
    */
    
    /* UNIMPLEMENTED (field) 
    /// <summary>
    /// Dragged files hovering over egui.
    /// </summary>
    public List<HoveredFile> HoveredFiles;
    */
    
    /* UNIMPLEMENTED (field) 
    /// <summary>
    /// Dragged files dropped into egui.
    /// 
    /// Note: when using <c>Eframe</c> on Windows, this will always be empty if drag-and-drop support has
    /// been disabled in <c>ViewportBuilder</c>.
    /// </summary>
    public List<DroppedFile> DroppedFiles;
    */
    
    /// <summary>
    /// The native window has the keyboard focus (i.e. is receiving key presses).
    /// 
    /// False when the user alt-tab away from the application, for instance.
    /// </summary>
    public bool Focused;
    
    /// <summary>
    /// Does the OS use dark or light mode?
    /// 
    /// <c>None</c> means "don't know".
    /// </summary>
    public Theme? SystemTheme;
    
    public ViewportInfo Viewport() {
        Egui.raw_input_viewport();
    
    }
    
    public RawInput Take() {
        Egui.raw_input_take();
    
    }
    
    public void Append(RawInput newer) {
        Egui.raw_input_append(TODO_ARG(newer));
    
    }
    
    public void Ui(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "crate::Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui) {
        Egui.raw_input_ui(TODO_ARG(ui));
    
    }
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static RawInput operator(EguiRawInput value) => new RawInput {
        ViewportId = value.viewport_id,
        Viewports = value.viewports,
        ScreenRect = value.screen_rect.has_value ? (EguiRect)value.screen_rect.value : null,
        MaxTextureSide = value.max_texture_side.has_value ? value.max_texture_side.value : null,
        Time = value.time.has_value ? value.time.value : null,
        PredictedDt = value.predicted_dt,
        Modifiers = (Modifiers)value.modifiers,
        Events = VEC_CONV_TODO(value.events),
        HoveredFiles = VEC_CONV_TODO(value.hovered_files),
        DroppedFiles = VEC_CONV_TODO(value.dropped_files),
        Focused = value.focused,
        SystemTheme = value.system_theme.has_value ? value.system_theme.value.Cast<Theme, EguiTheme>() : null,
    }
    */
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiRawInput operator(RawInput value) => new EguiRawInput {
        viewport_id = value.ViewportId,
        viewports = value.Viewports,
        screen_rect = new EguiOptionRect {
            has_value = value.ScreenRect.HasValue,
            value = value.ScreenRect.GetValueOrDefault(),
        },
        max_texture_side = new EguiOptionUsize {
            has_value = value.MaxTextureSide.HasValue,
            value = value.MaxTextureSide.GetValueOrDefault(),
        },
        time = new EguiOptionF64 {
            has_value = value.Time.HasValue,
            value = value.Time.GetValueOrDefault(),
        },
        predicted_dt = value.PredictedDt,
        modifiers = (EguiModifiers)value.Modifiers,
        events = VEC_CONV_TODO(value.Events),
        hovered_files = VEC_CONV_TODO(value.HoveredFiles),
        dropped_files = VEC_CONV_TODO(value.DroppedFiles),
        focused = value.Focused,
        system_theme = new EguiOptionTheme {
            has_value = value.SystemTheme.HasValue,
            value = value.SystemTheme.GetValueOrDefault(),
        },
    }
    */
}

/// <summary>
/// What called <c>RequestRepaint</c> or <c>RequestDiscard</c>?
/// </summary>
public unsafe partial struct RepaintCause {
    /* UNIMPLEMENTED (field) 
    /// <summary>
    /// What file had the call that requested the repaint?
    /// </summary>
    public str File;
    */
    
    /// <summary>
    /// What line number of the call that requested the repaint?
    /// </summary>
    public uint Line;
    
    /* UNIMPLEMENTED (field) 
    /// <summary>
    /// Explicit reason; human readable.
    /// </summary>
    public std::borrow::Cow Reason;
    */
    
    public RepaintCause() {
        Egui.repaint_cause_new();
    
    }
    
    public static RepaintCause NewReason(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Cow", id: Id(1271), args: Some(AngleBracketed { args: [Lifetime("'static"), Type(Primitive("str"))], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) reason) {
        Egui.repaint_cause_new_reason(TODO_ARG(reason));
    
    }
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static RepaintCause operator(EguiRepaintCause value) => new RepaintCause {
        File = value.file,
        Line = value.line,
        Reason = value.reason,
    }
    */
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiRepaintCause operator(RepaintCause value) => new EguiRepaintCause {
        file = value.File,
        line = value.Line,
        reason = value.Reason,
    }
    */
}

/// <summary>
/// Information given to the backend about when it is time to repaint the ui.
/// 
/// This is given in the callback set by <c>SetRequestRepaintCallback</c>.
/// </summary>
public unsafe partial struct RequestRepaintInfo {
    /* UNIMPLEMENTED (field) 
    /// <summary>
    /// This is used to specify what viewport that should repaint.
    /// </summary>
    public crate::ViewportId ViewportId;
    */
    
    /// <summary>
    /// Repaint after this duration. If zero, repaint as soon as possible.
    /// </summary>
    public TimeSpan Delay;
    
    /// <summary>
    /// The number of fully completed passes, of the entire lifetime of the <c>Context</c>.
    /// 
    /// This can be compared to <c>CumulativePassNr</c> to see if we we still
    /// need another repaint (ui pass / frame), or if one has already happened.
    /// </summary>
    public ulong CurrentCumulativePassNr;
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static RequestRepaintInfo operator(EguiRequestRepaintInfo value) => new RequestRepaintInfo {
        ViewportId = value.viewport_id,
        Delay = TimeSpan.FromSeconds(value.delay / Egui.TIME_SECOND),
        CurrentCumulativePassNr = value.current_cumulative_pass_nr,
    }
    */
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiRequestRepaintInfo operator(RequestRepaintInfo value) => new EguiRequestRepaintInfo {
        viewport_id = value.ViewportId,
        delay = Egui.TIME_SECOND * value.Delay.TotalSeconds,
        current_cumulative_pass_nr = value.CurrentCumulativePassNr,
    }
    */
}

public unsafe partial struct RowVertexIndices {
    public nuint Row;
    
    /* UNIMPLEMENTED (field) 
    public Array { type_: Primitive("u32"), len: "6" } VertexIndices;
    */
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static RowVertexIndices operator(EguiRowVertexIndices value) => new RowVertexIndices {
        Row = value.row,
        VertexIndices = value.vertex_indices,
    }
    */
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiRowVertexIndices operator(RowVertexIndices value) => new EguiRowVertexIndices {
        row = value.Row,
        vertex_indices = value.VertexIndices,
    }
    */
}

/// <summary>
/// Scroll animation configuration, used when programmatically scrolling somewhere (e.g. with <c>ScrollToCursor</c>)
/// The animation duration is calculated based on the distance to be scrolled via <c>PointsPerSecond</c>
/// and can be clamped to a min / max duration via <c>Duration</c>.
/// </summary>
public unsafe partial struct ScrollAnimation {
    /// <summary>
    /// Returns the "default value" for a type.
    /// </summary>
    public static readonly ScrollAnimation Default = (ScrollAnimation)Egui.scroll_animation_default();

    /// <summary>
    /// With what speed should we scroll? (Default: 1000.0)
    /// </summary>
    public float PointsPerSecond;
    
    /// <summary>
    /// The min / max scroll duration.
    /// </summary>
    public Rangef Duration;
    
    public ScrollAnimation(float pointsPerSecond, Rangef duration) {
        Egui.scroll_animation_new(TODO_ARG(pointsPerSecond), TODO_ARG(duration));
    
    }
    
    public static ScrollAnimation None() {
        Egui.scroll_animation_none();
    
    }
    
    public static ScrollAnimation Duration(float t) {
        Egui.scroll_animation_duration(TODO_ARG(t));
    
    }
    
    public void Ui(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "crate::Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui) {
        Egui.scroll_animation_ui(TODO_ARG(ui));
    
    }
    
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static ScrollAnimation operator(EguiScrollAnimation value) => new ScrollAnimation {
        PointsPerSecond = value.points_per_second,
        Duration = (Rangef)value.duration,
    }
    
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiScrollAnimation operator(ScrollAnimation value) => new EguiScrollAnimation {
        points_per_second = value.PointsPerSecond,
        duration = (EguiRangef)value.Duration,
    }
}

/// <summary>
/// Controls the spacing and visuals of a <c>ScrollArea</c>.
/// 
/// There are three presets to chose from:
/// * <c>Solid</c>
/// * <c>Thin</c>
/// * <c>Floating</c>
/// </summary>
public unsafe partial struct ScrollStyle {
    /// <summary>
    /// Returns the "default value" for a type.
    /// </summary>
    public static readonly ScrollStyle Default = (ScrollStyle)Egui.scroll_style_default();

    /// <summary>
    /// If <c>True</c>, scroll bars float above the content, partially covering it.
    /// 
    /// If <c>False</c>, the scroll bars allocate space, shrinking the area
    /// available to the contents.
    /// 
    /// This also changes the colors of the scroll-handle to make
    /// it more promiment.
    /// </summary>
    public bool Floating;
    
    /// <summary>
    /// The width of the scroll bars at it largest.
    /// </summary>
    public float BarWidth;
    
    /// <summary>
    /// Make sure the scroll handle is at least this big
    /// </summary>
    public float HandleMinLength;
    
    /// <summary>
    /// Margin between contents and scroll bar.
    /// </summary>
    public float BarInnerMargin;
    
    /// <summary>
    /// Margin between scroll bar and the outer container (e.g. right of a vertical scroll bar).
    /// Only makes sense for non-floating scroll bars.
    /// </summary>
    public float BarOuterMargin;
    
    /// <summary>
    /// The thin width of floating scroll bars that the user is NOT hovering.
    /// 
    /// When the user hovers the scroll bars they expand to <c>BarWidth</c>.
    /// </summary>
    public float FloatingWidth;
    
    /// <summary>
    /// How much space is allocated for a floating scroll bar?
    /// 
    /// Normally this is zero, but you could set this to something small
    /// like 4.0 and set <c>DormantHandleOpacity</c> and
    /// <c>DormantBackgroundOpacity</c> to e.g. 0.5
    /// so as to always show a thin scroll bar.
    /// </summary>
    public float FloatingAllocatedWidth;
    
    /// <summary>
    /// If true, use colors with more contrast. Good for floating scroll bars.
    /// </summary>
    public bool ForegroundColor;
    
    /// <summary>
    /// The opaqueness of the background when the user is neither scrolling
    /// nor hovering the scroll area.
    /// 
    /// This is only for floating scroll bars.
    /// Solid scroll bars are always opaque.
    /// </summary>
    public float DormantBackgroundOpacity;
    
    /// <summary>
    /// The opaqueness of the background when the user is hovering
    /// the scroll area, but not the scroll bar.
    /// 
    /// This is only for floating scroll bars.
    /// Solid scroll bars are always opaque.
    /// </summary>
    public float ActiveBackgroundOpacity;
    
    /// <summary>
    /// The opaqueness of the background when the user is hovering
    /// over the scroll bars.
    /// 
    /// This is only for floating scroll bars.
    /// Solid scroll bars are always opaque.
    /// </summary>
    public float InteractBackgroundOpacity;
    
    /// <summary>
    /// The opaqueness of the handle when the user is neither scrolling
    /// nor hovering the scroll area.
    /// 
    /// This is only for floating scroll bars.
    /// Solid scroll bars are always opaque.
    /// </summary>
    public float DormantHandleOpacity;
    
    /// <summary>
    /// The opaqueness of the handle when the user is hovering
    /// the scroll area, but not the scroll bar.
    /// 
    /// This is only for floating scroll bars.
    /// Solid scroll bars are always opaque.
    /// </summary>
    public float ActiveHandleOpacity;
    
    /// <summary>
    /// The opaqueness of the handle when the user is hovering
    /// over the scroll bars.
    /// 
    /// This is only for floating scroll bars.
    /// Solid scroll bars are always opaque.
    /// </summary>
    public float InteractHandleOpacity;
    
    public static ScrollStyle Solid() {
        Egui.scroll_style_solid();
    
    }
    
    public static ScrollStyle Thin() {
        Egui.scroll_style_thin();
    
    }
    
    public static ScrollStyle Floating() {
        Egui.scroll_style_floating();
    
    }
    
    public float AllocatedWidth() {
        Egui.scroll_style_allocated_width();
    
    }
    
    public void Ui(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui) {
        Egui.scroll_style_ui(TODO_ARG(ui));
    
    }
    
    public void DetailsUi(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui) {
        Egui.scroll_style_details_ui(TODO_ARG(ui));
    
    }
    
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static ScrollStyle operator(EguiScrollStyle value) => new ScrollStyle {
        Floating = value.floating,
        BarWidth = value.bar_width,
        HandleMinLength = value.handle_min_length,
        BarInnerMargin = value.bar_inner_margin,
        BarOuterMargin = value.bar_outer_margin,
        FloatingWidth = value.floating_width,
        FloatingAllocatedWidth = value.floating_allocated_width,
        ForegroundColor = value.foreground_color,
        DormantBackgroundOpacity = value.dormant_background_opacity,
        ActiveBackgroundOpacity = value.active_background_opacity,
        InteractBackgroundOpacity = value.interact_background_opacity,
        DormantHandleOpacity = value.dormant_handle_opacity,
        ActiveHandleOpacity = value.active_handle_opacity,
        InteractHandleOpacity = value.interact_handle_opacity,
    }
    
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiScrollStyle operator(ScrollStyle value) => new EguiScrollStyle {
        floating = value.Floating,
        bar_width = value.BarWidth,
        handle_min_length = value.HandleMinLength,
        bar_inner_margin = value.BarInnerMargin,
        bar_outer_margin = value.BarOuterMargin,
        floating_width = value.FloatingWidth,
        floating_allocated_width = value.FloatingAllocatedWidth,
        foreground_color = value.ForegroundColor,
        dormant_background_opacity = value.DormantBackgroundOpacity,
        active_background_opacity = value.ActiveBackgroundOpacity,
        interact_background_opacity = value.InteractBackgroundOpacity,
        dormant_handle_opacity = value.DormantHandleOpacity,
        active_handle_opacity = value.ActiveHandleOpacity,
        interact_handle_opacity = value.InteractHandleOpacity,
    }
}

/// <summary>
/// Selected text, selected elements etc
/// </summary>
public unsafe partial struct Selection {
    /// <summary>
    /// Returns the "default value" for a type.
    /// </summary>
    public static readonly Selection Default = (Selection)Egui.selection_default();

    public Color32 BgFill;
    
    public Stroke Stroke;
    
    public void Ui(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "crate::Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui) {
        Egui.selection_ui(TODO_ARG(ui));
    
    }
    
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static Selection operator(EguiSelection value) => new Selection {
        BgFill = (Color32)value.bg_fill,
        Stroke = (Stroke)value.stroke,
    }
    
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiSelection operator(Selection value) => new EguiSelection {
        bg_fill = (EguiColor32)value.BgFill,
        stroke = (EguiStroke)value.Stroke,
    }
}

public unsafe partial struct Settings {
    /// <summary>
    /// Returns the "default value" for a type.
    /// </summary>
    public static readonly Settings Default = (Settings)Egui.settings_default();

    /// <summary>
    /// Maximum number of undos.
    /// If your state is resource intensive, you should keep this low.
    /// 
    /// Default: <c>100</c>
    /// </summary>
    public nuint MaxUndos;
    
    /// <summary>
    /// When that state hasn't changed for this many seconds,
    /// create a new undo point (if one is needed).
    /// 
    /// Default value: <c>1.0</c> seconds.
    /// </summary>
    public float StableTime;
    
    /// <summary>
    /// If the state is changing so often that we never get to <c>StableTime</c>,
    /// then still create a save point every <c>AutoSaveInterval</c> seconds,
    /// so we have something to undo to.
    /// 
    /// Default value: <c>30</c> seconds.
    /// </summary>
    public float AutoSaveInterval;
    
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static Settings operator(EguiSettings value) => new Settings {
        MaxUndos = value.max_undos,
        StableTime = value.stable_time,
        AutoSaveInterval = value.auto_save_interval,
    }
    
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiSettings operator(Settings value) => new EguiSettings {
        max_undos = value.MaxUndos,
        stable_time = value.StableTime,
        auto_save_interval = value.AutoSaveInterval,
    }
}

/// <summary>
/// A texture with a known size.
/// </summary>
public unsafe partial struct SizedTexture {
    public TextureId Id;
    
    public Vec2 Size;
    
    public SizedTexture(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "TextureId", id: Id(3499), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) id, ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Vec2", id: Id(150), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) size) {
        Egui.sized_texture_new(TODO_ARG(id), TODO_ARG(size));
    
    }
    
    public static SizedTexture FromHandle(TextureHandle handle) {
        Egui.sized_texture_from_handle(TODO_ARG(handle));
    
    }
    
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static SizedTexture operator(EguiSizedTexture value) => new SizedTexture {
        Id = (TextureId)value.id,
        Size = (Vec2)value.size,
    }
    
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiSizedTexture operator(SizedTexture value) => new EguiSizedTexture {
        id = (EguiTextureId)value.Id,
        size = (EguiVec2)value.Size,
    }
}

/// <summary>
/// Controls the sizes and distances between widgets.
/// </summary>
public unsafe partial struct Spacing {
    /// <summary>
    /// Returns the "default value" for a type.
    /// </summary>
    public static readonly Spacing Default = (Spacing)Egui.spacing_default();

    /// <summary>
    /// Horizontal and vertical spacing between widgets.
    /// 
    /// To add extra space between widgets, use <c>AddSpace</c>.
    /// 
    /// <c>ItemSpacing</c> is inserted _after_ adding a widget, so to increase the spacing between
    /// widgets <c>A</c> and <c>B</c> you need to change <c>ItemSpacing</c> before adding <c>A</c>.
    /// </summary>
    public Vec2 ItemSpacing;
    
    /// <summary>
    /// Horizontal and vertical margins within a window frame.
    /// </summary>
    public Margin WindowMargin;
    
    /// <summary>
    /// Button size is text size plus this on each side
    /// </summary>
    public Vec2 ButtonPadding;
    
    /// <summary>
    /// Horizontal and vertical margins within a menu frame.
    /// </summary>
    public Margin MenuMargin;
    
    /// <summary>
    /// Indent collapsing regions etc by this much.
    /// </summary>
    public float Indent;
    
    /// <summary>
    /// Minimum size of a <c>DragValue</c>, color picker button, and other small widgets.
    /// <c>InteractSize.y</c> is the default height of button, slider, etc.
    /// Anything clickable should be (at least) this size.
    /// </summary>
    public Vec2 InteractSize;
    
    /// <summary>
    /// Default width of a <c>Slider</c>.
    /// </summary>
    public float SliderWidth;
    
    /// <summary>
    /// Default rail height of a <c>Slider</c>.
    /// </summary>
    public float SliderRailHeight;
    
    /// <summary>
    /// Default (minimum) width of a <c>ComboBox</c>.
    /// </summary>
    public float ComboWidth;
    
    /// <summary>
    /// Default width of a <c>TextEdit</c>.
    /// </summary>
    public float TextEditWidth;
    
    /// <summary>
    /// Checkboxes, radio button and collapsing headers have an icon at the start.
    /// This is the width/height of the outer part of this icon (e.g. the BOX of the checkbox).
    /// </summary>
    public float IconWidth;
    
    /// <summary>
    /// Checkboxes, radio button and collapsing headers have an icon at the start.
    /// This is the width/height of the inner part of this icon (e.g. the check of the checkbox).
    /// </summary>
    public float IconWidthInner;
    
    /// <summary>
    /// Checkboxes, radio button and collapsing headers have an icon at the start.
    /// This is the spacing between the icon and the text
    /// </summary>
    public float IconSpacing;
    
    /// <summary>
    /// The size used for the <c>MaxRect</c> the first frame.
    /// 
    /// Text will wrap at this width, and images that expand to fill the available space
    /// will expand to this size.
    /// 
    /// If the contents are smaller than this size, the area will shrink to fit the contents.
    /// If the contents overflow, the area will grow.
    /// </summary>
    public Vec2 DefaultAreaSize;
    
    /// <summary>
    /// Width of a tooltip (<c>OnHoverUi</c>, <c>OnHoverText</c> etc).
    /// </summary>
    public float TooltipWidth;
    
    /// <summary>
    /// The default wrapping width of a menu.
    /// 
    /// Items longer than this will wrap to a new line.
    /// </summary>
    public float MenuWidth;
    
    /// <summary>
    /// Horizontal distance between a menu and a submenu.
    /// </summary>
    public float MenuSpacing;
    
    /// <summary>
    /// End indented regions with a horizontal line
    /// </summary>
    public bool IndentEndsWithHorizontalLine;
    
    /// <summary>
    /// Height of a combo-box before showing scroll bars.
    /// </summary>
    public float ComboHeight;
    
    /// <summary>
    /// Controls the spacing of a <c>ScrollArea</c>.
    /// </summary>
    public ScrollStyle Scroll;
    
    public Tuple([ResolvedPath(Path { path: "Rect", id: Id(162), args: Some(AngleBracketed { args: [], constraints: [] }) }), ResolvedPath(Path { path: "Rect", id: Id(162), args: Some(AngleBracketed { args: [], constraints: [] }) })]) IconRectangles(Rect rect) {
        Egui.spacing_icon_rectangles(TODO_ARG(rect));
    
    }
    
    public void Ui(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "crate::Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui) {
        Egui.spacing_ui(TODO_ARG(ui));
    
    }
    
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static Spacing operator(EguiSpacing value) => new Spacing {
        ItemSpacing = (Vec2)value.item_spacing,
        WindowMargin = (Margin)value.window_margin,
        ButtonPadding = (Vec2)value.button_padding,
        MenuMargin = (Margin)value.menu_margin,
        Indent = value.indent,
        InteractSize = (Vec2)value.interact_size,
        SliderWidth = value.slider_width,
        SliderRailHeight = value.slider_rail_height,
        ComboWidth = value.combo_width,
        TextEditWidth = value.text_edit_width,
        IconWidth = value.icon_width,
        IconWidthInner = value.icon_width_inner,
        IconSpacing = value.icon_spacing,
        DefaultAreaSize = (Vec2)value.default_area_size,
        TooltipWidth = value.tooltip_width,
        MenuWidth = value.menu_width,
        MenuSpacing = value.menu_spacing,
        IndentEndsWithHorizontalLine = value.indent_ends_with_horizontal_line,
        ComboHeight = value.combo_height,
        Scroll = (ScrollStyle)value.scroll,
    }
    
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiSpacing operator(Spacing value) => new EguiSpacing {
        item_spacing = (EguiVec2)value.ItemSpacing,
        window_margin = (EguiMargin)value.WindowMargin,
        button_padding = (EguiVec2)value.ButtonPadding,
        menu_margin = (EguiMargin)value.MenuMargin,
        indent = value.Indent,
        interact_size = (EguiVec2)value.InteractSize,
        slider_width = value.SliderWidth,
        slider_rail_height = value.SliderRailHeight,
        combo_width = value.ComboWidth,
        text_edit_width = value.TextEditWidth,
        icon_width = value.IconWidth,
        icon_width_inner = value.IconWidthInner,
        icon_spacing = value.IconSpacing,
        default_area_size = (EguiVec2)value.DefaultAreaSize,
        tooltip_width = value.TooltipWidth,
        menu_width = value.MenuWidth,
        menu_spacing = value.MenuSpacing,
        indent_ends_with_horizontal_line = value.IndentEndsWithHorizontalLine,
        combo_height = value.ComboHeight,
        scroll = (EguiScrollStyle)value.Scroll,
    }
}

/// <summary>
/// Specifies the look and feel of egui.
/// 
/// You can change the visuals of a <c>Ui</c> with <c>StyleMut</c>
/// and of everything with <c>SetStyleOf</c>.
/// To choose between dark and light style, use <c>SetTheme</c>.
/// 
/// If you want to change fonts, use <c>SetFonts</c> instead.
/// </summary>
public unsafe partial struct Style {
    /// <summary>
    /// Returns the "default value" for a type.
    /// </summary>
    public static readonly Style Default = (Style)Egui.style_default();

    /* UNIMPLEMENTED (field) 
    /// <summary>
    /// If set this will change the default <c>TextStyle</c> for all widgets.
    /// 
    /// On most widgets you can also set an explicit text style,
    /// which will take precedence over this.
    /// </summary>
    public TextStyle? OverrideTextStyle;
    */
    
    /* UNIMPLEMENTED (field) 
    /// <summary>
    /// If set this will change the font family and size for all widgets.
    /// 
    /// On most widgets you can also set an explicit text style,
    /// which will take precedence over this.
    /// </summary>
    public crate::FontId? OverrideFontId;
    */
    
    /// <summary>
    /// How to vertically align text.
    /// 
    /// Set to <c>None</c> to use align that depends on the current layout.
    /// </summary>
    public Align? OverrideTextValign;
    
    /* UNIMPLEMENTED (field) 
    /// <summary>
    /// The <c>FontFamily</c> and size you want to use for a specific <c>TextStyle</c>.
    /// 
    /// The most convenient way to look something up in this is to use <c>Resolve</c>.
    /// 
    /// If you would like to overwrite app <c>TextStyles</c>
    /// </summary>
    public std::collections::BTreeMap TextStyles;
    */
    
    /* UNIMPLEMENTED (field) 
    /// <summary>
    /// The style to use for <c>DragValue</c> text.
    /// </summary>
    public TextStyle DragValueTextStyle;
    */
    
    /* UNIMPLEMENTED (field) 
    /// <summary>
    /// How to format numbers as strings, e.g. in a <c>DragValue</c>.
    /// 
    /// You can override this to e.g. add thousands separators.
    /// </summary>
    public NumberFormatter NumberFormatter;
    */
    
    /// <summary>
    /// If set, labels, buttons, etc. will use this to determine whether to wrap the text at the
    /// right edge of the <c>Ui</c> they are in. By default, this is <c>None</c>.
    /// 
    /// **Note**: this API is deprecated, use <c>WrapMode</c> instead.
    /// 
    /// * <c>None</c>: use <c>WrapMode</c> instead
    /// * <c>Some(true)</c>: wrap mode defaults to <c>Wrap</c>
    /// * <c>Some(false)</c>: wrap mode defaults to <c>Extend</c>
    /// </summary>
    public bool? Wrap;
    
    /* UNIMPLEMENTED (field) 
    /// <summary>
    /// If set, labels, buttons, etc. will use this to determine whether to wrap or truncate the
    /// text at the right edge of the <c>Ui</c> they are in, or to extend it. By default, this is
    /// <c>None</c>.
    /// 
    /// * <c>None</c>: follow layout (with may wrap)
    /// * <c>Some(mode)</c>: use the specified mode as default
    /// </summary>
    public crate::TextWrapMode? WrapMode;
    */
    
    /// <summary>
    /// Sizes and distances between widgets
    /// </summary>
    public Spacing Spacing;
    
    /// <summary>
    /// How and when interaction happens.
    /// </summary>
    public Interaction Interaction;
    
    /// <summary>
    /// Colors etc.
    /// </summary>
    public Visuals Visuals;
    
    /// <summary>
    /// How many seconds a typical animation should last.
    /// </summary>
    public float AnimationTime;
    
    /// <summary>
    /// Options to help debug why egui behaves strangely.
    /// 
    /// Only available in debug builds.
    /// </summary>
    public DebugOptions Debug;
    
    /// <summary>
    /// Show tooltips explaining <c>DragValue</c>:s etc when hovered.
    /// 
    /// This only affects a few egui widgets.
    /// </summary>
    public bool ExplanationTooltips;
    
    /// <summary>
    /// Show the URL of hyperlinks in a tooltip when hovered.
    /// </summary>
    public bool UrlInTooltip;
    
    /// <summary>
    /// If true and scrolling is enabled for only one direction, allow horizontal scrolling without pressing shift
    /// </summary>
    public bool AlwaysScrollTheOnlyDirection;
    
    /// <summary>
    /// The animation that should be used when scrolling a <c>ScrollArea</c> using e.g. <c>ScrollToRect</c>.
    /// </summary>
    public ScrollAnimation ScrollAnimation;
    
    public WidgetVisuals Interact(Response response) {
        Egui.style_interact(TODO_ARG(response));
    
    }
    
    public WidgetVisuals InteractSelectable(Response response, bool selected) {
        Egui.style_interact_selectable(TODO_ARG(response), TODO_ARG(selected));
    
    }
    
    public WidgetVisuals Noninteractive() {
        Egui.style_noninteractive();
    
    }
    
    public List<TextStyle> TextStyles() {
        Egui.style_text_styles();
    
    }
    
    public void Ui(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "crate::Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui) {
        Egui.style_ui(TODO_ARG(ui));
    
    }
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static Style operator(EguiStyle value) => new Style {
        OverrideTextStyle = value.override_text_style.has_value ? value.override_text_style.value : null,
        OverrideFontId = value.override_font_id.has_value ? value.override_font_id.value : null,
        OverrideTextValign = value.override_text_valign.has_value ? (EguiAlign)value.override_text_valign.value : null,
        TextStyles = value.text_styles,
        DragValueTextStyle = value.drag_value_text_style,
        NumberFormatter = value.number_formatter,
        Wrap = value.wrap.has_value ? value.wrap.value : null,
        WrapMode = value.wrap_mode.has_value ? value.wrap_mode.value : null,
        Spacing = (Spacing)value.spacing,
        Interaction = (Interaction)value.interaction,
        Visuals = (Visuals)value.visuals,
        AnimationTime = value.animation_time,
        Debug = (DebugOptions)value.debug,
        ExplanationTooltips = value.explanation_tooltips,
        UrlInTooltip = value.url_in_tooltip,
        AlwaysScrollTheOnlyDirection = value.always_scroll_the_only_direction,
        ScrollAnimation = (ScrollAnimation)value.scroll_animation,
    }
    */
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiStyle operator(Style value) => new EguiStyle {
        override_text_style = new EguiOptionTextStyle {
            has_value = value.OverrideTextStyle.HasValue,
            value = value.OverrideTextStyle.GetValueOrDefault(),
        },
        override_font_id = new EguiOptionCrate::fontId {
            has_value = value.OverrideFontId.HasValue,
            value = value.OverrideFontId.GetValueOrDefault(),
        },
        override_text_valign = new EguiOptionAlign {
            has_value = value.OverrideTextValign.HasValue,
            value = value.OverrideTextValign.GetValueOrDefault(),
        },
        text_styles = value.TextStyles,
        drag_value_text_style = value.DragValueTextStyle,
        number_formatter = value.NumberFormatter,
        wrap = new EguiOptionBool {
            has_value = value.Wrap.HasValue,
            value = value.Wrap.GetValueOrDefault(),
        },
        wrap_mode = new EguiOptionCrate::textWrapMode {
            has_value = value.WrapMode.HasValue,
            value = value.WrapMode.GetValueOrDefault(),
        },
        spacing = (EguiSpacing)value.Spacing,
        interaction = (EguiInteraction)value.Interaction,
        visuals = (EguiVisuals)value.Visuals,
        animation_time = value.AnimationTime,
        debug = (EguiDebugOptions)value.Debug,
        explanation_tooltips = value.ExplanationTooltips,
        url_in_tooltip = value.UrlInTooltip,
        always_scroll_the_only_direction = value.AlwaysScrollTheOnlyDirection,
        scroll_animation = (EguiScrollAnimation)value.ScrollAnimation,
    }
    */
}

/// <summary>
/// Look and feel of the text cursor.
/// </summary>
public unsafe partial struct TextCursorStyle {
    /// <summary>
    /// Returns the "default value" for a type.
    /// </summary>
    public static readonly TextCursorStyle Default = (TextCursorStyle)Egui.text_cursor_style_default();

    /// <summary>
    /// The color and width of the text cursor
    /// </summary>
    public Stroke Stroke;
    
    /// <summary>
    /// Show where the text cursor would be if you clicked?
    /// </summary>
    public bool Preview;
    
    /// <summary>
    /// Should the cursor blink?
    /// </summary>
    public bool Blink;
    
    /// <summary>
    /// When blinking, this is how long the cursor is visible.
    /// </summary>
    public float OnDuration;
    
    /// <summary>
    /// When blinking, this is how long the cursor is invisible.
    /// </summary>
    public float OffDuration;
    
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static TextCursorStyle operator(EguiTextCursorStyle value) => new TextCursorStyle {
        Stroke = (Stroke)value.stroke,
        Preview = value.preview,
        Blink = value.blink,
        OnDuration = value.on_duration,
        OffDuration = value.off_duration,
    }
    
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiTextCursorStyle operator(TextCursorStyle value) => new EguiTextCursorStyle {
        stroke = (EguiStroke)value.Stroke,
        preview = value.Preview,
        blink = value.Blink,
        on_duration = value.OnDuration,
        off_duration = value.OffDuration,
    }
}

/// <summary>
/// Build a <c>Ui</c> as the child of another <c>Ui</c>.
/// 
/// By default, everything is inherited from the parent,
/// except for <c>MaxRect</c> which by default is set to
/// the parent <c>AvailableRectBeforeWrap</c>.
/// </summary>
public unsafe partial struct UiBuilder {
    /// <summary>
    /// Returns the "default value" for a type.
    /// </summary>
    public static readonly UiBuilder Default = (UiBuilder)Egui.ui_builder_default();

    public Id? IdSalt;
    
    public UiStackInfo UiStackInfo;
    
    public LayerId? LayerId;
    
    public Rect? MaxRect;
    
    public Layout? Layout;
    
    public bool Disabled;
    
    public bool Invisible;
    
    public bool SizingPass;
    
    /* UNIMPLEMENTED (field) 
    public std::sync::Arc? Style;
    */
    
    public Sense? Sense;
    
    public UiBuilder() {
        Egui.ui_builder_new();
    
    }
    
    public UiBuilder IdSalt(ImplTrait([TraitBound { trait_: Path { path: "Hash", id: Id(83), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) idSalt) {
        Egui.ui_builder_id_salt(TODO_ARG(idSalt));
    
    }
    
    public UiBuilder UiStackInfo(UiStackInfo uiStackInfo) {
        Egui.ui_builder_ui_stack_info(TODO_ARG(uiStackInfo));
    
    }
    
    public UiBuilder LayerId(LayerId layerId) {
        Egui.ui_builder_layer_id(TODO_ARG(layerId));
    
    }
    
    public UiBuilder MaxRect(Rect maxRect) {
        Egui.ui_builder_max_rect(TODO_ARG(maxRect));
    
    }
    
    public UiBuilder Layout(Layout layout) {
        Egui.ui_builder_layout(TODO_ARG(layout));
    
    }
    
    public UiBuilder Disabled() {
        Egui.ui_builder_disabled();
    
    }
    
    public UiBuilder Invisible() {
        Egui.ui_builder_invisible();
    
    }
    
    public UiBuilder SizingPass() {
        Egui.ui_builder_sizing_pass();
    
    }
    
    public UiBuilder Style(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Arc", id: Id(1246), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "Style", id: Id(493), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) style) {
        Egui.ui_builder_style(TODO_ARG(style));
    
    }
    
    public UiBuilder Sense(Sense sense) {
        Egui.ui_builder_sense(TODO_ARG(sense));
    
    }
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static UiBuilder operator(EguiUiBuilder value) => new UiBuilder {
        IdSalt = value.id_salt.has_value ? (EguiId)value.id_salt.value : null,
        UiStackInfo = (UiStackInfo)value.ui_stack_info,
        LayerId = value.layer_id.has_value ? (EguiLayerId)value.layer_id.value : null,
        MaxRect = value.max_rect.has_value ? (EguiRect)value.max_rect.value : null,
        Layout = value.layout.has_value ? (EguiLayout)value.layout.value : null,
        Disabled = value.disabled,
        Invisible = value.invisible,
        SizingPass = value.sizing_pass,
        Style = value.style.has_value ? value.style.value : null,
        Sense = value.sense.has_value ? (EguiSense)value.sense.value : null,
    }
    */
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiUiBuilder operator(UiBuilder value) => new EguiUiBuilder {
        id_salt = new EguiOptionId {
            has_value = value.IdSalt.HasValue,
            value = value.IdSalt.GetValueOrDefault(),
        },
        ui_stack_info = (EguiUiStackInfo)value.UiStackInfo,
        layer_id = new EguiOptionLayerId {
            has_value = value.LayerId.HasValue,
            value = value.LayerId.GetValueOrDefault(),
        },
        max_rect = new EguiOptionRect {
            has_value = value.MaxRect.HasValue,
            value = value.MaxRect.GetValueOrDefault(),
        },
        layout = new EguiOptionLayout {
            has_value = value.Layout.HasValue,
            value = value.Layout.GetValueOrDefault(),
        },
        disabled = value.Disabled,
        invisible = value.Invisible,
        sizing_pass = value.SizingPass,
        style = new EguiOptionStd::sync::arc {
            has_value = value.Style.HasValue,
            value = value.Style.GetValueOrDefault(),
        },
        sense = new EguiOptionSense {
            has_value = value.Sense.HasValue,
            value = value.Sense.GetValueOrDefault(),
        },
    }
    */
}

/// <summary>
/// Information about a <c>Ui</c> to be included in the corresponding <c>UiStack</c>.
/// </summary>
public unsafe partial struct UiStackInfo {
    /// <summary>
    /// Returns the "default value" for a type.
    /// </summary>
    public static readonly UiStackInfo Default = (UiStackInfo)Egui.ui_stack_info_default();

    public UiKind? Kind;
    
    public Frame Frame;
    
    /* UNIMPLEMENTED (field) 
    public UiTags Tags;
    */
    
    public UiStackInfo(UiKind kind) {
        Egui.ui_stack_info_new(TODO_ARG(kind));
    
    }
    
    public UiStackInfo WithFrame(Frame frame) {
        Egui.ui_stack_info_with_frame(TODO_ARG(frame));
    
    }
    
    public UiStackInfo WithTag(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "String", id: Id(1295), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) key) {
        Egui.ui_stack_info_with_tag(TODO_ARG(key));
    
    }
    
    public UiStackInfo WithTagValue(ImplTrait([TraitBound { trait_: Path { path: "Into", id: Id(39), args: Some(AngleBracketed { args: [Type(ResolvedPath(Path { path: "String", id: Id(1295), args: Some(AngleBracketed { args: [], constraints: [] }) }))], constraints: [] }) }, generic_params: [], modifier: None }]) key, ImplTrait([TraitBound { trait_: Path { path: "Any", id: Id(23), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }, TraitBound { trait_: Path { path: "Send", id: Id(11), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }, TraitBound { trait_: Path { path: "Sync", id: Id(13), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }, Outlives("'static")]) value) {
        Egui.ui_stack_info_with_tag_value(TODO_ARG(key), TODO_ARG(value));
    
    }
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static UiStackInfo operator(EguiUiStackInfo value) => new UiStackInfo {
        Kind = value.kind.has_value ? value.kind.value.Cast<UiKind, EguiUiKind>() : null,
        Frame = (Frame)value.frame,
        Tags = value.tags,
    }
    */
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiUiStackInfo operator(UiStackInfo value) => new EguiUiStackInfo {
        kind = new EguiOptionUiKind {
            has_value = value.Kind.HasValue,
            value = value.Kind.GetValueOrDefault(),
        },
        frame = (EguiFrame)value.Frame,
        tags = value.Tags,
    }
    */
}

/// <summary>
/// A wrapper around <c>DynAny</c>, used for passing custom user data
/// to <c>Screenshot</c>.
/// </summary>
public unsafe partial struct UserData {
    /// <summary>
    /// Returns the "default value" for a type.
    /// </summary>
    public static readonly UserData Default = (UserData)Egui.user_data_default();

    /* UNIMPLEMENTED (field) 
    /// <summary>
    /// A user value given to the screenshot command,
    /// that will be returned in <c>Screenshot</c>.
    /// </summary>
    public std::sync::Arc? Data;
    */
    
    public UserData(ImplTrait([TraitBound { trait_: Path { path: "Any", id: Id(23), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }, TraitBound { trait_: Path { path: "Send", id: Id(11), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }, TraitBound { trait_: Path { path: "Sync", id: Id(13), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) userInfo) {
        Egui.user_data_new(TODO_ARG(userInfo));
    
    }
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static UserData operator(EguiUserData value) => new UserData {
        Data = value.data.has_value ? value.data.value : null,
    }
    */
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiUserData operator(UserData value) => new EguiUserData {
        data = new EguiOptionStd::sync::arc {
            has_value = value.Data.HasValue,
            value = value.Data.GetValueOrDefault(),
        },
    }
    */
}

/// <summary>
/// A pair of <c>ViewportId</c>, used to identify a viewport and its parent.
/// </summary>
public unsafe partial struct ViewportIdPair {
    /// <summary>
    /// Returns the "default value" for a type.
    /// </summary>
    public static readonly ViewportIdPair Default = (ViewportIdPair)Egui.viewport_id_pair_default();

    /* UNIMPLEMENTED (field) 
    public ViewportId This;
    */
    
    /* UNIMPLEMENTED (field) 
    public ViewportId Parent;
    */
    
    public static ViewportIdPair FromSelfAndParent(ViewportId this, ViewportId parent) {
        Egui.viewport_id_pair_from_self_and_parent(TODO_ARG(this), TODO_ARG(parent));
    
    }
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static ViewportIdPair operator(EguiViewportIdPair value) => new ViewportIdPair {
        This = value.this,
        Parent = value.parent,
    }
    */
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiViewportIdPair operator(ViewportIdPair value) => new EguiViewportIdPair {
        this = value.This,
        parent = value.Parent,
    }
    */
}

/// <summary>
/// Information about the current viewport, given as input each frame.
/// 
/// <c>None</c> means "unknown".
/// 
/// All units are in ui "points", which can be calculated from native physical pixels
/// using <c>PixelsPerPoint</c> = <c>ZoomFactor</c> * <c>NativePixelsPerPoint</c>;
/// </summary>
public unsafe partial struct ViewportInfo {
    /// <summary>
    /// Returns the "default value" for a type.
    /// </summary>
    public static readonly ViewportInfo Default = (ViewportInfo)Egui.viewport_info_default();

    /* UNIMPLEMENTED (field) 
    /// <summary>
    /// Parent viewport, if known.
    /// </summary>
    public crate::ViewportId? Parent;
    */
    
    /// <summary>
    /// Name of the viewport, if known.
    /// </summary>
    public string? Title;
    
    /* UNIMPLEMENTED (field) 
    public List<ViewportEvent> Events;
    */
    
    /// <summary>
    /// The OS native pixels-per-point.
    /// 
    /// This should always be set, if known.
    /// 
    /// On web this takes browser scaling into account,
    /// and corresponds to <c>Window.devicePixelRatio</c> in JavaScript.
    /// </summary>
    public float? NativePixelsPerPoint;
    
    /// <summary>
    /// Current monitor size in egui points.
    /// </summary>
    public Vec2? MonitorSize;
    
    /// <summary>
    /// The inner rectangle of the native window, in monitor space and ui points scale.
    /// 
    /// This is the content rectangle of the viewport.
    /// </summary>
    public Rect? InnerRect;
    
    /// <summary>
    /// The outer rectangle of the native window, in monitor space and ui points scale.
    /// 
    /// This is the content rectangle plus decoration chrome.
    /// </summary>
    public Rect? OuterRect;
    
    /// <summary>
    /// Are we minimized?
    /// </summary>
    public bool? Minimized;
    
    /// <summary>
    /// Are we maximized?
    /// </summary>
    public bool? Maximized;
    
    /// <summary>
    /// Are we in fullscreen mode?
    /// </summary>
    public bool? Fullscreen;
    
    /// <summary>
    /// Is the window focused and able to receive input?
    /// 
    /// This should be the same as <c>Focused</c>.
    /// </summary>
    public bool? Focused;
    
    public bool CloseRequested() {
        Egui.viewport_info_close_requested();
    
    }
    
    public ViewportInfo Take() {
        Egui.viewport_info_take();
    
    }
    
    public void Ui(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "crate::Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui) {
        Egui.viewport_info_ui(TODO_ARG(ui));
    
    }
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static ViewportInfo operator(EguiViewportInfo value) => new ViewportInfo {
        Parent = value.parent.has_value ? value.parent.value : null,
        Title = value.title.has_value ? STRING_CONV_TODO : null,
        Events = VEC_CONV_TODO(value.events),
        NativePixelsPerPoint = value.native_pixels_per_point.has_value ? value.native_pixels_per_point.value : null,
        MonitorSize = value.monitor_size.has_value ? (EguiVec2)value.monitor_size.value : null,
        InnerRect = value.inner_rect.has_value ? (EguiRect)value.inner_rect.value : null,
        OuterRect = value.outer_rect.has_value ? (EguiRect)value.outer_rect.value : null,
        Minimized = value.minimized.has_value ? value.minimized.value : null,
        Maximized = value.maximized.has_value ? value.maximized.value : null,
        Fullscreen = value.fullscreen.has_value ? value.fullscreen.value : null,
        Focused = value.focused.has_value ? value.focused.value : null,
    }
    */
    
    /* UNIMPLEMENTED (conversion)
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiViewportInfo operator(ViewportInfo value) => new EguiViewportInfo {
        parent = new EguiOptionCrate::viewportId {
            has_value = value.Parent.HasValue,
            value = value.Parent.GetValueOrDefault(),
        },
        title = new EguiOptionString {
            has_value = value.Title.HasValue,
            value = value.Title.GetValueOrDefault(),
        },
        events = VEC_CONV_TODO(value.Events),
        native_pixels_per_point = new EguiOptionF32 {
            has_value = value.NativePixelsPerPoint.HasValue,
            value = value.NativePixelsPerPoint.GetValueOrDefault(),
        },
        monitor_size = new EguiOptionVec2 {
            has_value = value.MonitorSize.HasValue,
            value = value.MonitorSize.GetValueOrDefault(),
        },
        inner_rect = new EguiOptionRect {
            has_value = value.InnerRect.HasValue,
            value = value.InnerRect.GetValueOrDefault(),
        },
        outer_rect = new EguiOptionRect {
            has_value = value.OuterRect.HasValue,
            value = value.OuterRect.GetValueOrDefault(),
        },
        minimized = new EguiOptionBool {
            has_value = value.Minimized.HasValue,
            value = value.Minimized.GetValueOrDefault(),
        },
        maximized = new EguiOptionBool {
            has_value = value.Maximized.HasValue,
            value = value.Maximized.GetValueOrDefault(),
        },
        fullscreen = new EguiOptionBool {
            has_value = value.Fullscreen.HasValue,
            value = value.Fullscreen.GetValueOrDefault(),
        },
        focused = new EguiOptionBool {
            has_value = value.Focused.HasValue,
            value = value.Focused.GetValueOrDefault(),
        },
    }
    */
}

/// <summary>
/// Controls the visual style (colors etc) of egui.
/// 
/// You can change the visuals of a <c>Ui</c> with <c>VisualsMut</c>
/// and of everything with <c>SetVisualsOf</c>.
/// 
/// If you want to change fonts, use <c>SetFonts</c> instead.
/// </summary>
public unsafe partial struct Visuals {
    /// <summary>
    /// Returns the "default value" for a type.
    /// </summary>
    public static readonly Visuals Default = (Visuals)Egui.visuals_default();

    /// <summary>
    /// If true, the visuals are overall dark with light text.
    /// If false, the visuals are overall light with dark text.
    /// 
    /// NOTE: setting this does very little by itself,
    /// this is more to provide a convenient summary of the rest of the settings.
    /// </summary>
    public bool DarkMode;
    
    /// <summary>
    /// Override default text color for all text.
    /// 
    /// This is great for setting the color of text for any widget.
    /// 
    /// If <c>TextColor</c> is <c>None</c> (default), then the text color will be the same as the
    /// foreground stroke color (<c>FgStroke</c>)
    /// and will depend on whether or not the widget is being interacted with.
    /// 
    /// In the future we may instead modulate
    /// the <c>TextColor</c> based on whether or not it is interacted with
    /// so that <c>Visuals.textColor</c> is always used,
    /// but its alpha may be different based on whether or not
    /// it is disabled, non-interactive, hovered etc.
    /// </summary>
    public Color32? OverrideTextColor;
    
    /// <summary>
    /// Visual styles of widgets
    /// </summary>
    public Widgets Widgets;
    
    public Selection Selection;
    
    /// <summary>
    /// The color used for <c>Hyperlink</c>,
    /// </summary>
    public Color32 HyperlinkColor;
    
    /// <summary>
    /// Something just barely different from the background color.
    /// Used for <c>Striped</c>.
    /// </summary>
    public Color32 FaintBgColor;
    
    /// <summary>
    /// Very dark or light color (for corresponding theme).
    /// Used as the background of text edits, scroll bars and others things
    /// that needs to look different from other interactive stuff.
    /// </summary>
    public Color32 ExtremeBgColor;
    
    /// <summary>
    /// Background color behind code-styled monospaced labels.
    /// </summary>
    public Color32 CodeBgColor;
    
    /// <summary>
    /// A good color for warning text (e.g. orange).
    /// </summary>
    public Color32 WarnFgColor;
    
    /// <summary>
    /// A good color for error text (e.g. red).
    /// </summary>
    public Color32 ErrorFgColor;
    
    public CornerRadius WindowCornerRadius;
    
    public Shadow WindowShadow;
    
    public Color32 WindowFill;
    
    public Stroke WindowStroke;
    
    /// <summary>
    /// Highlight the topmost window.
    /// </summary>
    public bool WindowHighlightTopmost;
    
    public CornerRadius MenuCornerRadius;
    
    /// <summary>
    /// Panel background color
    /// </summary>
    public Color32 PanelFill;
    
    public Shadow PopupShadow;
    
    public float ResizeCornerSize;
    
    /// <summary>
    /// How the text cursor acts.
    /// </summary>
    public TextCursorStyle TextCursor;
    
    /// <summary>
    /// Allow child widgets to be just on the border and still have a stroke with some thickness
    /// </summary>
    public float ClipRectMargin;
    
    /// <summary>
    /// Show a background behind buttons.
    /// </summary>
    public bool ButtonFrame;
    
    /// <summary>
    /// Show a background behind collapsing headers.
    /// </summary>
    public bool CollapsingHeaderFrame;
    
    /// <summary>
    /// Draw a vertical lien left of indented region, in e.g. <c>CollapsingHeader</c>.
    /// </summary>
    public bool IndentHasLeftVline;
    
    /// <summary>
    /// Whether or not Grids and Tables should be striped by default
    /// (have alternating rows differently colored).
    /// </summary>
    public bool Striped;
    
    /// <summary>
    /// Show trailing color behind the circle of a <c>Slider</c>. Default is OFF.
    /// 
    /// Enabling this will affect ALL sliders, and can be enabled/disabled per slider with <c>TrailingFill</c>.
    /// </summary>
    public bool SliderTrailingFill;
    
    /// <summary>
    /// Shape of the handle for sliders and similar widgets.
    /// 
    /// Changing this will affect ALL sliders, and can be enabled/disabled per slider with <c>HandleShape</c>.
    /// </summary>
    public HandleShape HandleShape;
    
    /// <summary>
    /// Should the cursor change when the user hovers over an interactive/clickable item?
    /// 
    /// This is consistent with a lot of browser-based applications (vscode, github
    /// all turn your cursor into <c>PointingHand</c> when a button is
    /// hovered) but it is inconsistent with native UI toolkits.
    /// </summary>
    public CursorIcon? InteractCursor;
    
    /// <summary>
    /// Show a spinner when loading an image.
    /// </summary>
    public bool ImageLoadingSpinners;
    
    /// <summary>
    /// How to display numeric color values.
    /// </summary>
    public NumericColorSpace NumericColorSpace;
    
    public WidgetVisuals Noninteractive() {
        Egui.visuals_noninteractive();
    
    }
    
    public Color32 TextColor() {
        Egui.visuals_text_color();
    
    }
    
    public Color32 WeakTextColor() {
        Egui.visuals_weak_text_color();
    
    }
    
    public Color32 StrongTextColor() {
        Egui.visuals_strong_text_color();
    
    }
    
    public Color32 WindowFill() {
        Egui.visuals_window_fill();
    
    }
    
    public Stroke WindowStroke() {
        Egui.visuals_window_stroke();
    
    }
    
    public Color32 FadeOutToColor() {
        Egui.visuals_fade_out_to_color();
    
    }
    
    public Color32 GrayOut(Color32 color) {
        Egui.visuals_gray_out(TODO_ARG(color));
    
    }
    
    public static Visuals Dark() {
        Egui.visuals_dark();
    
    }
    
    public static Visuals Light() {
        Egui.visuals_light();
    
    }
    
    public void Ui(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "crate::Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui) {
        Egui.visuals_ui(TODO_ARG(ui));
    
    }
    
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static Visuals operator(EguiVisuals value) => new Visuals {
        DarkMode = value.dark_mode,
        OverrideTextColor = value.override_text_color.has_value ? (EguiColor32)value.override_text_color.value : null,
        Widgets = (Widgets)value.widgets,
        Selection = (Selection)value.selection,
        HyperlinkColor = (Color32)value.hyperlink_color,
        FaintBgColor = (Color32)value.faint_bg_color,
        ExtremeBgColor = (Color32)value.extreme_bg_color,
        CodeBgColor = (Color32)value.code_bg_color,
        WarnFgColor = (Color32)value.warn_fg_color,
        ErrorFgColor = (Color32)value.error_fg_color,
        WindowCornerRadius = (CornerRadius)value.window_corner_radius,
        WindowShadow = (Shadow)value.window_shadow,
        WindowFill = (Color32)value.window_fill,
        WindowStroke = (Stroke)value.window_stroke,
        WindowHighlightTopmost = value.window_highlight_topmost,
        MenuCornerRadius = (CornerRadius)value.menu_corner_radius,
        PanelFill = (Color32)value.panel_fill,
        PopupShadow = (Shadow)value.popup_shadow,
        ResizeCornerSize = value.resize_corner_size,
        TextCursor = (TextCursorStyle)value.text_cursor,
        ClipRectMargin = value.clip_rect_margin,
        ButtonFrame = value.button_frame,
        CollapsingHeaderFrame = value.collapsing_header_frame,
        IndentHasLeftVline = value.indent_has_left_vline,
        Striped = value.striped,
        SliderTrailingFill = value.slider_trailing_fill,
        HandleShape = (HandleShape)value.handle_shape,
        InteractCursor = value.interact_cursor.has_value ? value.interact_cursor.value.Cast<CursorIcon, EguiCursorIcon>() : null,
        ImageLoadingSpinners = value.image_loading_spinners,
        NumericColorSpace = value.numeric_color_space.Cast<EguiNumericColorSpace, NumericColorSpace>(),
    }
    
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiVisuals operator(Visuals value) => new EguiVisuals {
        dark_mode = value.DarkMode,
        override_text_color = new EguiOptionColor32 {
            has_value = value.OverrideTextColor.HasValue,
            value = value.OverrideTextColor.GetValueOrDefault(),
        },
        widgets = (EguiWidgets)value.Widgets,
        selection = (EguiSelection)value.Selection,
        hyperlink_color = (EguiColor32)value.HyperlinkColor,
        faint_bg_color = (EguiColor32)value.FaintBgColor,
        extreme_bg_color = (EguiColor32)value.ExtremeBgColor,
        code_bg_color = (EguiColor32)value.CodeBgColor,
        warn_fg_color = (EguiColor32)value.WarnFgColor,
        error_fg_color = (EguiColor32)value.ErrorFgColor,
        window_corner_radius = (EguiCornerRadius)value.WindowCornerRadius,
        window_shadow = (EguiShadow)value.WindowShadow,
        window_fill = (EguiColor32)value.WindowFill,
        window_stroke = (EguiStroke)value.WindowStroke,
        window_highlight_topmost = value.WindowHighlightTopmost,
        menu_corner_radius = (EguiCornerRadius)value.MenuCornerRadius,
        panel_fill = (EguiColor32)value.PanelFill,
        popup_shadow = (EguiShadow)value.PopupShadow,
        resize_corner_size = value.ResizeCornerSize,
        text_cursor = (EguiTextCursorStyle)value.TextCursor,
        clip_rect_margin = value.ClipRectMargin,
        button_frame = value.ButtonFrame,
        collapsing_header_frame = value.CollapsingHeaderFrame,
        indent_has_left_vline = value.IndentHasLeftVline,
        striped = value.Striped,
        slider_trailing_fill = value.SliderTrailingFill,
        handle_shape = (EguiHandleShape)value.HandleShape,
        interact_cursor = new EguiOptionCursorIcon {
            has_value = value.InteractCursor.HasValue,
            value = value.InteractCursor.GetValueOrDefault(),
        },
        image_loading_spinners = value.ImageLoadingSpinners,
        numeric_color_space = value.NumericColorSpace.Cast<NumericColorSpace, EguiNumericColorSpace>(),
    }
}

/// <summary>
/// Describes a widget such as a <c>Button</c> or a <c>TextEdit</c>.
/// </summary>
public unsafe partial struct WidgetInfo {
    /// <summary>
    /// The type of widget this is.
    /// </summary>
    public WidgetType Typ;
    
    /// <summary>
    /// Whether the widget is enabled.
    /// </summary>
    public bool Enabled;
    
    /// <summary>
    /// The text on labels, buttons, checkboxes etc.
    /// </summary>
    public string? Label;
    
    /// <summary>
    /// The contents of some editable text (for <c>TextEdit</c> fields).
    /// </summary>
    public string? CurrentTextValue;
    
    /// <summary>
    /// The previous text value.
    /// </summary>
    public string? PrevTextValue;
    
    /// <summary>
    /// The current value of checkboxes and radio buttons.
    /// </summary>
    public bool? Selected;
    
    /// <summary>
    /// The current value of sliders etc.
    /// </summary>
    public double? Value;
    
    /// <summary>
    /// Selected range of characters in <c>CurrentTextValue</c>.
    /// </summary>
    public RangeInclusive? TextSelection;
    
    public WidgetInfo(WidgetType typ) {
        Egui.widget_info_new(TODO_ARG(typ));
    
    }
    
    public static WidgetInfo Labeled(WidgetType typ, bool enabled, ImplTrait([TraitBound { trait_: Path { path: "ToString", id: Id(1298), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) label) {
        Egui.widget_info_labeled(TODO_ARG(typ), TODO_ARG(enabled), TODO_ARG(label));
    
    }
    
    public static WidgetInfo Selected(WidgetType typ, bool enabled, bool selected, ImplTrait([TraitBound { trait_: Path { path: "ToString", id: Id(1298), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) label) {
        Egui.widget_info_selected(TODO_ARG(typ), TODO_ARG(enabled), TODO_ARG(selected), TODO_ARG(label));
    
    }
    
    public static WidgetInfo DragValue(bool enabled, double value) {
        Egui.widget_info_drag_value(TODO_ARG(enabled), TODO_ARG(value));
    
    }
    
    public static WidgetInfo Slider(bool enabled, double value, ImplTrait([TraitBound { trait_: Path { path: "ToString", id: Id(1298), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) label) {
        Egui.widget_info_slider(TODO_ARG(enabled), TODO_ARG(value), TODO_ARG(label));
    
    }
    
    public static WidgetInfo TextEdit(bool enabled, ImplTrait([TraitBound { trait_: Path { path: "ToString", id: Id(1298), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) prevTextValue, ImplTrait([TraitBound { trait_: Path { path: "ToString", id: Id(1298), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) textValue) {
        Egui.widget_info_text_edit(TODO_ARG(enabled), TODO_ARG(prevTextValue), TODO_ARG(textValue));
    
    }
    
    public static WidgetInfo TextSelectionChanged(bool enabled, RangeInclusive textSelection, ImplTrait([TraitBound { trait_: Path { path: "ToString", id: Id(1298), args: Some(AngleBracketed { args: [], constraints: [] }) }, generic_params: [], modifier: None }]) currentTextValue) {
        Egui.widget_info_text_selection_changed(TODO_ARG(enabled), TODO_ARG(textSelection), TODO_ARG(currentTextValue));
    
    }
    
    public string Description() {
        Egui.widget_info_description();
    
    }
    
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static WidgetInfo operator(EguiWidgetInfo value) => new WidgetInfo {
        Typ = value.typ.Cast<EguiWidgetType, WidgetType>(),
        Enabled = value.enabled,
        Label = value.label.has_value ? STRING_CONV_TODO : null,
        CurrentTextValue = value.current_text_value.has_value ? STRING_CONV_TODO : null,
        PrevTextValue = value.prev_text_value.has_value ? STRING_CONV_TODO : null,
        Selected = value.selected.has_value ? value.selected.value : null,
        Value = value.value.has_value ? value.value.value : null,
        TextSelection = value.text_selection.has_value ? (EguiRangeInclusive)value.text_selection.value : null,
    }
    
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiWidgetInfo operator(WidgetInfo value) => new EguiWidgetInfo {
        typ = value.Typ.Cast<WidgetType, EguiWidgetType>(),
        enabled = value.Enabled,
        label = new EguiOptionString {
            has_value = value.Label.HasValue,
            value = value.Label.GetValueOrDefault(),
        },
        current_text_value = new EguiOptionString {
            has_value = value.CurrentTextValue.HasValue,
            value = value.CurrentTextValue.GetValueOrDefault(),
        },
        prev_text_value = new EguiOptionString {
            has_value = value.PrevTextValue.HasValue,
            value = value.PrevTextValue.GetValueOrDefault(),
        },
        selected = new EguiOptionBool {
            has_value = value.Selected.HasValue,
            value = value.Selected.GetValueOrDefault(),
        },
        value = new EguiOptionF64 {
            has_value = value.Value.HasValue,
            value = value.Value.GetValueOrDefault(),
        },
        text_selection = new EguiOptionRangeInclusive {
            has_value = value.TextSelection.HasValue,
            value = value.TextSelection.GetValueOrDefault(),
        },
    }
}

/// <summary>
/// Used to store each widget's Id, Rect and Sense each frame.
/// 
/// Used to check which widget gets input when a user clicks somewhere.
/// </summary>
public unsafe partial struct WidgetRect {
    /// <summary>
    /// The globally unique widget id.
    /// 
    /// For interactive widgets, this better be globally unique.
    /// If not there will be weird bugs,
    /// and also big red warning test on the screen in debug builds
    /// (see <c>WarnOnIdClash</c>).
    /// 
    /// You can ensure globally unique ids using <c>PushId</c>.
    /// </summary>
    public Id Id;
    
    /// <summary>
    /// What layer the widget is on.
    /// </summary>
    public LayerId LayerId;
    
    /// <summary>
    /// The full widget rectangle, in local layer coordinates.
    /// </summary>
    public Rect Rect;
    
    /// <summary>
    /// Where the widget is, in local layer coordinates.
    /// 
    /// This is after clipping with the parent ui clip rect.
    /// </summary>
    public Rect InteractRect;
    
    /// <summary>
    /// How the widget responds to interaction.
    /// 
    /// Note: if <c>Enabled</c> is <c>False</c>, then
    /// the widget _effectively_ doesn't sense anything,
    /// but can still have the same <c>Sense</c>.
    /// This is because the sense informs the styling of the widget,
    /// but we don't want to change the style when a widget is disabled
    /// (that is handled by the <c>Painter</c> directly).
    /// </summary>
    public Sense Sense;
    
    /// <summary>
    /// Is the widget enabled?
    /// </summary>
    public bool Enabled;
    
    public WidgetRect Transform(emath::TSTransform transform) {
        Egui.widget_rect_transform(TODO_ARG(transform));
    
    }
    
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static WidgetRect operator(EguiWidgetRect value) => new WidgetRect {
        Id = (Id)value.id,
        LayerId = (LayerId)value.layer_id,
        Rect = (Rect)value.rect,
        InteractRect = (Rect)value.interact_rect,
        Sense = (Sense)value.sense,
        Enabled = value.enabled,
    }
    
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiWidgetRect operator(WidgetRect value) => new EguiWidgetRect {
        id = (EguiId)value.Id,
        layer_id = (EguiLayerId)value.LayerId,
        rect = (EguiRect)value.Rect,
        interact_rect = (EguiRect)value.InteractRect,
        sense = (EguiSense)value.Sense,
        enabled = value.Enabled,
    }
}

/// <summary>
/// bg = background, fg = foreground.
/// </summary>
public unsafe partial struct WidgetVisuals {
    /// <summary>
    /// Background color of widgets that must have a background fill,
    /// such as the slider background, a checkbox background, or a radio button background.
    /// 
    /// Must never be <c>Transparent</c>.
    /// </summary>
    public Color32 BgFill;
    
    /// <summary>
    /// Background color of widgets that can _optionally_ have a background fill, such as buttons.
    /// 
    /// May be <c>Transparent</c>.
    /// </summary>
    public Color32 WeakBgFill;
    
    /// <summary>
    /// For surrounding rectangle of things that need it,
    /// like buttons, the box of the checkbox, etc.
    /// Should maybe be called <c>FrameStroke</c>.
    /// </summary>
    public Stroke BgStroke;
    
    /// <summary>
    /// Button frames etc.
    /// </summary>
    public CornerRadius CornerRadius;
    
    /// <summary>
    /// Stroke and text color of the interactive part of a component (button text, slider grab, check-mark, …).
    /// </summary>
    public Stroke FgStroke;
    
    /// <summary>
    /// Make the frame this much larger.
    /// </summary>
    public float Expansion;
    
    public Color32 TextColor() {
        Egui.widget_visuals_text_color();
    
    }
    
    public CornerRadius Rounding() {
        Egui.widget_visuals_rounding();
    
    }
    
    public void Ui(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "crate::Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui) {
        Egui.widget_visuals_ui(TODO_ARG(ui));
    
    }
    
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static WidgetVisuals operator(EguiWidgetVisuals value) => new WidgetVisuals {
        BgFill = (Color32)value.bg_fill,
        WeakBgFill = (Color32)value.weak_bg_fill,
        BgStroke = (Stroke)value.bg_stroke,
        CornerRadius = (CornerRadius)value.corner_radius,
        FgStroke = (Stroke)value.fg_stroke,
        Expansion = value.expansion,
    }
    
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiWidgetVisuals operator(WidgetVisuals value) => new EguiWidgetVisuals {
        bg_fill = (EguiColor32)value.BgFill,
        weak_bg_fill = (EguiColor32)value.WeakBgFill,
        bg_stroke = (EguiStroke)value.BgStroke,
        corner_radius = (EguiCornerRadius)value.CornerRadius,
        fg_stroke = (EguiStroke)value.FgStroke,
        expansion = value.Expansion,
    }
}

/// <summary>
/// The visuals of widgets for different states of interaction.
/// </summary>
public unsafe partial struct Widgets {
    /// <summary>
    /// Returns the "default value" for a type.
    /// </summary>
    public static readonly Widgets Default = (Widgets)Egui.widgets_default();

    /// <summary>
    /// The style of a widget that you cannot interact with.
    /// * <c>Noninteractive.bgStroke</c> is the outline of windows.
    /// * <c>Noninteractive.bgFill</c> is the background color of windows.
    /// * <c>Noninteractive.fgStroke</c> is the normal text color.
    /// </summary>
    public WidgetVisuals Noninteractive;
    
    /// <summary>
    /// The style of an interactive widget, such as a button, at rest.
    /// </summary>
    public WidgetVisuals Inactive;
    
    /// <summary>
    /// The style of an interactive widget while you hover it, or when it is highlighted.
    /// 
    /// See <c>Hovered</c>, <c>Highlighted</c> and <c>Highlight</c>.
    /// </summary>
    public WidgetVisuals Hovered;
    
    /// <summary>
    /// The style of an interactive widget as you are clicking or dragging it.
    /// </summary>
    public WidgetVisuals Active;
    
    /// <summary>
    /// The style of a button that has an open menu beneath it (e.g. a combo-box)
    /// </summary>
    public WidgetVisuals Open;
    
    public WidgetVisuals Style(Response response) {
        Egui.widgets_style(TODO_ARG(response));
    
    }
    
    public static Widgets Dark() {
        Egui.widgets_dark();
    
    }
    
    public static Widgets Light() {
        Egui.widgets_light();
    
    }
    
    public void Ui(BorrowedRef { lifetime: None, is_mutable: true, type_: ResolvedPath(Path { path: "crate::Ui", id: Id(238), args: Some(AngleBracketed { args: [], constraints: [] }) }) } ui) {
        Egui.widgets_ui(TODO_ARG(ui));
    
    }
    
    /// <summary>
    /// Converts from the Rust to the C# version of this type.
    /// </summary>
    public static Widgets operator(EguiWidgets value) => new Widgets {
        Noninteractive = (WidgetVisuals)value.noninteractive,
        Inactive = (WidgetVisuals)value.inactive,
        Hovered = (WidgetVisuals)value.hovered,
        Active = (WidgetVisuals)value.active,
        Open = (WidgetVisuals)value.open,
    }
    
    /// <summary>
    /// Converts from the C# to the Rust version of this type.
    /// </summary>
    public static EguiWidgets operator(Widgets value) => new EguiWidgets {
        noninteractive = (EguiWidgetVisuals)value.Noninteractive,
        inactive = (EguiWidgetVisuals)value.Inactive,
        hovered = (EguiWidgetVisuals)value.Hovered,
        active = (EguiWidgetVisuals)value.Active,
        open = (EguiWidgetVisuals)value.Open,
    }
}

