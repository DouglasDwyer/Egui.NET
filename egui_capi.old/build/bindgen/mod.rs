#![allow(warnings)]

use std::{collections::*, env::var};
use rustdoc_types::*;

/// Defines the C# and Rust members that will be autogenerated.
mod ag;

/// Holds data about types that were generated.
pub struct BindgenContext {
    /// Externally-provided types defined for this context.
    external_types: Vec<ag::TypeReference>,
    /// Types that should be ignored during generation.
    ignore_types: Vec<String>,
    /// The definitions to create in C# and Rust.
    items: Vec<ag::Type>,
    /// The Rustdoc crate definition.
    krate: Crate,
    /// The types for which a `VxOption...` must be generated.
    optional_types: Vec<ag::TypeReference>,
    /// Describes the type of each item in the context.
    types: HashMap<Id, ag::TypeReference>
}

impl BindgenContext {
    pub fn new(external_tys: &[ag::TypeReference], ignore_tys: &[&str]) -> Self {
        let external_types = external_tys.to_vec();
        let ignore_types = ignore_tys.into_iter().map(ToString::to_string).collect();
        let items = Vec::new();
        let krate = serde_json::from_str::<Crate>(include_str!("egui.json")).expect("Failed to parse egui");
        let types = HashMap::default();
        let optional_types = Vec::new();

        Self {
            external_types,
            ignore_types,
            items,
            krate,
            optional_types,
            types
        }
    }

    /// Identifies which items are relevant for autogeneration and emits type definitions.
    pub fn collect(&mut self) {
        assert!(!self.krate.includes_private, "Public bindings should not include private items");
        self.categorize_types();
        self.collect_items();
        self.collect_optional_types();
        self.items.sort();
    }

    /// All of the items that were automatically generates.
    pub fn items(&self) -> &[ag::Type] {
        &self.items
    }

    /// The types for which optional structs much be generated.
    pub fn optional_types(&self) -> &[ag::TypeReference] {
        &self.optional_types
    }

    /// Autogenerates definitions for all relevant items in the crate.
    fn collect_items(&mut self) {
        for (id, ty) in self.types.clone() {
            match ty {
                ag::TypeReference::Class(name) => self.collect_class_or_struct(id, name, true),
                ag::TypeReference::Enum(name) => self.collect_enum(id, name),
                ag::TypeReference::Struct(name) => self.collect_class_or_struct(id, name, false),
                ag::TypeReference::Builtin(_) | ag::TypeReference::Primitive(_) | ag::TypeReference::Unknown(_) => {},
            }
        }
    }

    /// Gathers the types for which options must be generated.
    fn collect_optional_types(&mut self) {
        let referenced_types = self.items.iter().flat_map(ag::Type::referenced_types).collect::<BTreeSet<ag::TypeReference>>();
        for ty in referenced_types.into_iter().filter(|x| !x.contains_unknown()) {
            if let ag::TypeReference::Builtin(ag::BuiltinType::Option(x)) = ty {
                self.optional_types.push(*x);
            }
        }
    }

    /// Gathers the items associated with a simple numeric enum.
    fn collect_enum(&mut self, id: Id, name: ag::TypeName) {
        let enum_ty = &self.krate.index[&id];
        let ItemEnum::Enum(x) = &enum_ty.inner else { unreachable!() };
            
        let variants = x.variants.iter().map(|id| {
            let variant = &self.krate.index[id];
            let ItemEnum::Variant(inner) = &variant.inner else { unreachable!() };
            
            ag::EnumVariant {
                docs: variant.docs.clone().unwrap_or_default(),
                name: variant.name.clone().unwrap_or_default(),
                index: inner.discriminant.as_ref().map(|x| str::parse(&x.value).expect("Failed to parse enum discriminant"))
            }
        }).collect();

        self.items.push(ag::Type::Enum {
            docs: enum_ty.docs.clone().unwrap_or_default(),
            name,
            variants
        });
    }

    /// Gathers the items associated with either a class or struct.
    fn collect_class_or_struct(&mut self, id: Id, name: ag::TypeName, handle: bool) {
        let self_ty = &self.types[&id];
        let struct_ty = &self.krate.index[&id];
        let ItemEnum::Struct(x) = &struct_ty.inner else { unreachable!() };
        let StructKind::Plain { fields, .. } = &x.kind else { return };
        
        let mut collected_fields = Vec::new();
        for field_id in fields {
            let field_item = &self.krate.index[field_id];
            let ItemEnum::StructField(field) = &field_item.inner else { unreachable!() };
            collected_fields.push(ag::StructField {
                name: field_item.name.clone().unwrap_or_default(),
                ty: self.resolve_type(Some(self_ty), field),
                docs: field_item.docs.clone().unwrap_or_default()
            });
        }

        let mut collected_methods = Vec::new();
        for impl_id in &x.impls {
            let impl_item = &self.krate.index[impl_id];
            let ItemEnum::Impl(i) = &impl_item.inner else { unreachable!() };
            if i.trait_.is_none() {
                for method_id in &i.items {
                    let method_item = &self.krate.index[method_id];
                    if let ItemEnum::Function(fun) = &method_item.inner {
                        let has_this = fun.sig.inputs.first().map(|(name, _)| name == "self").unwrap_or(false);
                        let return_ty = fun.sig.output.as_ref().map(|x| self.resolve_type(Some(self_ty), x));
                        let parameters = fun.sig.inputs.iter().skip(has_this as usize).map(|(name, ty)| ag::MethodParameter {
                            name: name.clone(),
                            ty: self.resolve_type(Some(self_ty), ty)
                        }).collect();
                        
                        collected_methods.push(ag::Method {
                            name: method_item.name.clone().unwrap_or_default(),
                            has_this,
                            return_ty,
                            parameters,
                            ty: name.clone(),
                            docs: method_item.docs.clone().unwrap_or_default()
                        });
                    }
                }
            }
        }

        if handle {
            self.items.push(ag::Type::Class {
                name,
                fields: collected_fields,
                has_default: self.struct_impls(x, "Default"),
                methods: collected_methods,
                docs: struct_ty.docs.clone().unwrap_or_default()
            })
        }
        else {
            self.items.push(ag::Type::Struct {
                name,
                fields: collected_fields,
                has_default: self.struct_impls(x, "Default"),
                methods: collected_methods,
                docs: struct_ty.docs.clone().unwrap_or_default()
            })
        }
    }

    /// Checks if the enum only has primitive variants.
    fn is_primitive_enum(&self, x: &Enum) -> bool {
        for variant in &x.variants {
            let ItemEnum::Variant(x) = &self.krate.index[variant].inner else { unreachable!() };
            if x.kind != VariantKind::Plain {
                return false;
            }
        }
    
        true
    }

    /// Checks if the enum only has primitive variants.
    fn is_trivial_struct(&self, x: &Struct) -> bool {
        if let StructKind::Plain { has_stripped_fields: false, .. } = &x.kind {
            for id in &x.impls {
                let ItemEnum::Impl(impl_block) = &self.krate.index[id].inner else { unreachable!() };
                if impl_block.trait_.as_ref().map(|x| x.path == "Clone").unwrap_or_default() {
                    return true;
                }
            }
        }
        
        false
    }

    /// Populates the [`Self::types`] map by identifying the type of each item in the crate.
    fn categorize_types(&mut self) {
        for (id, item) in self.krate.index.to_owned() {
            if item.name.as_ref().map(|x| self.external_types.iter().any(|y| y.type_name().map(|z| z.original.contains(x)).unwrap_or(false))
                || self.ignore_types.contains(x)).unwrap_or_default() {
                continue;
            }

            match &item.inner {
                ItemEnum::Enum(x) => if self.is_primitive_enum(x) {
                    self.types.insert(id, ag::TypeReference::Enum(ag::TypeName::from_path(&self.krate.paths[&id].path)));
                },
                ItemEnum::Struct(x) => if self.is_trivial_struct(x) {
                    self.types.insert(id, ag::TypeReference::Struct(ag::TypeName::from_path(&self.krate.paths[&id].path)));
                } else {
                    self.types.insert(id, ag::TypeReference::Class(ag::TypeName::from_path(&self.krate.paths[&id].path)));
                },
                _ => {}
            }
        }
    }
    
    /// Determines whether `x` implements the trait with `path`.
    fn struct_impls(&self, x: &Struct, path: &str) -> bool {
        for id in &x.impls {
            let ItemEnum::Impl(impl_block) = &self.krate.index[id].inner else { unreachable!() };
            if impl_block.trait_.as_ref().map(|x| x.path == path).unwrap_or_default() {
                return true;
            }
        }

        false
    }

    fn resolve_type(&self, self_ty: Option<&ag::TypeReference>, ty: &Type) -> ag::TypeReference {
        match ty {
            Type::ResolvedPath(path) => {
                match path.path.as_str() {
                    "Option" | "Vec" => {
                        let builtin_fn = match path.path.as_str() {
                            "Option" => Box::new(ag::BuiltinType::Option) as Box<dyn Fn(Box<ag::TypeReference>) -> ag::BuiltinType>,
                            "Vec" => Box::new(ag::BuiltinType::Vec),
                            _ => unreachable!()
                        };

                        let Some(GenericArgs::AngleBracketed { args, .. }) = path.args.as_deref() else { return ag::TypeReference::Unknown(path.path.clone()) };
                        if args.len() == 1 {
                            let GenericArg::Type(arg) = &args[0] else { return ag::TypeReference::Unknown(path.path.clone()) };
                            ag::TypeReference::Builtin(builtin_fn(Box::new(self.resolve_type(self_ty, arg))))
                        }
                        else {
                            ag::TypeReference::Unknown(path.path.clone())
                        }
                    },
                    "std::time::Duration" => ag::TypeReference::Builtin(ag::BuiltinType::TimeSpan),
                    "std::time::SystemTime" => ag::TypeReference::Builtin(ag::BuiltinType::DateTime),
                    "String" | "str" => ag::TypeReference::Builtin(ag::BuiltinType::String),
                    _ => {
                        let simple_name = self.krate.paths[&path.id].path.last().expect("Path was empty");
                        for ty in self.types.values().chain(&self.external_types) {
                            match ty {
                                ag::TypeReference::Enum(name) | ag::TypeReference::Struct(name)
                                    => if simple_name == &name.simple {
                                        return ty.clone();
                                    }
                                _ => {}
                            }
                        }
                        //println!("Try find {} but could not for {simple_name}", path.path);
                        ag::TypeReference::Unknown(path.path.clone())
                    }
                }
            },
            Type::Primitive(name) => ag::TypeReference::Primitive(match &**name {
                "bool" => ag::PrimitiveType::Bool,
                "u8" => ag::PrimitiveType::U8,
                "u16" => ag::PrimitiveType::U16,
                "u32" => ag::PrimitiveType::U32,
                "u64" => ag::PrimitiveType::U64,
                "i8" => ag::PrimitiveType::I8,
                "i16" => ag::PrimitiveType::I16,
                "i32" => ag::PrimitiveType::I32,
                "i64" => ag::PrimitiveType::I64,
                "f32" => ag::PrimitiveType::F32,
                "f64" => ag::PrimitiveType::F64,
                "isize" => ag::PrimitiveType::ISize,
                "usize" => ag::PrimitiveType::USize,
                _ => return ag::TypeReference::Unknown(name.clone())
            }),
            Type::BorrowedRef { is_mutable: false, type_, .. } => self.resolve_type(self_ty, &type_),
            Type::BorrowedRef { is_mutable: true, type_, .. } => ag::TypeReference::Unknown(format!("{ty:?}")),
            Type::Generic(x) if x == "Self" && self_ty.is_some() => self_ty.expect("No self type available").clone(),
            | Type::DynTrait(_)
            | Type::Generic(_)
            | Type::FunctionPointer(_)
            | Type::Tuple(_)
            | Type::Slice(_)
            | Type::Array { .. }
            | Type::Pat { .. }
            | Type::ImplTrait(_)
            | Type::Infer
            | Type::RawPointer { .. }
            | Type::QualifiedPath { .. } => ag::TypeReference::Unknown(format!("{ty:?}")),
        }
    }
}

/// Generates the formatted C# bindings for the given items.
pub fn autogenerate_cs(items: &[ag::Type]) -> String {
    let mut item_names = items.iter().map(|x| x.name().cs.clone())
        .chain(items.iter().flat_map(|x| x.cs_members()))
        .collect::<Vec<_>>();
    let mut items_string = String::new();
    for item in items {
        items_string += &format!("{}\n", ag::DisplayCs(item));
    }

    include_str!("Template.cs")
        .replace("__ITEM_NAMES__", &format!("{item_names:?}"))
        .replace("__ITEMS__", &items_string)
}

/// Generates the formatted Rust bindings for the given items.
pub fn autogenerate_rs(items: &[ag::Type], optional_types: &[ag::TypeReference]) -> String {
    let mut result = String::new();
    let mut f = std::fmt::Formatter::new(&mut result, std::fmt::FormattingOptions::default());

    for item in items {
        write!(f, "{}\n", ag::DisplayRs(item)).expect("Failed to write autogenerated Rust code");
    }

    for ty in optional_types {
        ty.rs_option_wrapper(&mut f).expect("Failed to write autogenerated Rust code");
        write!(f, "\n").expect("Failed to write autogenerated Rust code");
    }

    result
}

pub fn autogenerate(directory: &std::path::Path) {
    let mut ctx = BindgenContext::new(&[
        ag::TypeReference::Struct(ag::TypeName::from_path(&["egui".to_string(), "emath".to_string(), "Align".to_string()])),
        ag::TypeReference::Struct(ag::TypeName::from_path(&["egui".to_string(), "emath".to_string(), "Color32".to_string()])),
        ag::TypeReference::Struct(ag::TypeName::from_path(&["egui".to_string(), "emath".to_string(), "Pos2".to_string()])),
        ag::TypeReference::Struct(ag::TypeName::from_path(&["egui".to_string(), "emath".to_string(), "Rangef".to_string()])),
        ag::TypeReference::Struct(ag::TypeName::from_path(&["egui".to_string(), "emath".to_string(), "Rect".to_string()])),
        ag::TypeReference::Struct(ag::TypeName::from_path(&["egui".to_string(), "emath".to_string(), "Rot2".to_string()])),
        ag::TypeReference::Struct(ag::TypeName::from_path(&["egui".to_string(), "emath".to_string(), "Vec2".to_string()])),
        ag::TypeReference::Struct(ag::TypeName::from_path(&["egui".to_string(), "epaint".to_string(), "CornerRadius".to_string()])),
        ag::TypeReference::Struct(ag::TypeName::from_path(&["egui".to_string(), "epaint".to_string(), "Margin".to_string()])),
        ag::TypeReference::Struct(ag::TypeName::from_path(&["egui".to_string(), "epaint".to_string(), "Shadow".to_string()])),
        ag::TypeReference::Struct(ag::TypeName::from_path(&["egui".to_string(), "epaint".to_string(), "Stroke".to_string()])),
        ag::TypeReference::Struct(ag::TypeName::from_path(&["egui".to_string(), "epaint".to_string(), "TextureId".to_string()])),
        ag::TypeReference::Struct(ag::TypeName::from_path(&["egui".to_string(), "text".to_string(), "cursor".to_string(), "CCursor".to_string()])),
        ag::TypeReference::Struct(ag::TypeName::from_path(&["egui".to_string(), "text".to_string(), "cursor".to_string(), "Cursor".to_string()])),
        ag::TypeReference::Struct(ag::TypeName::from_path(&["egui".to_string(), "text".to_string(), "cursor".to_string(), "PCursor".to_string()])),
        ag::TypeReference::Struct(ag::TypeName::from_path(&["egui".to_string(), "HandleShape".to_string()])),
        ag::TypeReference::Struct(ag::TypeName::from_path(&["egui".to_string(), "Id".to_string()])),
        ag::TypeReference::Struct(ag::TypeName::from_path(&["egui".to_string(), "Key".to_string()])),
        ag::TypeReference::Struct(ag::TypeName::from_path(&["egui".to_string(), "Sense".to_string()])),
        ag::TypeReference::Struct(ag::TypeName::from_path(&["std".to_string(), "ops".to_string(), "RangeInclusive".to_string()]))
    ], &[
        "FullOutput",
        "IconData",
        "OperatingSystem",
        "X11WindowType",

        "Loaders",
        "PanelState",
        "ViewportBuilder",
        "ViewportOutput"
    ]);

    ctx.collect();

    std::fs::write(directory.join("Egui.g.cs"), autogenerate_cs(ctx.items())).expect("Failed to write C# bindings");
    std::fs::write(directory.join("egui.rs"), autogenerate_rs(ctx.items(), ctx.optional_types())).expect("Failed to write Rust bindings");
}

/*
KEY QUESTION TO ANSWER:
- How to copy data between C# and Rust? I really need some kind of ABI.
  Specifically, when function calls happen, we assume always C# -> Rust.
  Therefore, we must have:
   > A way to pin C# objects and set them up for borrowing + a way to convert to the Rust FFI type
   > The function call proper
   > A conversion from Rust to C# again
   > Cleanup for handles and strings that may not be done



*/